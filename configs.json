{
    "versions": [
        "3.5.2",
        "3.6.0",
        "3.6.1",
        "3.6.2",
        "3.7.0",
        "3.7.1",
        "3.8.0",
        "3.8.1",
        "3.9.0",
        "3.9.1",
        "4.0.0",
        "4.0.1",
        "5.0.0",
        "5.0.1",
        "5.0.2",
        "6.0.0",
        "6.0.1",
        "HEAD"
    ],
    "3.5.2": {
        "BasedOnStyle": {
            "type": "string",
            "doc": "<p>  The style used for all options not specifically set in the configuration.</p>\n<p>  This option is supported only in the <strong>clang-format</strong> configuration\n  (both within <code>-style=&#39;{...}&#39;</code> and the <code>.clang-format</code> file).</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LLVM</code>\nA style complying with the <a href=\"http://llvm.org/docs/CodingStandards.html\">LLVM coding standards</a></li>\n<li><code>Google</code>\nA style complying with <a href=\"http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml\">Google&#39;s C++ style guide</a></li>\n<li><code>Chromium</code>\nA style complying with <a href=\"http://www.chromium.org/developers/coding-style\">Chromium&#39;s style guide</a></li>\n<li><code>Mozilla</code>\nA style complying with <a href=\"https://developer.mozilla.org/en-US/docs/Developer_Guide/Coding_Style\">Mozilla&#39;s style guide</a></li>\n<li><code>WebKit</code>\nA style complying with <a href=\"http://www.webkit.org/coding/coding-style.html\">WebKit&#39;s style guide</a></li>\n</ul>\n",
            "options": [
                "LLVM",
                "Google",
                "Chromium",
                "Mozilla",
                "WebKit"
            ]
        },
        "AccessModifierOffset": {
            "type": "int",
            "doc": "<p>  The extra indent or outdent of access modifiers, e.g. <code>public:</code>.</p>\n"
        },
        "AlignEscapedNewlinesLeft": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns escaped newlines as far left as possible.\n  Otherwise puts them into the right-most column.</p>\n"
        },
        "AlignTrailingComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns trailing comments.</p>\n"
        },
        "AllowAllParametersOfDeclarationOnNextLine": {
            "type": "bool",
            "doc": "<p>  Allow putting all parameters of a function declaration onto\n  the next line even if <code>BinPackParameters</code> is <code>false</code>.</p>\n"
        },
        "AllowShortBlocksOnASingleLine": {
            "type": "bool",
            "doc": "<p>  Allows contracting simple braced statements to a single line.</p>\n<p>  E.g., this allows <code>if (a) { return; }</code> to be put on a single line.</p>\n"
        },
        "AllowShortFunctionsOnASingleLine": {
            "type": "ShortFunctionStyle",
            "doc": "<p>  Dependent on the value, <code>int f() { return 0; }</code> can be put\n  on a single line.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>SFS_None</code> (in configuration: <code>None</code>)\nNever merge functions into a single line.</li>\n<li><code>SFS_Inline</code> (in configuration: <code>Inline</code>)\nOnly merge functions defined inside a class.</li>\n<li><code>SFS_All</code> (in configuration: <code>All</code>)\nMerge all functions fitting on a single line.</li>\n</ul>\n",
            "options": [
                "None",
                "Inline",
                "All"
            ]
        },
        "AllowShortIfStatementsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>if (a) return;</code> can be put on a single\n  line.</p>\n"
        },
        "AllowShortLoopsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>while (true) continue;</code> can be put on a\n  single line.</p>\n"
        },
        "AlwaysBreakBeforeMultilineStrings": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break before multiline string literals.</p>\n"
        },
        "AlwaysBreakTemplateDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break after the <code>template&lt;...&gt;</code> of a\n  template declaration.</p>\n"
        },
        "BinPackParameters": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function call&#39;s or function definition&#39;s parameters\n  will either all be on the same line or will have one line each.</p>\n"
        },
        "BreakBeforeBinaryOperators": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, binary operators will be placed after line breaks.</p>\n"
        },
        "BreakBeforeBraces": {
            "type": "BraceBreakingStyle",
            "doc": "<p>  The brace breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>BS_Attach</code> (in configuration: <code>Attach</code>)\nAlways attach braces to surrounding context.</li>\n<li><code>BS_Linux</code> (in configuration: <code>Linux</code>)\nLike <code>Attach</code>, but break before braces on function, namespace and\nclass definitions.</li>\n<li><code>BS_Stroustrup</code> (in configuration: <code>Stroustrup</code>)\nLike <code>Attach</code>, but break before function definitions.</li>\n<li><code>BS_Allman</code> (in configuration: <code>Allman</code>)\nAlways break before braces.</li>\n<li><code>BS_GNU</code> (in configuration: <code>GNU</code>)\nAlways break before braces and add an extra level of indentation to\nbraces of control statements, not to those of class, function\nor other definitions.</li>\n</ul>\n",
            "options": [
                "Attach",
                "Linux",
                "Stroustrup",
                "Allman",
                "GNU"
            ]
        },
        "BreakBeforeTernaryOperators": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, ternary operators will be placed after line breaks.</p>\n"
        },
        "BreakConstructorInitializersBeforeComma": {
            "type": "bool",
            "doc": "<p>  Always break constructor initializers before commas and align\n  the commas with the colon.</p>\n"
        },
        "ColumnLimit": {
            "type": "unsigned",
            "doc": "<p>  The column limit.</p>\n<p>  A column limit of <code>0</code> means that there is no column limit. In this case,\n  clang-format will respect the input&#39;s line breaking decisions within\n  statements unless they contradict other rules.</p>\n"
        },
        "CommentPragmas": {
            "type": "std::string",
            "doc": "<p>  A regular expression that describes comments with special meaning,\n  which should not be split into lines or otherwise changed.</p>\n"
        },
        "ConstructorInitializerAllOnOneLineOrOnePerLine": {
            "type": "bool",
            "doc": "<p>  If the constructor initializers don&#39;t fit on a line, put each\n  initializer on its own line.</p>\n"
        },
        "ConstructorInitializerIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of constructor\n  initializer lists.</p>\n"
        },
        "ContinuationIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  Indent width for line continuations.</p>\n"
        },
        "Cpp11BracedListStyle": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, format braced lists as best suited for C++11 braced\n  lists.</p>\n<p>  Important differences:</p>\n<ul>\n<li>No spaces inside the braced list.</li>\n<li>No line break before the closing brace.</li>\n<li><p>Indentation with the continuation indent, not with the block indent.</p>\n<p>Fundamentally, C++11 braced lists are formatted exactly like function\ncalls would be formatted in their place. If the braced list follows a name\n(e.g. a type or variable name), clang-format formats as if the <code>{}</code> were\nthe parentheses of a function call with that name. If there is no name,\na zero-length name is assumed.</p>\n</li>\n</ul>\n"
        },
        "DerivePointerAlignment": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, analyze the formatted file for the most common\n  alignment of &amp; and *. <code>PointerAlignment</code> is then used only as fallback.</p>\n"
        },
        "DisableFormat": {
            "type": "bool",
            "doc": "<p>  Disables formatting at all.</p>\n"
        },
        "ExperimentalAutoDetectBinPacking": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format detects whether function calls and\n  definitions are formatted with one parameter per line.</p>\n<p>  Each call can be bin-packed, one-per-line or inconclusive. If it is\n  inconclusive, e.g. completely on one line, but a decision needs to be\n  made, clang-format analyzes whether there are other bin-packed cases in\n  the input file and act accordingly.</p>\n<p>  NOTE: This is an experimental flag, that might go away or be renamed. Do\n  not use this in config files, etc. Use at your own risk.</p>\n"
        },
        "ForEachMacros": {
            "type": "std::vector<std::string>",
            "doc": "<p>  A vector of macros that should be interpreted as foreach loops\n  instead of as function calls.</p>\n<p>  These are expected to be macros of the form:</p>\n<pre><code class=\"lang-  \">  FOREACH(&lt;variable-declaration&gt;, ...)\n  &lt;loop-body&gt;\n</code></pre>\n<p>  For example: BOOST_FOREACH.</p>\n"
        },
        "IndentCaseLabels": {
            "type": "bool",
            "doc": "<p>  Indent case labels one level from the switch statement.</p>\n<p>  When <code>false</code>, use the same indentation level as for the switch statement.\n  Switch statement body is always indented one level more than case labels.</p>\n"
        },
        "IndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns to use for indentation.</p>\n"
        },
        "IndentWrappedFunctionNames": {
            "type": "bool",
            "doc": "<p>  Indent if a function definition or declaration is wrapped after the\n  type.</p>\n"
        },
        "KeepEmptyLinesAtTheStartOfBlocks": {
            "type": "bool",
            "doc": "<p>  If true, empty lines at the start of blocks are kept.</p>\n"
        },
        "Language": {
            "type": "LanguageKind",
            "doc": "<p>  Language, this format style is targeted at.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LK_None</code> (in configuration: <code>None</code>)\nDo not use.</li>\n<li><code>LK_Cpp</code> (in configuration: <code>Cpp</code>)\nShould be used for C, C++, ObjectiveC, ObjectiveC++.</li>\n<li><code>LK_JavaScript</code> (in configuration: <code>JavaScript</code>)\nShould be used for JavaScript.</li>\n<li><code>LK_Proto</code> (in configuration: <code>Proto</code>)\nShould be used for Protocol Buffers\n(https://developers.google.com/protocol-buffers/).</li>\n</ul>\n",
            "options": [
                "None",
                "Cpp",
                "JavaScript",
                "Proto"
            ]
        },
        "MaxEmptyLinesToKeep": {
            "type": "unsigned",
            "doc": "<p>  The maximum number of consecutive empty lines to keep.</p>\n"
        },
        "NamespaceIndentation": {
            "type": "NamespaceIndentationKind",
            "doc": "<p>  The indentation used for namespaces.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>NI_None</code> (in configuration: <code>None</code>)\nDon&#39;t indent in namespaces.</li>\n<li><code>NI_Inner</code> (in configuration: <code>Inner</code>)\nIndent only in inner namespaces (nested in other namespaces).</li>\n<li><code>NI_All</code> (in configuration: <code>All</code>)\nIndent in all namespaces.</li>\n</ul>\n",
            "options": [
                "None",
                "Inner",
                "All"
            ]
        },
        "ObjCSpaceAfterProperty": {
            "type": "bool",
            "doc": "<p>  Add a space after <code>@property</code> in Objective-C, i.e. use\n  <code>\\@property (readonly)</code> instead of <code>\\@property(readonly)</code>.</p>\n"
        },
        "ObjCSpaceBeforeProtocolList": {
            "type": "bool",
            "doc": "<p>  Add a space in front of an Objective-C protocol list, i.e. use\n  <code>Foo &lt;Protocol&gt;</code> instead of <code>Foo&lt;Protocol&gt;</code>.</p>\n"
        },
        "PenaltyBreakBeforeFirstCallParameter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking a function call after &quot;call(&quot;.</p>\n"
        },
        "PenaltyBreakComment": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a comment.</p>\n"
        },
        "PenaltyBreakFirstLessLess": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking before the first <code>&lt;&lt;</code>.</p>\n"
        },
        "PenaltyBreakString": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a string literal.</p>\n"
        },
        "PenaltyExcessCharacter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each character outside of the column limit.</p>\n"
        },
        "PenaltyReturnTypeOnItsOwnLine": {
            "type": "unsigned",
            "doc": "<p>  Penalty for putting the return type of a function onto its own\n  line.</p>\n"
        },
        "PointerAlignment": {
            "type": "PointerAlignmentStyle",
            "doc": "<p>  Pointer and reference alignment style.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>PAS_Left</code> (in configuration: <code>Left</code>)\nAlign pointer to the left.</li>\n<li><code>PAS_Right</code> (in configuration: <code>Right</code>)\nAlign pointer to the right.</li>\n<li><code>PAS_Middle</code> (in configuration: <code>Middle</code>)\nAlign pointer in the middle.</li>\n</ul>\n",
            "options": [
                "Left",
                "Right",
                "Middle"
            ]
        },
        "SpaceBeforeAssignmentOperators": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, spaces will be removed before assignment operators.</p>\n"
        },
        "SpaceBeforeParens": {
            "type": "SpaceBeforeParensOptions",
            "doc": "<p>  Defines in which cases to put a space before opening parentheses.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>SBPO_Never</code> (in configuration: <code>Never</code>)\nNever put a space before opening parentheses.</li>\n<li><code>SBPO_ControlStatements</code> (in configuration: <code>ControlStatements</code>)\nPut a space before opening parentheses only after control statement\nkeywords (<code>for/if/while...</code>).</li>\n<li><code>SBPO_Always</code> (in configuration: <code>Always</code>)\nAlways put a space before opening parentheses, except when it&#39;s\nprohibited by the syntax rules (in function-like macro definitions) or\nwhen determined by other style rules (after unary operators, opening\nparentheses, etc.)</li>\n</ul>\n",
            "options": [
                "Never",
                "ControlStatements",
                "Always"
            ]
        },
        "SpaceInEmptyParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into &#39;()&#39;.</p>\n"
        },
        "SpacesBeforeTrailingComments": {
            "type": "unsigned",
            "doc": "<p>  The number of spaces before trailing line comments\n  (<code>//</code> - comments).</p>\n<p>  This does not affect trailing block comments (<code>/**/</code> - comments) as those\n  commonly have different usage patterns and a number of special cases.</p>\n"
        },
        "SpacesInAngles": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after &#39;&lt;&#39; and before &#39;&gt;&#39; in\n  template argument lists</p>\n"
        },
        "SpacesInCStyleCastParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into C style casts.</p>\n"
        },
        "SpacesInContainerLiterals": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces are inserted inside container literals (e.g.\n  ObjC and Javascript array and dict literals).</p>\n"
        },
        "SpacesInParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after &#39;(&#39; and before &#39;)&#39;.</p>\n"
        },
        "Standard": {
            "type": "LanguageStandard",
            "doc": "<p>  Format compatible with this standard, e.g. use\n  <code>A&lt;A&lt;int&gt; &gt;</code> instead of <code>A&lt;A&lt;int&gt;&gt;</code> for LS_Cpp03.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LS_Cpp03</code> (in configuration: <code>Cpp03</code>)\nUse C++03-compatible syntax.</li>\n<li><code>LS_Cpp11</code> (in configuration: <code>Cpp11</code>)\nUse features of C++11 (e.g. <code>A&lt;A&lt;int&gt;&gt;</code> instead of\n<code>A&lt;A&lt;int&gt; &gt;</code>).</li>\n<li><code>LS_Auto</code> (in configuration: <code>Auto</code>)\nAutomatic detection based on the input.</li>\n</ul>\n",
            "options": [
                "Cpp03",
                "Cpp11",
                "Auto"
            ]
        },
        "TabWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns used for tab stops.</p>\n"
        },
        "UseTab": {
            "type": "UseTabStyle",
            "doc": "<p>  The way to use tab characters in the resulting file.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>UT_Never</code> (in configuration: <code>Never</code>)\nNever use tab.</li>\n<li><code>UT_ForIndentation</code> (in configuration: <code>ForIndentation</code>)\nUse tabs only for indentation.</li>\n<li><code>UT_Always</code> (in configuration: <code>Always</code>)\nUse tabs whenever we need to fill whitespace that spans at least from\none tab stop to the next one.</li>\n</ul>\n",
            "options": [
                "Never",
                "ForIndentation",
                "Always"
            ]
        }
    },
    "3.6.0": {
        "BasedOnStyle": {
            "type": "string",
            "doc": "<p>  The style used for all options not specifically set in the configuration.</p>\n<p>  This option is supported only in the <strong>clang-format</strong> configuration\n  (both within <code>-style=&#39;{...}&#39;</code> and the <code>.clang-format</code> file).</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LLVM</code>\nA style complying with the <a href=\"http://llvm.org/docs/CodingStandards.html\">LLVM coding standards</a></li>\n<li><code>Google</code>\nA style complying with <a href=\"http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml\">Google&#39;s C++ style guide</a></li>\n<li><code>Chromium</code>\nA style complying with <a href=\"http://www.chromium.org/developers/coding-style\">Chromium&#39;s style guide</a></li>\n<li><code>Mozilla</code>\nA style complying with <a href=\"https://developer.mozilla.org/en-US/docs/Developer_Guide/Coding_Style\">Mozilla&#39;s style guide</a></li>\n<li><code>WebKit</code>\nA style complying with <a href=\"http://www.webkit.org/coding/coding-style.html\">WebKit&#39;s style guide</a></li>\n</ul>\n",
            "options": [
                "LLVM",
                "Google",
                "Chromium",
                "Mozilla",
                "WebKit"
            ]
        },
        "AccessModifierOffset": {
            "type": "int",
            "doc": "<p>  The extra indent or outdent of access modifiers, e.g. <code>public:</code>.</p>\n"
        },
        "AlignAfterOpenBracket": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, horizontally aligns arguments after an open bracket.</p>\n<p>  This applies to round brackets (parentheses), angle brackets and square\n  brackets. This will result in formattings like</p>\n<pre><code class=\"lang-  \">  someLongFunction(argument1,\n  argument2);\n</code></pre>\n"
        },
        "AlignEscapedNewlinesLeft": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns escaped newlines as far left as possible.\n  Otherwise puts them into the right-most column.</p>\n"
        },
        "AlignOperands": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, horizontally align operands of binary and ternary\n  expressions.</p>\n"
        },
        "AlignTrailingComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns trailing comments.</p>\n"
        },
        "AllowAllParametersOfDeclarationOnNextLine": {
            "type": "bool",
            "doc": "<p>  Allow putting all parameters of a function declaration onto\n  the next line even if <code>BinPackParameters</code> is <code>false</code>.</p>\n"
        },
        "AllowShortBlocksOnASingleLine": {
            "type": "bool",
            "doc": "<p>  Allows contracting simple braced statements to a single line.</p>\n<p>  E.g., this allows <code>if (a) { return; }</code> to be put on a single line.</p>\n"
        },
        "AllowShortCaseLabelsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, short case labels will be contracted to a single line.</p>\n"
        },
        "AllowShortFunctionsOnASingleLine": {
            "type": "ShortFunctionStyle",
            "doc": "<p>  Dependent on the value, <code>int f() { return 0; }</code> can be put\n  on a single line.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>SFS_None</code> (in configuration: <code>None</code>)\nNever merge functions into a single line.</li>\n<li><code>SFS_Inline</code> (in configuration: <code>Inline</code>)\nOnly merge functions defined inside a class.</li>\n<li><code>SFS_Empty</code> (in configuration: <code>Empty</code>)\nOnly merge empty functions.</li>\n<li><code>SFS_All</code> (in configuration: <code>All</code>)\nMerge all functions fitting on a single line.</li>\n</ul>\n",
            "options": [
                "None",
                "Inline",
                "Empty",
                "All"
            ]
        },
        "AllowShortIfStatementsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>if (a) return;</code> can be put on a single\n  line.</p>\n"
        },
        "AllowShortLoopsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>while (true) continue;</code> can be put on a\n  single line.</p>\n"
        },
        "AlwaysBreakAfterDefinitionReturnType": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break after function definition return types.</p>\n<p>  More truthfully called &#39;break before the identifier following the type\n  in a function definition&#39;. PenaltyReturnTypeOnItsOwnLine becomes\n  irrelevant.</p>\n"
        },
        "AlwaysBreakBeforeMultilineStrings": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break before multiline string literals.</p>\n"
        },
        "AlwaysBreakTemplateDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break after the <code>template&lt;...&gt;</code> of a\n  template declaration.</p>\n"
        },
        "BinPackArguments": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function call&#39;s arguments will either be all on the\n  same line or will have one line each.</p>\n"
        },
        "BinPackParameters": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function declaration&#39;s or function definition&#39;s\n  parameters will either all be on the same line or will have one line each.</p>\n"
        },
        "BreakBeforeBinaryOperators": {
            "type": "BinaryOperatorStyle",
            "doc": "<p>  The way to wrap binary operators.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>BOS_None</code> (in configuration: <code>None</code>)\nBreak after operators.</li>\n<li><code>BOS_NonAssignment</code> (in configuration: <code>NonAssignment</code>)\nBreak before operators that aren&#39;t assignments.</li>\n<li><code>BOS_All</code> (in configuration: <code>All</code>)\nBreak before operators.</li>\n</ul>\n",
            "options": [
                "None",
                "NonAssignment",
                "All"
            ]
        },
        "BreakBeforeBraces": {
            "type": "BraceBreakingStyle",
            "doc": "<p>  The brace breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>BS_Attach</code> (in configuration: <code>Attach</code>)\nAlways attach braces to surrounding context.</li>\n<li><code>BS_Linux</code> (in configuration: <code>Linux</code>)\nLike <code>Attach</code>, but break before braces on function, namespace and\nclass definitions.</li>\n<li><code>BS_Stroustrup</code> (in configuration: <code>Stroustrup</code>)\nLike <code>Attach</code>, but break before function definitions, and &#39;else&#39;.</li>\n<li><code>BS_Allman</code> (in configuration: <code>Allman</code>)\nAlways break before braces.</li>\n<li><code>BS_GNU</code> (in configuration: <code>GNU</code>)\nAlways break before braces and add an extra level of indentation to\nbraces of control statements, not to those of class, function\nor other definitions.</li>\n</ul>\n",
            "options": [
                "Attach",
                "Linux",
                "Stroustrup",
                "Allman",
                "GNU"
            ]
        },
        "BreakBeforeTernaryOperators": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, ternary operators will be placed after line breaks.</p>\n"
        },
        "BreakConstructorInitializersBeforeComma": {
            "type": "bool",
            "doc": "<p>  Always break constructor initializers before commas and align\n  the commas with the colon.</p>\n"
        },
        "ColumnLimit": {
            "type": "unsigned",
            "doc": "<p>  The column limit.</p>\n<p>  A column limit of <code>0</code> means that there is no column limit. In this case,\n  clang-format will respect the input&#39;s line breaking decisions within\n  statements unless they contradict other rules.</p>\n"
        },
        "CommentPragmas": {
            "type": "std::string",
            "doc": "<p>  A regular expression that describes comments with special meaning,\n  which should not be split into lines or otherwise changed.</p>\n"
        },
        "ConstructorInitializerAllOnOneLineOrOnePerLine": {
            "type": "bool",
            "doc": "<p>  If the constructor initializers don&#39;t fit on a line, put each\n  initializer on its own line.</p>\n"
        },
        "ConstructorInitializerIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of constructor\n  initializer lists.</p>\n"
        },
        "ContinuationIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  Indent width for line continuations.</p>\n"
        },
        "Cpp11BracedListStyle": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, format braced lists as best suited for C++11 braced\n  lists.</p>\n<p>  Important differences:</p>\n<ul>\n<li>No spaces inside the braced list.</li>\n<li>No line break before the closing brace.</li>\n<li><p>Indentation with the continuation indent, not with the block indent.</p>\n<p>Fundamentally, C++11 braced lists are formatted exactly like function\ncalls would be formatted in their place. If the braced list follows a name\n(e.g. a type or variable name), clang-format formats as if the <code>{}</code> were\nthe parentheses of a function call with that name. If there is no name,\na zero-length name is assumed.</p>\n</li>\n</ul>\n"
        },
        "DerivePointerAlignment": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, analyze the formatted file for the most common\n  alignment of &amp; and *. <code>PointerAlignment</code> is then used only as fallback.</p>\n"
        },
        "DisableFormat": {
            "type": "bool",
            "doc": "<p>  Disables formatting at all.</p>\n"
        },
        "ExperimentalAutoDetectBinPacking": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format detects whether function calls and\n  definitions are formatted with one parameter per line.</p>\n<p>  Each call can be bin-packed, one-per-line or inconclusive. If it is\n  inconclusive, e.g. completely on one line, but a decision needs to be\n  made, clang-format analyzes whether there are other bin-packed cases in\n  the input file and act accordingly.</p>\n<p>  NOTE: This is an experimental flag, that might go away or be renamed. Do\n  not use this in config files, etc. Use at your own risk.</p>\n"
        },
        "ForEachMacros": {
            "type": "std::vector<std::string>",
            "doc": "<p>  A vector of macros that should be interpreted as foreach loops\n  instead of as function calls.</p>\n<p>  These are expected to be macros of the form:</p>\n<pre><code class=\"lang-  \">  FOREACH(&lt;variable-declaration&gt;, ...)\n  &lt;loop-body&gt;\n</code></pre>\n<p>  For example: BOOST_FOREACH.</p>\n"
        },
        "IndentCaseLabels": {
            "type": "bool",
            "doc": "<p>  Indent case labels one level from the switch statement.</p>\n<p>  When <code>false</code>, use the same indentation level as for the switch statement.\n  Switch statement body is always indented one level more than case labels.</p>\n"
        },
        "IndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns to use for indentation.</p>\n"
        },
        "IndentWrappedFunctionNames": {
            "type": "bool",
            "doc": "<p>  Indent if a function definition or declaration is wrapped after the\n  type.</p>\n"
        },
        "KeepEmptyLinesAtTheStartOfBlocks": {
            "type": "bool",
            "doc": "<p>  If true, empty lines at the start of blocks are kept.</p>\n"
        },
        "Language": {
            "type": "LanguageKind",
            "doc": "<p>  Language, this format style is targeted at.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LK_None</code> (in configuration: <code>None</code>)\nDo not use.</li>\n<li><code>LK_Cpp</code> (in configuration: <code>Cpp</code>)\nShould be used for C, C++, ObjectiveC, ObjectiveC++.</li>\n<li><code>LK_Java</code> (in configuration: <code>Java</code>)\nShould be used for Java.</li>\n<li><code>LK_JavaScript</code> (in configuration: <code>JavaScript</code>)\nShould be used for JavaScript.</li>\n<li><code>LK_Proto</code> (in configuration: <code>Proto</code>)\nShould be used for Protocol Buffers\n(https://developers.google.com/protocol-buffers/).</li>\n</ul>\n",
            "options": [
                "None",
                "Cpp",
                "Java",
                "JavaScript",
                "Proto"
            ]
        },
        "MaxEmptyLinesToKeep": {
            "type": "unsigned",
            "doc": "<p>  The maximum number of consecutive empty lines to keep.</p>\n"
        },
        "NamespaceIndentation": {
            "type": "NamespaceIndentationKind",
            "doc": "<p>  The indentation used for namespaces.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>NI_None</code> (in configuration: <code>None</code>)\nDon&#39;t indent in namespaces.</li>\n<li><code>NI_Inner</code> (in configuration: <code>Inner</code>)\nIndent only in inner namespaces (nested in other namespaces).</li>\n<li><code>NI_All</code> (in configuration: <code>All</code>)\nIndent in all namespaces.</li>\n</ul>\n",
            "options": [
                "None",
                "Inner",
                "All"
            ]
        },
        "ObjCBlockIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of ObjC blocks.</p>\n"
        },
        "ObjCSpaceAfterProperty": {
            "type": "bool",
            "doc": "<p>  Add a space after <code>@property</code> in Objective-C, i.e. use\n  <code>\\@property (readonly)</code> instead of <code>\\@property(readonly)</code>.</p>\n"
        },
        "ObjCSpaceBeforeProtocolList": {
            "type": "bool",
            "doc": "<p>  Add a space in front of an Objective-C protocol list, i.e. use\n  <code>Foo &lt;Protocol&gt;</code> instead of <code>Foo&lt;Protocol&gt;</code>.</p>\n"
        },
        "PenaltyBreakBeforeFirstCallParameter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking a function call after &quot;call(&quot;.</p>\n"
        },
        "PenaltyBreakComment": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a comment.</p>\n"
        },
        "PenaltyBreakFirstLessLess": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking before the first <code>&lt;&lt;</code>.</p>\n"
        },
        "PenaltyBreakString": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a string literal.</p>\n"
        },
        "PenaltyExcessCharacter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each character outside of the column limit.</p>\n"
        },
        "PenaltyReturnTypeOnItsOwnLine": {
            "type": "unsigned",
            "doc": "<p>  Penalty for putting the return type of a function onto its own\n  line.</p>\n"
        },
        "PointerAlignment": {
            "type": "PointerAlignmentStyle",
            "doc": "<p>  Pointer and reference alignment style.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>PAS_Left</code> (in configuration: <code>Left</code>)\nAlign pointer to the left.</li>\n<li><code>PAS_Right</code> (in configuration: <code>Right</code>)\nAlign pointer to the right.</li>\n<li><code>PAS_Middle</code> (in configuration: <code>Middle</code>)\nAlign pointer in the middle.</li>\n</ul>\n",
            "options": [
                "Left",
                "Right",
                "Middle"
            ]
        },
        "SpaceAfterCStyleCast": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, a space may be inserted after C style casts.</p>\n"
        },
        "SpaceBeforeAssignmentOperators": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, spaces will be removed before assignment operators.</p>\n"
        },
        "SpaceBeforeParens": {
            "type": "SpaceBeforeParensOptions",
            "doc": "<p>  Defines in which cases to put a space before opening parentheses.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>SBPO_Never</code> (in configuration: <code>Never</code>)\nNever put a space before opening parentheses.</li>\n<li><code>SBPO_ControlStatements</code> (in configuration: <code>ControlStatements</code>)\nPut a space before opening parentheses only after control statement\nkeywords (<code>for/if/while...</code>).</li>\n<li><code>SBPO_Always</code> (in configuration: <code>Always</code>)\nAlways put a space before opening parentheses, except when it&#39;s\nprohibited by the syntax rules (in function-like macro definitions) or\nwhen determined by other style rules (after unary operators, opening\nparentheses, etc.)</li>\n</ul>\n",
            "options": [
                "Never",
                "ControlStatements",
                "Always"
            ]
        },
        "SpaceInEmptyParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into &#39;()&#39;.</p>\n"
        },
        "SpacesBeforeTrailingComments": {
            "type": "unsigned",
            "doc": "<p>  The number of spaces before trailing line comments\n  (<code>//</code> - comments).</p>\n<p>  This does not affect trailing block comments (<code>/**/</code> - comments) as those\n  commonly have different usage patterns and a number of special cases.</p>\n"
        },
        "SpacesInAngles": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after &#39;&lt;&#39; and before &#39;&gt;&#39; in\n  template argument lists</p>\n"
        },
        "SpacesInCStyleCastParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into C style casts.</p>\n"
        },
        "SpacesInContainerLiterals": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces are inserted inside container literals (e.g.\n  ObjC and Javascript array and dict literals).</p>\n"
        },
        "SpacesInParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after &#39;(&#39; and before &#39;)&#39;.</p>\n"
        },
        "SpacesInSquareBrackets": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after &#39;[&#39; and before &#39;]&#39;.</p>\n"
        },
        "Standard": {
            "type": "LanguageStandard",
            "doc": "<p>  Format compatible with this standard, e.g. use\n  <code>A&lt;A&lt;int&gt; &gt;</code> instead of <code>A&lt;A&lt;int&gt;&gt;</code> for LS_Cpp03.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LS_Cpp03</code> (in configuration: <code>Cpp03</code>)\nUse C++03-compatible syntax.</li>\n<li><code>LS_Cpp11</code> (in configuration: <code>Cpp11</code>)\nUse features of C++11 (e.g. <code>A&lt;A&lt;int&gt;&gt;</code> instead of\n<code>A&lt;A&lt;int&gt; &gt;</code>).</li>\n<li><code>LS_Auto</code> (in configuration: <code>Auto</code>)\nAutomatic detection based on the input.</li>\n</ul>\n",
            "options": [
                "Cpp03",
                "Cpp11",
                "Auto"
            ]
        },
        "TabWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns used for tab stops.</p>\n"
        },
        "UseTab": {
            "type": "UseTabStyle",
            "doc": "<p>  The way to use tab characters in the resulting file.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>UT_Never</code> (in configuration: <code>Never</code>)\nNever use tab.</li>\n<li><code>UT_ForIndentation</code> (in configuration: <code>ForIndentation</code>)\nUse tabs only for indentation.</li>\n<li><code>UT_Always</code> (in configuration: <code>Always</code>)\nUse tabs whenever we need to fill whitespace that spans at least from\none tab stop to the next one.</li>\n</ul>\n",
            "options": [
                "Never",
                "ForIndentation",
                "Always"
            ]
        }
    },
    "3.6.1": {
        "BasedOnStyle": {
            "type": "string",
            "doc": "<p>  The style used for all options not specifically set in the configuration.</p>\n<p>  This option is supported only in the <strong>clang-format</strong> configuration\n  (both within <code>-style=&#39;{...}&#39;</code> and the <code>.clang-format</code> file).</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LLVM</code>\nA style complying with the <a href=\"http://llvm.org/docs/CodingStandards.html\">LLVM coding standards</a></li>\n<li><code>Google</code>\nA style complying with <a href=\"http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml\">Google&#39;s C++ style guide</a></li>\n<li><code>Chromium</code>\nA style complying with <a href=\"http://www.chromium.org/developers/coding-style\">Chromium&#39;s style guide</a></li>\n<li><code>Mozilla</code>\nA style complying with <a href=\"https://developer.mozilla.org/en-US/docs/Developer_Guide/Coding_Style\">Mozilla&#39;s style guide</a></li>\n<li><code>WebKit</code>\nA style complying with <a href=\"http://www.webkit.org/coding/coding-style.html\">WebKit&#39;s style guide</a></li>\n</ul>\n",
            "options": [
                "LLVM",
                "Google",
                "Chromium",
                "Mozilla",
                "WebKit"
            ]
        },
        "AccessModifierOffset": {
            "type": "int",
            "doc": "<p>  The extra indent or outdent of access modifiers, e.g. <code>public:</code>.</p>\n"
        },
        "AlignAfterOpenBracket": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, horizontally aligns arguments after an open bracket.</p>\n<p>  This applies to round brackets (parentheses), angle brackets and square\n  brackets. This will result in formattings like</p>\n<pre><code class=\"lang-  \">  someLongFunction(argument1,\n  argument2);\n</code></pre>\n"
        },
        "AlignEscapedNewlinesLeft": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns escaped newlines as far left as possible.\n  Otherwise puts them into the right-most column.</p>\n"
        },
        "AlignOperands": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, horizontally align operands of binary and ternary\n  expressions.</p>\n"
        },
        "AlignTrailingComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns trailing comments.</p>\n"
        },
        "AllowAllParametersOfDeclarationOnNextLine": {
            "type": "bool",
            "doc": "<p>  Allow putting all parameters of a function declaration onto\n  the next line even if <code>BinPackParameters</code> is <code>false</code>.</p>\n"
        },
        "AllowShortBlocksOnASingleLine": {
            "type": "bool",
            "doc": "<p>  Allows contracting simple braced statements to a single line.</p>\n<p>  E.g., this allows <code>if (a) { return; }</code> to be put on a single line.</p>\n"
        },
        "AllowShortCaseLabelsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, short case labels will be contracted to a single line.</p>\n"
        },
        "AllowShortFunctionsOnASingleLine": {
            "type": "ShortFunctionStyle",
            "doc": "<p>  Dependent on the value, <code>int f() { return 0; }</code> can be put\n  on a single line.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>SFS_None</code> (in configuration: <code>None</code>)\nNever merge functions into a single line.</li>\n<li><code>SFS_Inline</code> (in configuration: <code>Inline</code>)\nOnly merge functions defined inside a class.</li>\n<li><code>SFS_Empty</code> (in configuration: <code>Empty</code>)\nOnly merge empty functions.</li>\n<li><code>SFS_All</code> (in configuration: <code>All</code>)\nMerge all functions fitting on a single line.</li>\n</ul>\n",
            "options": [
                "None",
                "Inline",
                "Empty",
                "All"
            ]
        },
        "AllowShortIfStatementsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>if (a) return;</code> can be put on a single\n  line.</p>\n"
        },
        "AllowShortLoopsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>while (true) continue;</code> can be put on a\n  single line.</p>\n"
        },
        "AlwaysBreakAfterDefinitionReturnType": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break after function definition return types.</p>\n<p>  More truthfully called &#39;break before the identifier following the type\n  in a function definition&#39;. PenaltyReturnTypeOnItsOwnLine becomes\n  irrelevant.</p>\n"
        },
        "AlwaysBreakBeforeMultilineStrings": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break before multiline string literals.</p>\n"
        },
        "AlwaysBreakTemplateDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break after the <code>template&lt;...&gt;</code> of a\n  template declaration.</p>\n"
        },
        "BinPackArguments": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function call&#39;s arguments will either be all on the\n  same line or will have one line each.</p>\n"
        },
        "BinPackParameters": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function declaration&#39;s or function definition&#39;s\n  parameters will either all be on the same line or will have one line each.</p>\n"
        },
        "BreakBeforeBinaryOperators": {
            "type": "BinaryOperatorStyle",
            "doc": "<p>  The way to wrap binary operators.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>BOS_None</code> (in configuration: <code>None</code>)\nBreak after operators.</li>\n<li><code>BOS_NonAssignment</code> (in configuration: <code>NonAssignment</code>)\nBreak before operators that aren&#39;t assignments.</li>\n<li><code>BOS_All</code> (in configuration: <code>All</code>)\nBreak before operators.</li>\n</ul>\n",
            "options": [
                "None",
                "NonAssignment",
                "All"
            ]
        },
        "BreakBeforeBraces": {
            "type": "BraceBreakingStyle",
            "doc": "<p>  The brace breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>BS_Attach</code> (in configuration: <code>Attach</code>)\nAlways attach braces to surrounding context.</li>\n<li><code>BS_Linux</code> (in configuration: <code>Linux</code>)\nLike <code>Attach</code>, but break before braces on function, namespace and\nclass definitions.</li>\n<li><code>BS_Stroustrup</code> (in configuration: <code>Stroustrup</code>)\nLike <code>Attach</code>, but break before function definitions, and &#39;else&#39;.</li>\n<li><code>BS_Allman</code> (in configuration: <code>Allman</code>)\nAlways break before braces.</li>\n<li><code>BS_GNU</code> (in configuration: <code>GNU</code>)\nAlways break before braces and add an extra level of indentation to\nbraces of control statements, not to those of class, function\nor other definitions.</li>\n</ul>\n",
            "options": [
                "Attach",
                "Linux",
                "Stroustrup",
                "Allman",
                "GNU"
            ]
        },
        "BreakBeforeTernaryOperators": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, ternary operators will be placed after line breaks.</p>\n"
        },
        "BreakConstructorInitializersBeforeComma": {
            "type": "bool",
            "doc": "<p>  Always break constructor initializers before commas and align\n  the commas with the colon.</p>\n"
        },
        "ColumnLimit": {
            "type": "unsigned",
            "doc": "<p>  The column limit.</p>\n<p>  A column limit of <code>0</code> means that there is no column limit. In this case,\n  clang-format will respect the input&#39;s line breaking decisions within\n  statements unless they contradict other rules.</p>\n"
        },
        "CommentPragmas": {
            "type": "std::string",
            "doc": "<p>  A regular expression that describes comments with special meaning,\n  which should not be split into lines or otherwise changed.</p>\n"
        },
        "ConstructorInitializerAllOnOneLineOrOnePerLine": {
            "type": "bool",
            "doc": "<p>  If the constructor initializers don&#39;t fit on a line, put each\n  initializer on its own line.</p>\n"
        },
        "ConstructorInitializerIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of constructor\n  initializer lists.</p>\n"
        },
        "ContinuationIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  Indent width for line continuations.</p>\n"
        },
        "Cpp11BracedListStyle": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, format braced lists as best suited for C++11 braced\n  lists.</p>\n<p>  Important differences:</p>\n<ul>\n<li>No spaces inside the braced list.</li>\n<li>No line break before the closing brace.</li>\n<li><p>Indentation with the continuation indent, not with the block indent.</p>\n<p>Fundamentally, C++11 braced lists are formatted exactly like function\ncalls would be formatted in their place. If the braced list follows a name\n(e.g. a type or variable name), clang-format formats as if the <code>{}</code> were\nthe parentheses of a function call with that name. If there is no name,\na zero-length name is assumed.</p>\n</li>\n</ul>\n"
        },
        "DerivePointerAlignment": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, analyze the formatted file for the most common\n  alignment of &amp; and *. <code>PointerAlignment</code> is then used only as fallback.</p>\n"
        },
        "DisableFormat": {
            "type": "bool",
            "doc": "<p>  Disables formatting at all.</p>\n"
        },
        "ExperimentalAutoDetectBinPacking": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format detects whether function calls and\n  definitions are formatted with one parameter per line.</p>\n<p>  Each call can be bin-packed, one-per-line or inconclusive. If it is\n  inconclusive, e.g. completely on one line, but a decision needs to be\n  made, clang-format analyzes whether there are other bin-packed cases in\n  the input file and act accordingly.</p>\n<p>  NOTE: This is an experimental flag, that might go away or be renamed. Do\n  not use this in config files, etc. Use at your own risk.</p>\n"
        },
        "ForEachMacros": {
            "type": "std::vector<std::string>",
            "doc": "<p>  A vector of macros that should be interpreted as foreach loops\n  instead of as function calls.</p>\n<p>  These are expected to be macros of the form:</p>\n<pre><code class=\"lang-  \">  FOREACH(&lt;variable-declaration&gt;, ...)\n  &lt;loop-body&gt;\n</code></pre>\n<p>  For example: BOOST_FOREACH.</p>\n"
        },
        "IndentCaseLabels": {
            "type": "bool",
            "doc": "<p>  Indent case labels one level from the switch statement.</p>\n<p>  When <code>false</code>, use the same indentation level as for the switch statement.\n  Switch statement body is always indented one level more than case labels.</p>\n"
        },
        "IndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns to use for indentation.</p>\n"
        },
        "IndentWrappedFunctionNames": {
            "type": "bool",
            "doc": "<p>  Indent if a function definition or declaration is wrapped after the\n  type.</p>\n"
        },
        "KeepEmptyLinesAtTheStartOfBlocks": {
            "type": "bool",
            "doc": "<p>  If true, empty lines at the start of blocks are kept.</p>\n"
        },
        "Language": {
            "type": "LanguageKind",
            "doc": "<p>  Language, this format style is targeted at.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LK_None</code> (in configuration: <code>None</code>)\nDo not use.</li>\n<li><code>LK_Cpp</code> (in configuration: <code>Cpp</code>)\nShould be used for C, C++, ObjectiveC, ObjectiveC++.</li>\n<li><code>LK_Java</code> (in configuration: <code>Java</code>)\nShould be used for Java.</li>\n<li><code>LK_JavaScript</code> (in configuration: <code>JavaScript</code>)\nShould be used for JavaScript.</li>\n<li><code>LK_Proto</code> (in configuration: <code>Proto</code>)\nShould be used for Protocol Buffers\n(https://developers.google.com/protocol-buffers/).</li>\n</ul>\n",
            "options": [
                "None",
                "Cpp",
                "Java",
                "JavaScript",
                "Proto"
            ]
        },
        "MaxEmptyLinesToKeep": {
            "type": "unsigned",
            "doc": "<p>  The maximum number of consecutive empty lines to keep.</p>\n"
        },
        "NamespaceIndentation": {
            "type": "NamespaceIndentationKind",
            "doc": "<p>  The indentation used for namespaces.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>NI_None</code> (in configuration: <code>None</code>)\nDon&#39;t indent in namespaces.</li>\n<li><code>NI_Inner</code> (in configuration: <code>Inner</code>)\nIndent only in inner namespaces (nested in other namespaces).</li>\n<li><code>NI_All</code> (in configuration: <code>All</code>)\nIndent in all namespaces.</li>\n</ul>\n",
            "options": [
                "None",
                "Inner",
                "All"
            ]
        },
        "ObjCBlockIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of ObjC blocks.</p>\n"
        },
        "ObjCSpaceAfterProperty": {
            "type": "bool",
            "doc": "<p>  Add a space after <code>@property</code> in Objective-C, i.e. use\n  <code>\\@property (readonly)</code> instead of <code>\\@property(readonly)</code>.</p>\n"
        },
        "ObjCSpaceBeforeProtocolList": {
            "type": "bool",
            "doc": "<p>  Add a space in front of an Objective-C protocol list, i.e. use\n  <code>Foo &lt;Protocol&gt;</code> instead of <code>Foo&lt;Protocol&gt;</code>.</p>\n"
        },
        "PenaltyBreakBeforeFirstCallParameter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking a function call after &quot;call(&quot;.</p>\n"
        },
        "PenaltyBreakComment": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a comment.</p>\n"
        },
        "PenaltyBreakFirstLessLess": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking before the first <code>&lt;&lt;</code>.</p>\n"
        },
        "PenaltyBreakString": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a string literal.</p>\n"
        },
        "PenaltyExcessCharacter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each character outside of the column limit.</p>\n"
        },
        "PenaltyReturnTypeOnItsOwnLine": {
            "type": "unsigned",
            "doc": "<p>  Penalty for putting the return type of a function onto its own\n  line.</p>\n"
        },
        "PointerAlignment": {
            "type": "PointerAlignmentStyle",
            "doc": "<p>  Pointer and reference alignment style.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>PAS_Left</code> (in configuration: <code>Left</code>)\nAlign pointer to the left.</li>\n<li><code>PAS_Right</code> (in configuration: <code>Right</code>)\nAlign pointer to the right.</li>\n<li><code>PAS_Middle</code> (in configuration: <code>Middle</code>)\nAlign pointer in the middle.</li>\n</ul>\n",
            "options": [
                "Left",
                "Right",
                "Middle"
            ]
        },
        "SpaceAfterCStyleCast": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, a space may be inserted after C style casts.</p>\n"
        },
        "SpaceBeforeAssignmentOperators": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, spaces will be removed before assignment operators.</p>\n"
        },
        "SpaceBeforeParens": {
            "type": "SpaceBeforeParensOptions",
            "doc": "<p>  Defines in which cases to put a space before opening parentheses.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>SBPO_Never</code> (in configuration: <code>Never</code>)\nNever put a space before opening parentheses.</li>\n<li><code>SBPO_ControlStatements</code> (in configuration: <code>ControlStatements</code>)\nPut a space before opening parentheses only after control statement\nkeywords (<code>for/if/while...</code>).</li>\n<li><code>SBPO_Always</code> (in configuration: <code>Always</code>)\nAlways put a space before opening parentheses, except when it&#39;s\nprohibited by the syntax rules (in function-like macro definitions) or\nwhen determined by other style rules (after unary operators, opening\nparentheses, etc.)</li>\n</ul>\n",
            "options": [
                "Never",
                "ControlStatements",
                "Always"
            ]
        },
        "SpaceInEmptyParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into &#39;()&#39;.</p>\n"
        },
        "SpacesBeforeTrailingComments": {
            "type": "unsigned",
            "doc": "<p>  The number of spaces before trailing line comments\n  (<code>//</code> - comments).</p>\n<p>  This does not affect trailing block comments (<code>/**/</code> - comments) as those\n  commonly have different usage patterns and a number of special cases.</p>\n"
        },
        "SpacesInAngles": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after &#39;&lt;&#39; and before &#39;&gt;&#39; in\n  template argument lists</p>\n"
        },
        "SpacesInCStyleCastParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into C style casts.</p>\n"
        },
        "SpacesInContainerLiterals": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces are inserted inside container literals (e.g.\n  ObjC and Javascript array and dict literals).</p>\n"
        },
        "SpacesInParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after &#39;(&#39; and before &#39;)&#39;.</p>\n"
        },
        "SpacesInSquareBrackets": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after &#39;[&#39; and before &#39;]&#39;.</p>\n"
        },
        "Standard": {
            "type": "LanguageStandard",
            "doc": "<p>  Format compatible with this standard, e.g. use\n  <code>A&lt;A&lt;int&gt; &gt;</code> instead of <code>A&lt;A&lt;int&gt;&gt;</code> for LS_Cpp03.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LS_Cpp03</code> (in configuration: <code>Cpp03</code>)\nUse C++03-compatible syntax.</li>\n<li><code>LS_Cpp11</code> (in configuration: <code>Cpp11</code>)\nUse features of C++11 (e.g. <code>A&lt;A&lt;int&gt;&gt;</code> instead of\n<code>A&lt;A&lt;int&gt; &gt;</code>).</li>\n<li><code>LS_Auto</code> (in configuration: <code>Auto</code>)\nAutomatic detection based on the input.</li>\n</ul>\n",
            "options": [
                "Cpp03",
                "Cpp11",
                "Auto"
            ]
        },
        "TabWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns used for tab stops.</p>\n"
        },
        "UseTab": {
            "type": "UseTabStyle",
            "doc": "<p>  The way to use tab characters in the resulting file.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>UT_Never</code> (in configuration: <code>Never</code>)\nNever use tab.</li>\n<li><code>UT_ForIndentation</code> (in configuration: <code>ForIndentation</code>)\nUse tabs only for indentation.</li>\n<li><code>UT_Always</code> (in configuration: <code>Always</code>)\nUse tabs whenever we need to fill whitespace that spans at least from\none tab stop to the next one.</li>\n</ul>\n",
            "options": [
                "Never",
                "ForIndentation",
                "Always"
            ]
        }
    },
    "3.6.2": {
        "BasedOnStyle": {
            "type": "string",
            "doc": "<p>  The style used for all options not specifically set in the configuration.</p>\n<p>  This option is supported only in the <strong>clang-format</strong> configuration\n  (both within <code>-style=&#39;{...}&#39;</code> and the <code>.clang-format</code> file).</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LLVM</code>\nA style complying with the <a href=\"http://llvm.org/docs/CodingStandards.html\">LLVM coding standards</a></li>\n<li><code>Google</code>\nA style complying with <a href=\"http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml\">Google&#39;s C++ style guide</a></li>\n<li><code>Chromium</code>\nA style complying with <a href=\"http://www.chromium.org/developers/coding-style\">Chromium&#39;s style guide</a></li>\n<li><code>Mozilla</code>\nA style complying with <a href=\"https://developer.mozilla.org/en-US/docs/Developer_Guide/Coding_Style\">Mozilla&#39;s style guide</a></li>\n<li><code>WebKit</code>\nA style complying with <a href=\"http://www.webkit.org/coding/coding-style.html\">WebKit&#39;s style guide</a></li>\n</ul>\n",
            "options": [
                "LLVM",
                "Google",
                "Chromium",
                "Mozilla",
                "WebKit"
            ]
        },
        "AccessModifierOffset": {
            "type": "int",
            "doc": "<p>  The extra indent or outdent of access modifiers, e.g. <code>public:</code>.</p>\n"
        },
        "AlignAfterOpenBracket": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, horizontally aligns arguments after an open bracket.</p>\n<p>  This applies to round brackets (parentheses), angle brackets and square\n  brackets. This will result in formattings like</p>\n<pre><code class=\"lang-  \">  someLongFunction(argument1,\n  argument2);\n</code></pre>\n"
        },
        "AlignEscapedNewlinesLeft": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns escaped newlines as far left as possible.\n  Otherwise puts them into the right-most column.</p>\n"
        },
        "AlignOperands": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, horizontally align operands of binary and ternary\n  expressions.</p>\n"
        },
        "AlignTrailingComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns trailing comments.</p>\n"
        },
        "AllowAllParametersOfDeclarationOnNextLine": {
            "type": "bool",
            "doc": "<p>  Allow putting all parameters of a function declaration onto\n  the next line even if <code>BinPackParameters</code> is <code>false</code>.</p>\n"
        },
        "AllowShortBlocksOnASingleLine": {
            "type": "bool",
            "doc": "<p>  Allows contracting simple braced statements to a single line.</p>\n<p>  E.g., this allows <code>if (a) { return; }</code> to be put on a single line.</p>\n"
        },
        "AllowShortCaseLabelsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, short case labels will be contracted to a single line.</p>\n"
        },
        "AllowShortFunctionsOnASingleLine": {
            "type": "ShortFunctionStyle",
            "doc": "<p>  Dependent on the value, <code>int f() { return 0; }</code> can be put\n  on a single line.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>SFS_None</code> (in configuration: <code>None</code>)\nNever merge functions into a single line.</li>\n<li><code>SFS_Inline</code> (in configuration: <code>Inline</code>)\nOnly merge functions defined inside a class.</li>\n<li><code>SFS_Empty</code> (in configuration: <code>Empty</code>)\nOnly merge empty functions.</li>\n<li><code>SFS_All</code> (in configuration: <code>All</code>)\nMerge all functions fitting on a single line.</li>\n</ul>\n",
            "options": [
                "None",
                "Inline",
                "Empty",
                "All"
            ]
        },
        "AllowShortIfStatementsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>if (a) return;</code> can be put on a single\n  line.</p>\n"
        },
        "AllowShortLoopsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>while (true) continue;</code> can be put on a\n  single line.</p>\n"
        },
        "AlwaysBreakAfterDefinitionReturnType": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break after function definition return types.</p>\n<p>  More truthfully called &#39;break before the identifier following the type\n  in a function definition&#39;. PenaltyReturnTypeOnItsOwnLine becomes\n  irrelevant.</p>\n"
        },
        "AlwaysBreakBeforeMultilineStrings": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break before multiline string literals.</p>\n"
        },
        "AlwaysBreakTemplateDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break after the <code>template&lt;...&gt;</code> of a\n  template declaration.</p>\n"
        },
        "BinPackArguments": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function call&#39;s arguments will either be all on the\n  same line or will have one line each.</p>\n"
        },
        "BinPackParameters": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function declaration&#39;s or function definition&#39;s\n  parameters will either all be on the same line or will have one line each.</p>\n"
        },
        "BreakBeforeBinaryOperators": {
            "type": "BinaryOperatorStyle",
            "doc": "<p>  The way to wrap binary operators.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>BOS_None</code> (in configuration: <code>None</code>)\nBreak after operators.</li>\n<li><code>BOS_NonAssignment</code> (in configuration: <code>NonAssignment</code>)\nBreak before operators that aren&#39;t assignments.</li>\n<li><code>BOS_All</code> (in configuration: <code>All</code>)\nBreak before operators.</li>\n</ul>\n",
            "options": [
                "None",
                "NonAssignment",
                "All"
            ]
        },
        "BreakBeforeBraces": {
            "type": "BraceBreakingStyle",
            "doc": "<p>  The brace breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>BS_Attach</code> (in configuration: <code>Attach</code>)\nAlways attach braces to surrounding context.</li>\n<li><code>BS_Linux</code> (in configuration: <code>Linux</code>)\nLike <code>Attach</code>, but break before braces on function, namespace and\nclass definitions.</li>\n<li><code>BS_Stroustrup</code> (in configuration: <code>Stroustrup</code>)\nLike <code>Attach</code>, but break before function definitions, and &#39;else&#39;.</li>\n<li><code>BS_Allman</code> (in configuration: <code>Allman</code>)\nAlways break before braces.</li>\n<li><code>BS_GNU</code> (in configuration: <code>GNU</code>)\nAlways break before braces and add an extra level of indentation to\nbraces of control statements, not to those of class, function\nor other definitions.</li>\n</ul>\n",
            "options": [
                "Attach",
                "Linux",
                "Stroustrup",
                "Allman",
                "GNU"
            ]
        },
        "BreakBeforeTernaryOperators": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, ternary operators will be placed after line breaks.</p>\n"
        },
        "BreakConstructorInitializersBeforeComma": {
            "type": "bool",
            "doc": "<p>  Always break constructor initializers before commas and align\n  the commas with the colon.</p>\n"
        },
        "ColumnLimit": {
            "type": "unsigned",
            "doc": "<p>  The column limit.</p>\n<p>  A column limit of <code>0</code> means that there is no column limit. In this case,\n  clang-format will respect the input&#39;s line breaking decisions within\n  statements unless they contradict other rules.</p>\n"
        },
        "CommentPragmas": {
            "type": "std::string",
            "doc": "<p>  A regular expression that describes comments with special meaning,\n  which should not be split into lines or otherwise changed.</p>\n"
        },
        "ConstructorInitializerAllOnOneLineOrOnePerLine": {
            "type": "bool",
            "doc": "<p>  If the constructor initializers don&#39;t fit on a line, put each\n  initializer on its own line.</p>\n"
        },
        "ConstructorInitializerIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of constructor\n  initializer lists.</p>\n"
        },
        "ContinuationIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  Indent width for line continuations.</p>\n"
        },
        "Cpp11BracedListStyle": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, format braced lists as best suited for C++11 braced\n  lists.</p>\n<p>  Important differences:</p>\n<ul>\n<li>No spaces inside the braced list.</li>\n<li>No line break before the closing brace.</li>\n<li><p>Indentation with the continuation indent, not with the block indent.</p>\n<p>Fundamentally, C++11 braced lists are formatted exactly like function\ncalls would be formatted in their place. If the braced list follows a name\n(e.g. a type or variable name), clang-format formats as if the <code>{}</code> were\nthe parentheses of a function call with that name. If there is no name,\na zero-length name is assumed.</p>\n</li>\n</ul>\n"
        },
        "DerivePointerAlignment": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, analyze the formatted file for the most common\n  alignment of &amp; and *. <code>PointerAlignment</code> is then used only as fallback.</p>\n"
        },
        "DisableFormat": {
            "type": "bool",
            "doc": "<p>  Disables formatting at all.</p>\n"
        },
        "ExperimentalAutoDetectBinPacking": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format detects whether function calls and\n  definitions are formatted with one parameter per line.</p>\n<p>  Each call can be bin-packed, one-per-line or inconclusive. If it is\n  inconclusive, e.g. completely on one line, but a decision needs to be\n  made, clang-format analyzes whether there are other bin-packed cases in\n  the input file and act accordingly.</p>\n<p>  NOTE: This is an experimental flag, that might go away or be renamed. Do\n  not use this in config files, etc. Use at your own risk.</p>\n"
        },
        "ForEachMacros": {
            "type": "std::vector<std::string>",
            "doc": "<p>  A vector of macros that should be interpreted as foreach loops\n  instead of as function calls.</p>\n<p>  These are expected to be macros of the form:</p>\n<pre><code class=\"lang-  \">  FOREACH(&lt;variable-declaration&gt;, ...)\n  &lt;loop-body&gt;\n</code></pre>\n<p>  For example: BOOST_FOREACH.</p>\n"
        },
        "IndentCaseLabels": {
            "type": "bool",
            "doc": "<p>  Indent case labels one level from the switch statement.</p>\n<p>  When <code>false</code>, use the same indentation level as for the switch statement.\n  Switch statement body is always indented one level more than case labels.</p>\n"
        },
        "IndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns to use for indentation.</p>\n"
        },
        "IndentWrappedFunctionNames": {
            "type": "bool",
            "doc": "<p>  Indent if a function definition or declaration is wrapped after the\n  type.</p>\n"
        },
        "KeepEmptyLinesAtTheStartOfBlocks": {
            "type": "bool",
            "doc": "<p>  If true, empty lines at the start of blocks are kept.</p>\n"
        },
        "Language": {
            "type": "LanguageKind",
            "doc": "<p>  Language, this format style is targeted at.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LK_None</code> (in configuration: <code>None</code>)\nDo not use.</li>\n<li><code>LK_Cpp</code> (in configuration: <code>Cpp</code>)\nShould be used for C, C++, ObjectiveC, ObjectiveC++.</li>\n<li><code>LK_Java</code> (in configuration: <code>Java</code>)\nShould be used for Java.</li>\n<li><code>LK_JavaScript</code> (in configuration: <code>JavaScript</code>)\nShould be used for JavaScript.</li>\n<li><code>LK_Proto</code> (in configuration: <code>Proto</code>)\nShould be used for Protocol Buffers\n(https://developers.google.com/protocol-buffers/).</li>\n</ul>\n",
            "options": [
                "None",
                "Cpp",
                "Java",
                "JavaScript",
                "Proto"
            ]
        },
        "MaxEmptyLinesToKeep": {
            "type": "unsigned",
            "doc": "<p>  The maximum number of consecutive empty lines to keep.</p>\n"
        },
        "NamespaceIndentation": {
            "type": "NamespaceIndentationKind",
            "doc": "<p>  The indentation used for namespaces.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>NI_None</code> (in configuration: <code>None</code>)\nDon&#39;t indent in namespaces.</li>\n<li><code>NI_Inner</code> (in configuration: <code>Inner</code>)\nIndent only in inner namespaces (nested in other namespaces).</li>\n<li><code>NI_All</code> (in configuration: <code>All</code>)\nIndent in all namespaces.</li>\n</ul>\n",
            "options": [
                "None",
                "Inner",
                "All"
            ]
        },
        "ObjCBlockIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of ObjC blocks.</p>\n"
        },
        "ObjCSpaceAfterProperty": {
            "type": "bool",
            "doc": "<p>  Add a space after <code>@property</code> in Objective-C, i.e. use\n  <code>\\@property (readonly)</code> instead of <code>\\@property(readonly)</code>.</p>\n"
        },
        "ObjCSpaceBeforeProtocolList": {
            "type": "bool",
            "doc": "<p>  Add a space in front of an Objective-C protocol list, i.e. use\n  <code>Foo &lt;Protocol&gt;</code> instead of <code>Foo&lt;Protocol&gt;</code>.</p>\n"
        },
        "PenaltyBreakBeforeFirstCallParameter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking a function call after &quot;call(&quot;.</p>\n"
        },
        "PenaltyBreakComment": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a comment.</p>\n"
        },
        "PenaltyBreakFirstLessLess": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking before the first <code>&lt;&lt;</code>.</p>\n"
        },
        "PenaltyBreakString": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a string literal.</p>\n"
        },
        "PenaltyExcessCharacter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each character outside of the column limit.</p>\n"
        },
        "PenaltyReturnTypeOnItsOwnLine": {
            "type": "unsigned",
            "doc": "<p>  Penalty for putting the return type of a function onto its own\n  line.</p>\n"
        },
        "PointerAlignment": {
            "type": "PointerAlignmentStyle",
            "doc": "<p>  Pointer and reference alignment style.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>PAS_Left</code> (in configuration: <code>Left</code>)\nAlign pointer to the left.</li>\n<li><code>PAS_Right</code> (in configuration: <code>Right</code>)\nAlign pointer to the right.</li>\n<li><code>PAS_Middle</code> (in configuration: <code>Middle</code>)\nAlign pointer in the middle.</li>\n</ul>\n",
            "options": [
                "Left",
                "Right",
                "Middle"
            ]
        },
        "SpaceAfterCStyleCast": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, a space may be inserted after C style casts.</p>\n"
        },
        "SpaceBeforeAssignmentOperators": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, spaces will be removed before assignment operators.</p>\n"
        },
        "SpaceBeforeParens": {
            "type": "SpaceBeforeParensOptions",
            "doc": "<p>  Defines in which cases to put a space before opening parentheses.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>SBPO_Never</code> (in configuration: <code>Never</code>)\nNever put a space before opening parentheses.</li>\n<li><code>SBPO_ControlStatements</code> (in configuration: <code>ControlStatements</code>)\nPut a space before opening parentheses only after control statement\nkeywords (<code>for/if/while...</code>).</li>\n<li><code>SBPO_Always</code> (in configuration: <code>Always</code>)\nAlways put a space before opening parentheses, except when it&#39;s\nprohibited by the syntax rules (in function-like macro definitions) or\nwhen determined by other style rules (after unary operators, opening\nparentheses, etc.)</li>\n</ul>\n",
            "options": [
                "Never",
                "ControlStatements",
                "Always"
            ]
        },
        "SpaceInEmptyParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into &#39;()&#39;.</p>\n"
        },
        "SpacesBeforeTrailingComments": {
            "type": "unsigned",
            "doc": "<p>  The number of spaces before trailing line comments\n  (<code>//</code> - comments).</p>\n<p>  This does not affect trailing block comments (<code>/**/</code> - comments) as those\n  commonly have different usage patterns and a number of special cases.</p>\n"
        },
        "SpacesInAngles": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after &#39;&lt;&#39; and before &#39;&gt;&#39; in\n  template argument lists</p>\n"
        },
        "SpacesInCStyleCastParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into C style casts.</p>\n"
        },
        "SpacesInContainerLiterals": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces are inserted inside container literals (e.g.\n  ObjC and Javascript array and dict literals).</p>\n"
        },
        "SpacesInParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after &#39;(&#39; and before &#39;)&#39;.</p>\n"
        },
        "SpacesInSquareBrackets": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after &#39;[&#39; and before &#39;]&#39;.</p>\n"
        },
        "Standard": {
            "type": "LanguageStandard",
            "doc": "<p>  Format compatible with this standard, e.g. use\n  <code>A&lt;A&lt;int&gt; &gt;</code> instead of <code>A&lt;A&lt;int&gt;&gt;</code> for LS_Cpp03.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LS_Cpp03</code> (in configuration: <code>Cpp03</code>)\nUse C++03-compatible syntax.</li>\n<li><code>LS_Cpp11</code> (in configuration: <code>Cpp11</code>)\nUse features of C++11 (e.g. <code>A&lt;A&lt;int&gt;&gt;</code> instead of\n<code>A&lt;A&lt;int&gt; &gt;</code>).</li>\n<li><code>LS_Auto</code> (in configuration: <code>Auto</code>)\nAutomatic detection based on the input.</li>\n</ul>\n",
            "options": [
                "Cpp03",
                "Cpp11",
                "Auto"
            ]
        },
        "TabWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns used for tab stops.</p>\n"
        },
        "UseTab": {
            "type": "UseTabStyle",
            "doc": "<p>  The way to use tab characters in the resulting file.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>UT_Never</code> (in configuration: <code>Never</code>)\nNever use tab.</li>\n<li><code>UT_ForIndentation</code> (in configuration: <code>ForIndentation</code>)\nUse tabs only for indentation.</li>\n<li><code>UT_Always</code> (in configuration: <code>Always</code>)\nUse tabs whenever we need to fill whitespace that spans at least from\none tab stop to the next one.</li>\n</ul>\n",
            "options": [
                "Never",
                "ForIndentation",
                "Always"
            ]
        }
    },
    "3.7.0": {
        "BasedOnStyle": {
            "type": "string",
            "doc": "<p>  The style used for all options not specifically set in the configuration.</p>\n<p>  This option is supported only in the <strong>clang-format</strong> configuration\n  (both within <code>-style=&#39;{...}&#39;</code> and the <code>.clang-format</code> file).</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LLVM</code>\nA style complying with the <a href=\"http://llvm.org/docs/CodingStandards.html\">LLVM coding standards</a></li>\n<li><code>Google</code>\nA style complying with <a href=\"http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml\">Google&#39;s C++ style guide</a></li>\n<li><code>Chromium</code>\nA style complying with <a href=\"http://www.chromium.org/developers/coding-style\">Chromium&#39;s style guide</a></li>\n<li><code>Mozilla</code>\nA style complying with <a href=\"https://developer.mozilla.org/en-US/docs/Developer_Guide/Coding_Style\">Mozilla&#39;s style guide</a></li>\n<li><code>WebKit</code>\nA style complying with <a href=\"http://www.webkit.org/coding/coding-style.html\">WebKit&#39;s style guide</a></li>\n</ul>\n",
            "options": [
                "LLVM",
                "Google",
                "Chromium",
                "Mozilla",
                "WebKit"
            ]
        },
        "AccessModifierOffset": {
            "type": "int",
            "doc": "<p>  The extra indent or outdent of access modifiers, e.g. <code>public:</code>.</p>\n"
        },
        "AlignAfterOpenBracket": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, horizontally aligns arguments after an open bracket.</p>\n<p>  This applies to round brackets (parentheses), angle brackets and square\n  brackets. This will result in formattings like</p>\n<pre><code class=\"lang-  \">  someLongFunction(argument1,\n  argument2);\n</code></pre>\n"
        },
        "AlignConsecutiveAssignments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns consecutive assignments.</p>\n<p>  This will align the assignment operators of consecutive lines. This\n  will result in formattings like</p>\n<pre><code class=\"lang-  \">  int aaaa = 12;\n  int b    = 23;\n  int ccc  = 23;\n</code></pre>\n"
        },
        "AlignEscapedNewlinesLeft": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns escaped newlines as far left as possible.\n  Otherwise puts them into the right-most column.</p>\n"
        },
        "AlignOperands": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, horizontally align operands of binary and ternary\n  expressions.</p>\n"
        },
        "AlignTrailingComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns trailing comments.</p>\n"
        },
        "AllowAllParametersOfDeclarationOnNextLine": {
            "type": "bool",
            "doc": "<p>  Allow putting all parameters of a function declaration onto\n  the next line even if <code>BinPackParameters</code> is <code>false</code>.</p>\n"
        },
        "AllowShortBlocksOnASingleLine": {
            "type": "bool",
            "doc": "<p>  Allows contracting simple braced statements to a single line.</p>\n<p>  E.g., this allows <code>if (a) { return; }</code> to be put on a single line.</p>\n"
        },
        "AllowShortCaseLabelsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, short case labels will be contracted to a single line.</p>\n"
        },
        "AllowShortFunctionsOnASingleLine": {
            "type": "ShortFunctionStyle",
            "doc": "<p>  Dependent on the value, <code>int f() { return 0; }</code> can be put\n  on a single line.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>SFS_None</code> (in configuration: <code>None</code>)\nNever merge functions into a single line.</li>\n<li><code>SFS_Empty</code> (in configuration: <code>Empty</code>)\nOnly merge empty functions.</li>\n<li><code>SFS_Inline</code> (in configuration: <code>Inline</code>)\nOnly merge functions defined inside a class. Implies &quot;empty&quot;.</li>\n<li><code>SFS_All</code> (in configuration: <code>All</code>)\nMerge all functions fitting on a single line.</li>\n</ul>\n",
            "options": [
                "None",
                "Empty",
                "Inline",
                "All"
            ]
        },
        "AllowShortIfStatementsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>if (a) return;</code> can be put on a single\n  line.</p>\n"
        },
        "AllowShortLoopsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>while (true) continue;</code> can be put on a\n  single line.</p>\n"
        },
        "AlwaysBreakAfterDefinitionReturnType": {
            "type": "DefinitionReturnTypeBreakingStyle",
            "doc": "<p>  The function definition return type breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>DRTBS_None</code> (in configuration: <code>None</code>)\nBreak after return type automatically.\n<code>PenaltyReturnTypeOnItsOwnLine</code> is taken into account.</li>\n<li><code>DRTBS_All</code> (in configuration: <code>All</code>)\nAlways break after the return type.</li>\n<li><code>DRTBS_TopLevel</code> (in configuration: <code>TopLevel</code>)\nAlways break after the return types of top level functions.</li>\n</ul>\n",
            "options": [
                "None",
                "All",
                "TopLevel"
            ]
        },
        "AlwaysBreakBeforeMultilineStrings": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break before multiline string literals.</p>\n<p>  This flag is mean to make cases where there are multiple multiline strings\n  in a file look more consistent. Thus, it will only take effect if wrapping\n  the string at that point leads to it being indented\n  <code>ContinuationIndentWidth</code> spaces from the start of the line.</p>\n"
        },
        "AlwaysBreakTemplateDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break after the <code>template&lt;...&gt;</code> of a\n  template declaration.</p>\n"
        },
        "BinPackArguments": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function call&#39;s arguments will either be all on the\n  same line or will have one line each.</p>\n"
        },
        "BinPackParameters": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function declaration&#39;s or function definition&#39;s\n  parameters will either all be on the same line or will have one line each.</p>\n"
        },
        "BreakBeforeBinaryOperators": {
            "type": "BinaryOperatorStyle",
            "doc": "<p>  The way to wrap binary operators.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>BOS_None</code> (in configuration: <code>None</code>)\nBreak after operators.</li>\n<li><code>BOS_NonAssignment</code> (in configuration: <code>NonAssignment</code>)\nBreak before operators that aren&#39;t assignments.</li>\n<li><code>BOS_All</code> (in configuration: <code>All</code>)\nBreak before operators.</li>\n</ul>\n",
            "options": [
                "None",
                "NonAssignment",
                "All"
            ]
        },
        "BreakBeforeBraces": {
            "type": "BraceBreakingStyle",
            "doc": "<p>  The brace breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>BS_Attach</code> (in configuration: <code>Attach</code>)\nAlways attach braces to surrounding context.</li>\n<li><code>BS_Linux</code> (in configuration: <code>Linux</code>)\nLike <code>Attach</code>, but break before braces on function, namespace and\nclass definitions.</li>\n<li><code>BS_Mozilla</code> (in configuration: <code>Mozilla</code>)\nLike <code>Attach</code>, but break before braces on enum, function, and record\ndefinitions.</li>\n<li><code>BS_Stroustrup</code> (in configuration: <code>Stroustrup</code>)\nLike <code>Attach</code>, but break before function definitions, and &#39;else&#39;.</li>\n<li><code>BS_Allman</code> (in configuration: <code>Allman</code>)\nAlways break before braces.</li>\n<li><code>BS_GNU</code> (in configuration: <code>GNU</code>)\nAlways break before braces and add an extra level of indentation to\nbraces of control statements, not to those of class, function\nor other definitions.</li>\n</ul>\n",
            "options": [
                "Attach",
                "Linux",
                "Mozilla",
                "Stroustrup",
                "Allman",
                "GNU"
            ]
        },
        "BreakBeforeTernaryOperators": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, ternary operators will be placed after line breaks.</p>\n"
        },
        "BreakConstructorInitializersBeforeComma": {
            "type": "bool",
            "doc": "<p>  Always break constructor initializers before commas and align\n  the commas with the colon.</p>\n"
        },
        "ColumnLimit": {
            "type": "unsigned",
            "doc": "<p>  The column limit.</p>\n<p>  A column limit of <code>0</code> means that there is no column limit. In this case,\n  clang-format will respect the input&#39;s line breaking decisions within\n  statements unless they contradict other rules.</p>\n"
        },
        "CommentPragmas": {
            "type": "std::string",
            "doc": "<p>  A regular expression that describes comments with special meaning,\n  which should not be split into lines or otherwise changed.</p>\n"
        },
        "ConstructorInitializerAllOnOneLineOrOnePerLine": {
            "type": "bool",
            "doc": "<p>  If the constructor initializers don&#39;t fit on a line, put each\n  initializer on its own line.</p>\n"
        },
        "ConstructorInitializerIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of constructor\n  initializer lists.</p>\n"
        },
        "ContinuationIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  Indent width for line continuations.</p>\n"
        },
        "Cpp11BracedListStyle": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, format braced lists as best suited for C++11 braced\n  lists.</p>\n<p>  Important differences:</p>\n<ul>\n<li>No spaces inside the braced list.</li>\n<li>No line break before the closing brace.</li>\n<li><p>Indentation with the continuation indent, not with the block indent.</p>\n<p>Fundamentally, C++11 braced lists are formatted exactly like function\ncalls would be formatted in their place. If the braced list follows a name\n(e.g. a type or variable name), clang-format formats as if the <code>{}</code> were\nthe parentheses of a function call with that name. If there is no name,\na zero-length name is assumed.</p>\n</li>\n</ul>\n"
        },
        "DerivePointerAlignment": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, analyze the formatted file for the most common\n  alignment of &amp; and *. <code>PointerAlignment</code> is then used only as fallback.</p>\n"
        },
        "DisableFormat": {
            "type": "bool",
            "doc": "<p>  Disables formatting completely.</p>\n"
        },
        "ExperimentalAutoDetectBinPacking": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format detects whether function calls and\n  definitions are formatted with one parameter per line.</p>\n<p>  Each call can be bin-packed, one-per-line or inconclusive. If it is\n  inconclusive, e.g. completely on one line, but a decision needs to be\n  made, clang-format analyzes whether there are other bin-packed cases in\n  the input file and act accordingly.</p>\n<p>  NOTE: This is an experimental flag, that might go away or be renamed. Do\n  not use this in config files, etc. Use at your own risk.</p>\n"
        },
        "ForEachMacros": {
            "type": "std::vector<std::string>",
            "doc": "<p>  A vector of macros that should be interpreted as foreach loops\n  instead of as function calls.</p>\n<p>  These are expected to be macros of the form:</p>\n<pre><code class=\"lang-  \">  FOREACH(&lt;variable-declaration&gt;, ...)\n  &lt;loop-body&gt;\n</code></pre>\n<p>  For example: BOOST_FOREACH.</p>\n"
        },
        "IndentCaseLabels": {
            "type": "bool",
            "doc": "<p>  Indent case labels one level from the switch statement.</p>\n<p>  When <code>false</code>, use the same indentation level as for the switch statement.\n  Switch statement body is always indented one level more than case labels.</p>\n"
        },
        "IndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns to use for indentation.</p>\n"
        },
        "IndentWrappedFunctionNames": {
            "type": "bool",
            "doc": "<p>  Indent if a function definition or declaration is wrapped after the\n  type.</p>\n"
        },
        "KeepEmptyLinesAtTheStartOfBlocks": {
            "type": "bool",
            "doc": "<p>  If true, empty lines at the start of blocks are kept.</p>\n"
        },
        "Language": {
            "type": "LanguageKind",
            "doc": "<p>  Language, this format style is targeted at.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LK_None</code> (in configuration: <code>None</code>)\nDo not use.</li>\n<li><code>LK_Cpp</code> (in configuration: <code>Cpp</code>)\nShould be used for C, C++, ObjectiveC, ObjectiveC++.</li>\n<li><code>LK_Java</code> (in configuration: <code>Java</code>)\nShould be used for Java.</li>\n<li><code>LK_JavaScript</code> (in configuration: <code>JavaScript</code>)\nShould be used for JavaScript.</li>\n<li><code>LK_Proto</code> (in configuration: <code>Proto</code>)\nShould be used for Protocol Buffers\n(https://developers.google.com/protocol-buffers/).</li>\n</ul>\n",
            "options": [
                "None",
                "Cpp",
                "Java",
                "JavaScript",
                "Proto"
            ]
        },
        "MacroBlockBegin": {
            "type": "std::string",
            "doc": "<p>  A regular expression matching macros that start a block.</p>\n"
        },
        "MacroBlockEnd": {
            "type": "std::string",
            "doc": "<p>  A regular expression matching macros that end a block.</p>\n"
        },
        "MaxEmptyLinesToKeep": {
            "type": "unsigned",
            "doc": "<p>  The maximum number of consecutive empty lines to keep.</p>\n"
        },
        "NamespaceIndentation": {
            "type": "NamespaceIndentationKind",
            "doc": "<p>  The indentation used for namespaces.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>NI_None</code> (in configuration: <code>None</code>)\nDon&#39;t indent in namespaces.</li>\n<li><code>NI_Inner</code> (in configuration: <code>Inner</code>)\nIndent only in inner namespaces (nested in other namespaces).</li>\n<li><code>NI_All</code> (in configuration: <code>All</code>)\nIndent in all namespaces.</li>\n</ul>\n",
            "options": [
                "None",
                "Inner",
                "All"
            ]
        },
        "ObjCBlockIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of ObjC blocks.</p>\n"
        },
        "ObjCSpaceAfterProperty": {
            "type": "bool",
            "doc": "<p>  Add a space after <code>@property</code> in Objective-C, i.e. use\n  <code>\\@property (readonly)</code> instead of <code>\\@property(readonly)</code>.</p>\n"
        },
        "ObjCSpaceBeforeProtocolList": {
            "type": "bool",
            "doc": "<p>  Add a space in front of an Objective-C protocol list, i.e. use\n  <code>Foo &lt;Protocol&gt;</code> instead of <code>Foo&lt;Protocol&gt;</code>.</p>\n"
        },
        "PenaltyBreakBeforeFirstCallParameter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking a function call after &quot;call(&quot;.</p>\n"
        },
        "PenaltyBreakComment": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a comment.</p>\n"
        },
        "PenaltyBreakFirstLessLess": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking before the first <code>&lt;&lt;</code>.</p>\n"
        },
        "PenaltyBreakString": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a string literal.</p>\n"
        },
        "PenaltyExcessCharacter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each character outside of the column limit.</p>\n"
        },
        "PenaltyReturnTypeOnItsOwnLine": {
            "type": "unsigned",
            "doc": "<p>  Penalty for putting the return type of a function onto its own\n  line.</p>\n"
        },
        "PointerAlignment": {
            "type": "PointerAlignmentStyle",
            "doc": "<p>  Pointer and reference alignment style.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>PAS_Left</code> (in configuration: <code>Left</code>)\nAlign pointer to the left.</li>\n<li><code>PAS_Right</code> (in configuration: <code>Right</code>)\nAlign pointer to the right.</li>\n<li><code>PAS_Middle</code> (in configuration: <code>Middle</code>)\nAlign pointer in the middle.</li>\n</ul>\n",
            "options": [
                "Left",
                "Right",
                "Middle"
            ]
        },
        "SpaceAfterCStyleCast": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, a space may be inserted after C style casts.</p>\n"
        },
        "SpaceBeforeAssignmentOperators": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, spaces will be removed before assignment operators.</p>\n"
        },
        "SpaceBeforeParens": {
            "type": "SpaceBeforeParensOptions",
            "doc": "<p>  Defines in which cases to put a space before opening parentheses.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>SBPO_Never</code> (in configuration: <code>Never</code>)\nNever put a space before opening parentheses.</li>\n<li><code>SBPO_ControlStatements</code> (in configuration: <code>ControlStatements</code>)\nPut a space before opening parentheses only after control statement\nkeywords (<code>for/if/while...</code>).</li>\n<li><code>SBPO_Always</code> (in configuration: <code>Always</code>)\nAlways put a space before opening parentheses, except when it&#39;s\nprohibited by the syntax rules (in function-like macro definitions) or\nwhen determined by other style rules (after unary operators, opening\nparentheses, etc.)</li>\n</ul>\n",
            "options": [
                "Never",
                "ControlStatements",
                "Always"
            ]
        },
        "SpaceInEmptyParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into &#39;()&#39;.</p>\n"
        },
        "SpacesBeforeTrailingComments": {
            "type": "unsigned",
            "doc": "<p>  The number of spaces before trailing line comments\n  (<code>//</code> - comments).</p>\n<p>  This does not affect trailing block comments (<code>/**/</code> - comments) as those\n  commonly have different usage patterns and a number of special cases.</p>\n"
        },
        "SpacesInAngles": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after &#39;&lt;&#39; and before &#39;&gt;&#39; in\n  template argument lists</p>\n"
        },
        "SpacesInCStyleCastParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into C style casts.</p>\n"
        },
        "SpacesInContainerLiterals": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces are inserted inside container literals (e.g.\n  ObjC and Javascript array and dict literals).</p>\n"
        },
        "SpacesInParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after &#39;(&#39; and before &#39;)&#39;.</p>\n"
        },
        "SpacesInSquareBrackets": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after &#39;[&#39; and before &#39;]&#39;.</p>\n"
        },
        "Standard": {
            "type": "LanguageStandard",
            "doc": "<p>  Format compatible with this standard, e.g. use\n  <code>A&lt;A&lt;int&gt; &gt;</code> instead of <code>A&lt;A&lt;int&gt;&gt;</code> for LS_Cpp03.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LS_Cpp03</code> (in configuration: <code>Cpp03</code>)\nUse C++03-compatible syntax.</li>\n<li><code>LS_Cpp11</code> (in configuration: <code>Cpp11</code>)\nUse features of C++11 (e.g. <code>A&lt;A&lt;int&gt;&gt;</code> instead of\n<code>A&lt;A&lt;int&gt; &gt;</code>).</li>\n<li><code>LS_Auto</code> (in configuration: <code>Auto</code>)\nAutomatic detection based on the input.</li>\n</ul>\n",
            "options": [
                "Cpp03",
                "Cpp11",
                "Auto"
            ]
        },
        "TabWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns used for tab stops.</p>\n"
        },
        "UseTab": {
            "type": "UseTabStyle",
            "doc": "<p>  The way to use tab characters in the resulting file.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>UT_Never</code> (in configuration: <code>Never</code>)\nNever use tab.</li>\n<li><code>UT_ForIndentation</code> (in configuration: <code>ForIndentation</code>)\nUse tabs only for indentation.</li>\n<li><code>UT_Always</code> (in configuration: <code>Always</code>)\nUse tabs whenever we need to fill whitespace that spans at least from\none tab stop to the next one.</li>\n</ul>\n",
            "options": [
                "Never",
                "ForIndentation",
                "Always"
            ]
        }
    },
    "3.7.1": {
        "BasedOnStyle": {
            "type": "string",
            "doc": "<p>  The style used for all options not specifically set in the configuration.</p>\n<p>  This option is supported only in the <strong>clang-format</strong> configuration\n  (both within <code>-style=&#39;{...}&#39;</code> and the <code>.clang-format</code> file).</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LLVM</code>\nA style complying with the <a href=\"http://llvm.org/docs/CodingStandards.html\">LLVM coding standards</a></li>\n<li><code>Google</code>\nA style complying with <a href=\"http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml\">Google&#39;s C++ style guide</a></li>\n<li><code>Chromium</code>\nA style complying with <a href=\"http://www.chromium.org/developers/coding-style\">Chromium&#39;s style guide</a></li>\n<li><code>Mozilla</code>\nA style complying with <a href=\"https://developer.mozilla.org/en-US/docs/Developer_Guide/Coding_Style\">Mozilla&#39;s style guide</a></li>\n<li><code>WebKit</code>\nA style complying with <a href=\"http://www.webkit.org/coding/coding-style.html\">WebKit&#39;s style guide</a></li>\n</ul>\n",
            "options": [
                "LLVM",
                "Google",
                "Chromium",
                "Mozilla",
                "WebKit"
            ]
        },
        "AccessModifierOffset": {
            "type": "int",
            "doc": "<p>  The extra indent or outdent of access modifiers, e.g. <code>public:</code>.</p>\n"
        },
        "AlignAfterOpenBracket": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, horizontally aligns arguments after an open bracket.</p>\n<p>  This applies to round brackets (parentheses), angle brackets and square\n  brackets. This will result in formattings like</p>\n<pre><code class=\"lang-  \">  someLongFunction(argument1,\n  argument2);\n</code></pre>\n"
        },
        "AlignConsecutiveAssignments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns consecutive assignments.</p>\n<p>  This will align the assignment operators of consecutive lines. This\n  will result in formattings like</p>\n<pre><code class=\"lang-  \">  int aaaa = 12;\n  int b    = 23;\n  int ccc  = 23;\n</code></pre>\n"
        },
        "AlignEscapedNewlinesLeft": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns escaped newlines as far left as possible.\n  Otherwise puts them into the right-most column.</p>\n"
        },
        "AlignOperands": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, horizontally align operands of binary and ternary\n  expressions.</p>\n"
        },
        "AlignTrailingComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns trailing comments.</p>\n"
        },
        "AllowAllParametersOfDeclarationOnNextLine": {
            "type": "bool",
            "doc": "<p>  Allow putting all parameters of a function declaration onto\n  the next line even if <code>BinPackParameters</code> is <code>false</code>.</p>\n"
        },
        "AllowShortBlocksOnASingleLine": {
            "type": "bool",
            "doc": "<p>  Allows contracting simple braced statements to a single line.</p>\n<p>  E.g., this allows <code>if (a) { return; }</code> to be put on a single line.</p>\n"
        },
        "AllowShortCaseLabelsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, short case labels will be contracted to a single line.</p>\n"
        },
        "AllowShortFunctionsOnASingleLine": {
            "type": "ShortFunctionStyle",
            "doc": "<p>  Dependent on the value, <code>int f() { return 0; }</code> can be put\n  on a single line.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>SFS_None</code> (in configuration: <code>None</code>)\nNever merge functions into a single line.</li>\n<li><code>SFS_Empty</code> (in configuration: <code>Empty</code>)\nOnly merge empty functions.</li>\n<li><code>SFS_Inline</code> (in configuration: <code>Inline</code>)\nOnly merge functions defined inside a class. Implies &quot;empty&quot;.</li>\n<li><code>SFS_All</code> (in configuration: <code>All</code>)\nMerge all functions fitting on a single line.</li>\n</ul>\n",
            "options": [
                "None",
                "Empty",
                "Inline",
                "All"
            ]
        },
        "AllowShortIfStatementsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>if (a) return;</code> can be put on a single\n  line.</p>\n"
        },
        "AllowShortLoopsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>while (true) continue;</code> can be put on a\n  single line.</p>\n"
        },
        "AlwaysBreakAfterDefinitionReturnType": {
            "type": "DefinitionReturnTypeBreakingStyle",
            "doc": "<p>  The function definition return type breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>DRTBS_None</code> (in configuration: <code>None</code>)\nBreak after return type automatically.\n<code>PenaltyReturnTypeOnItsOwnLine</code> is taken into account.</li>\n<li><code>DRTBS_All</code> (in configuration: <code>All</code>)\nAlways break after the return type.</li>\n<li><code>DRTBS_TopLevel</code> (in configuration: <code>TopLevel</code>)\nAlways break after the return types of top level functions.</li>\n</ul>\n",
            "options": [
                "None",
                "All",
                "TopLevel"
            ]
        },
        "AlwaysBreakBeforeMultilineStrings": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break before multiline string literals.</p>\n<p>  This flag is mean to make cases where there are multiple multiline strings\n  in a file look more consistent. Thus, it will only take effect if wrapping\n  the string at that point leads to it being indented\n  <code>ContinuationIndentWidth</code> spaces from the start of the line.</p>\n"
        },
        "AlwaysBreakTemplateDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break after the <code>template&lt;...&gt;</code> of a\n  template declaration.</p>\n"
        },
        "BinPackArguments": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function call&#39;s arguments will either be all on the\n  same line or will have one line each.</p>\n"
        },
        "BinPackParameters": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function declaration&#39;s or function definition&#39;s\n  parameters will either all be on the same line or will have one line each.</p>\n"
        },
        "BreakBeforeBinaryOperators": {
            "type": "BinaryOperatorStyle",
            "doc": "<p>  The way to wrap binary operators.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>BOS_None</code> (in configuration: <code>None</code>)\nBreak after operators.</li>\n<li><code>BOS_NonAssignment</code> (in configuration: <code>NonAssignment</code>)\nBreak before operators that aren&#39;t assignments.</li>\n<li><code>BOS_All</code> (in configuration: <code>All</code>)\nBreak before operators.</li>\n</ul>\n",
            "options": [
                "None",
                "NonAssignment",
                "All"
            ]
        },
        "BreakBeforeBraces": {
            "type": "BraceBreakingStyle",
            "doc": "<p>  The brace breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>BS_Attach</code> (in configuration: <code>Attach</code>)\nAlways attach braces to surrounding context.</li>\n<li><code>BS_Linux</code> (in configuration: <code>Linux</code>)\nLike <code>Attach</code>, but break before braces on function, namespace and\nclass definitions.</li>\n<li><code>BS_Mozilla</code> (in configuration: <code>Mozilla</code>)\nLike <code>Attach</code>, but break before braces on enum, function, and record\ndefinitions.</li>\n<li><code>BS_Stroustrup</code> (in configuration: <code>Stroustrup</code>)\nLike <code>Attach</code>, but break before function definitions, and &#39;else&#39;.</li>\n<li><code>BS_Allman</code> (in configuration: <code>Allman</code>)\nAlways break before braces.</li>\n<li><code>BS_GNU</code> (in configuration: <code>GNU</code>)\nAlways break before braces and add an extra level of indentation to\nbraces of control statements, not to those of class, function\nor other definitions.</li>\n</ul>\n",
            "options": [
                "Attach",
                "Linux",
                "Mozilla",
                "Stroustrup",
                "Allman",
                "GNU"
            ]
        },
        "BreakBeforeTernaryOperators": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, ternary operators will be placed after line breaks.</p>\n"
        },
        "BreakConstructorInitializersBeforeComma": {
            "type": "bool",
            "doc": "<p>  Always break constructor initializers before commas and align\n  the commas with the colon.</p>\n"
        },
        "ColumnLimit": {
            "type": "unsigned",
            "doc": "<p>  The column limit.</p>\n<p>  A column limit of <code>0</code> means that there is no column limit. In this case,\n  clang-format will respect the input&#39;s line breaking decisions within\n  statements unless they contradict other rules.</p>\n"
        },
        "CommentPragmas": {
            "type": "std::string",
            "doc": "<p>  A regular expression that describes comments with special meaning,\n  which should not be split into lines or otherwise changed.</p>\n"
        },
        "ConstructorInitializerAllOnOneLineOrOnePerLine": {
            "type": "bool",
            "doc": "<p>  If the constructor initializers don&#39;t fit on a line, put each\n  initializer on its own line.</p>\n"
        },
        "ConstructorInitializerIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of constructor\n  initializer lists.</p>\n"
        },
        "ContinuationIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  Indent width for line continuations.</p>\n"
        },
        "Cpp11BracedListStyle": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, format braced lists as best suited for C++11 braced\n  lists.</p>\n<p>  Important differences:</p>\n<ul>\n<li>No spaces inside the braced list.</li>\n<li>No line break before the closing brace.</li>\n<li><p>Indentation with the continuation indent, not with the block indent.</p>\n<p>Fundamentally, C++11 braced lists are formatted exactly like function\ncalls would be formatted in their place. If the braced list follows a name\n(e.g. a type or variable name), clang-format formats as if the <code>{}</code> were\nthe parentheses of a function call with that name. If there is no name,\na zero-length name is assumed.</p>\n</li>\n</ul>\n"
        },
        "DerivePointerAlignment": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, analyze the formatted file for the most common\n  alignment of &amp; and *. <code>PointerAlignment</code> is then used only as fallback.</p>\n"
        },
        "DisableFormat": {
            "type": "bool",
            "doc": "<p>  Disables formatting completely.</p>\n"
        },
        "ExperimentalAutoDetectBinPacking": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format detects whether function calls and\n  definitions are formatted with one parameter per line.</p>\n<p>  Each call can be bin-packed, one-per-line or inconclusive. If it is\n  inconclusive, e.g. completely on one line, but a decision needs to be\n  made, clang-format analyzes whether there are other bin-packed cases in\n  the input file and act accordingly.</p>\n<p>  NOTE: This is an experimental flag, that might go away or be renamed. Do\n  not use this in config files, etc. Use at your own risk.</p>\n"
        },
        "ForEachMacros": {
            "type": "std::vector<std::string>",
            "doc": "<p>  A vector of macros that should be interpreted as foreach loops\n  instead of as function calls.</p>\n<p>  These are expected to be macros of the form:</p>\n<pre><code class=\"lang-  \">  FOREACH(&lt;variable-declaration&gt;, ...)\n  &lt;loop-body&gt;\n</code></pre>\n<p>  For example: BOOST_FOREACH.</p>\n"
        },
        "IndentCaseLabels": {
            "type": "bool",
            "doc": "<p>  Indent case labels one level from the switch statement.</p>\n<p>  When <code>false</code>, use the same indentation level as for the switch statement.\n  Switch statement body is always indented one level more than case labels.</p>\n"
        },
        "IndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns to use for indentation.</p>\n"
        },
        "IndentWrappedFunctionNames": {
            "type": "bool",
            "doc": "<p>  Indent if a function definition or declaration is wrapped after the\n  type.</p>\n"
        },
        "KeepEmptyLinesAtTheStartOfBlocks": {
            "type": "bool",
            "doc": "<p>  If true, empty lines at the start of blocks are kept.</p>\n"
        },
        "Language": {
            "type": "LanguageKind",
            "doc": "<p>  Language, this format style is targeted at.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LK_None</code> (in configuration: <code>None</code>)\nDo not use.</li>\n<li><code>LK_Cpp</code> (in configuration: <code>Cpp</code>)\nShould be used for C, C++, ObjectiveC, ObjectiveC++.</li>\n<li><code>LK_Java</code> (in configuration: <code>Java</code>)\nShould be used for Java.</li>\n<li><code>LK_JavaScript</code> (in configuration: <code>JavaScript</code>)\nShould be used for JavaScript.</li>\n<li><code>LK_Proto</code> (in configuration: <code>Proto</code>)\nShould be used for Protocol Buffers\n(https://developers.google.com/protocol-buffers/).</li>\n</ul>\n",
            "options": [
                "None",
                "Cpp",
                "Java",
                "JavaScript",
                "Proto"
            ]
        },
        "MacroBlockBegin": {
            "type": "std::string",
            "doc": "<p>  A regular expression matching macros that start a block.</p>\n"
        },
        "MacroBlockEnd": {
            "type": "std::string",
            "doc": "<p>  A regular expression matching macros that end a block.</p>\n"
        },
        "MaxEmptyLinesToKeep": {
            "type": "unsigned",
            "doc": "<p>  The maximum number of consecutive empty lines to keep.</p>\n"
        },
        "NamespaceIndentation": {
            "type": "NamespaceIndentationKind",
            "doc": "<p>  The indentation used for namespaces.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>NI_None</code> (in configuration: <code>None</code>)\nDon&#39;t indent in namespaces.</li>\n<li><code>NI_Inner</code> (in configuration: <code>Inner</code>)\nIndent only in inner namespaces (nested in other namespaces).</li>\n<li><code>NI_All</code> (in configuration: <code>All</code>)\nIndent in all namespaces.</li>\n</ul>\n",
            "options": [
                "None",
                "Inner",
                "All"
            ]
        },
        "ObjCBlockIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of ObjC blocks.</p>\n"
        },
        "ObjCSpaceAfterProperty": {
            "type": "bool",
            "doc": "<p>  Add a space after <code>@property</code> in Objective-C, i.e. use\n  <code>\\@property (readonly)</code> instead of <code>\\@property(readonly)</code>.</p>\n"
        },
        "ObjCSpaceBeforeProtocolList": {
            "type": "bool",
            "doc": "<p>  Add a space in front of an Objective-C protocol list, i.e. use\n  <code>Foo &lt;Protocol&gt;</code> instead of <code>Foo&lt;Protocol&gt;</code>.</p>\n"
        },
        "PenaltyBreakBeforeFirstCallParameter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking a function call after &quot;call(&quot;.</p>\n"
        },
        "PenaltyBreakComment": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a comment.</p>\n"
        },
        "PenaltyBreakFirstLessLess": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking before the first <code>&lt;&lt;</code>.</p>\n"
        },
        "PenaltyBreakString": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a string literal.</p>\n"
        },
        "PenaltyExcessCharacter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each character outside of the column limit.</p>\n"
        },
        "PenaltyReturnTypeOnItsOwnLine": {
            "type": "unsigned",
            "doc": "<p>  Penalty for putting the return type of a function onto its own\n  line.</p>\n"
        },
        "PointerAlignment": {
            "type": "PointerAlignmentStyle",
            "doc": "<p>  Pointer and reference alignment style.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>PAS_Left</code> (in configuration: <code>Left</code>)\nAlign pointer to the left.</li>\n<li><code>PAS_Right</code> (in configuration: <code>Right</code>)\nAlign pointer to the right.</li>\n<li><code>PAS_Middle</code> (in configuration: <code>Middle</code>)\nAlign pointer in the middle.</li>\n</ul>\n",
            "options": [
                "Left",
                "Right",
                "Middle"
            ]
        },
        "SpaceAfterCStyleCast": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, a space may be inserted after C style casts.</p>\n"
        },
        "SpaceBeforeAssignmentOperators": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, spaces will be removed before assignment operators.</p>\n"
        },
        "SpaceBeforeParens": {
            "type": "SpaceBeforeParensOptions",
            "doc": "<p>  Defines in which cases to put a space before opening parentheses.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>SBPO_Never</code> (in configuration: <code>Never</code>)\nNever put a space before opening parentheses.</li>\n<li><code>SBPO_ControlStatements</code> (in configuration: <code>ControlStatements</code>)\nPut a space before opening parentheses only after control statement\nkeywords (<code>for/if/while...</code>).</li>\n<li><code>SBPO_Always</code> (in configuration: <code>Always</code>)\nAlways put a space before opening parentheses, except when it&#39;s\nprohibited by the syntax rules (in function-like macro definitions) or\nwhen determined by other style rules (after unary operators, opening\nparentheses, etc.)</li>\n</ul>\n",
            "options": [
                "Never",
                "ControlStatements",
                "Always"
            ]
        },
        "SpaceInEmptyParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into &#39;()&#39;.</p>\n"
        },
        "SpacesBeforeTrailingComments": {
            "type": "unsigned",
            "doc": "<p>  The number of spaces before trailing line comments\n  (<code>//</code> - comments).</p>\n<p>  This does not affect trailing block comments (<code>/**/</code> - comments) as those\n  commonly have different usage patterns and a number of special cases.</p>\n"
        },
        "SpacesInAngles": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after &#39;&lt;&#39; and before &#39;&gt;&#39; in\n  template argument lists</p>\n"
        },
        "SpacesInCStyleCastParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into C style casts.</p>\n"
        },
        "SpacesInContainerLiterals": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces are inserted inside container literals (e.g.\n  ObjC and Javascript array and dict literals).</p>\n"
        },
        "SpacesInParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after &#39;(&#39; and before &#39;)&#39;.</p>\n"
        },
        "SpacesInSquareBrackets": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after &#39;[&#39; and before &#39;]&#39;.</p>\n"
        },
        "Standard": {
            "type": "LanguageStandard",
            "doc": "<p>  Format compatible with this standard, e.g. use\n  <code>A&lt;A&lt;int&gt; &gt;</code> instead of <code>A&lt;A&lt;int&gt;&gt;</code> for LS_Cpp03.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LS_Cpp03</code> (in configuration: <code>Cpp03</code>)\nUse C++03-compatible syntax.</li>\n<li><code>LS_Cpp11</code> (in configuration: <code>Cpp11</code>)\nUse features of C++11 (e.g. <code>A&lt;A&lt;int&gt;&gt;</code> instead of\n<code>A&lt;A&lt;int&gt; &gt;</code>).</li>\n<li><code>LS_Auto</code> (in configuration: <code>Auto</code>)\nAutomatic detection based on the input.</li>\n</ul>\n",
            "options": [
                "Cpp03",
                "Cpp11",
                "Auto"
            ]
        },
        "TabWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns used for tab stops.</p>\n"
        },
        "UseTab": {
            "type": "UseTabStyle",
            "doc": "<p>  The way to use tab characters in the resulting file.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>UT_Never</code> (in configuration: <code>Never</code>)\nNever use tab.</li>\n<li><code>UT_ForIndentation</code> (in configuration: <code>ForIndentation</code>)\nUse tabs only for indentation.</li>\n<li><code>UT_Always</code> (in configuration: <code>Always</code>)\nUse tabs whenever we need to fill whitespace that spans at least from\none tab stop to the next one.</li>\n</ul>\n",
            "options": [
                "Never",
                "ForIndentation",
                "Always"
            ]
        }
    },
    "3.8.0": {
        "BasedOnStyle": {
            "type": "string",
            "doc": "<p>  The style used for all options not specifically set in the configuration.</p>\n<p>  This option is supported only in the <strong>clang-format</strong> configuration\n  (both within <code>-style=&#39;{...}&#39;</code> and the <code>.clang-format</code> file).</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LLVM</code>\nA style complying with the <a href=\"http://llvm.org/docs/CodingStandards.html\">LLVM coding standards</a></li>\n<li><code>Google</code>\nA style complying with <a href=\"http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml\">Google&#39;s C++ style guide</a></li>\n<li><code>Chromium</code>\nA style complying with <a href=\"http://www.chromium.org/developers/coding-style\">Chromium&#39;s style guide</a></li>\n<li><code>Mozilla</code>\nA style complying with <a href=\"https://developer.mozilla.org/en-US/docs/Developer_Guide/Coding_Style\">Mozilla&#39;s style guide</a></li>\n<li><code>WebKit</code>\nA style complying with <a href=\"http://www.webkit.org/coding/coding-style.html\">WebKit&#39;s style guide</a></li>\n</ul>\n",
            "options": [
                "LLVM",
                "Google",
                "Chromium",
                "Mozilla",
                "WebKit"
            ]
        },
        "AccessModifierOffset": {
            "type": "int",
            "doc": "<p>  The extra indent or outdent of access modifiers, e.g. <code>public:</code>.</p>\n"
        },
        "AlignAfterOpenBracket": {
            "type": "BracketAlignmentStyle",
            "doc": "<p>  If <code>true</code>, horizontally aligns arguments after an open bracket.</p>\n<p>  This applies to round brackets (parentheses), angle brackets and square\n  brackets. This will result in formattings like</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BAS_Align</code> (in configuration: <code>Align</code>)\nAlign parameters on the open bracket, e.g.:</p>\n<pre><code>  someLongFunction(argument1,\n                   argument2);\n</code></pre></li>\n<li><p><code>BAS_DontAlign</code> (in configuration: <code>DontAlign</code>)\nDon&#39;t align, instead use <code>ContinuationIndentWidth</code>, e.g.:</p>\n<pre><code>  someLongFunction(argument1,\n      argument2);\n</code></pre></li>\n<li><p><code>BAS_AlwaysBreak</code> (in configuration: <code>AlwaysBreak</code>)\nAlways break after an open bracket, if the parameters don&#39;t fit\non a single line, e.g.:</p>\n<pre><code>  someLongFunction(\n      argument1, argument2);\n</code></pre></li>\n</ul>\n",
            "options": [
                "Align",
                "DontAlign",
                "AlwaysBreak"
            ]
        },
        "AlignConsecutiveAssignments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns consecutive assignments.</p>\n<p>  This will align the assignment operators of consecutive lines. This\n  will result in formattings like</p>\n<pre><code class=\"lang-  \">    int aaaa = 12;\n    int b    = 23;\n    int ccc  = 23;\n</code></pre>\n"
        },
        "AlignConsecutiveDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns consecutive declarations.</p>\n<p>  This will align the declaration names of consecutive lines. This\n  will result in formattings like</p>\n<pre><code class=\"lang-  \">    int         aaaa = 12;\n    float       b = 23;\n    std::string ccc = 23;\n</code></pre>\n"
        },
        "AlignEscapedNewlinesLeft": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns escaped newlines as far left as possible.\n  Otherwise puts them into the right-most column.</p>\n"
        },
        "AlignOperands": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, horizontally align operands of binary and ternary\n  expressions.</p>\n"
        },
        "AlignTrailingComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns trailing comments.</p>\n"
        },
        "AllowAllParametersOfDeclarationOnNextLine": {
            "type": "bool",
            "doc": "<p>  Allow putting all parameters of a function declaration onto\n  the next line even if <code>BinPackParameters</code> is <code>false</code>.</p>\n"
        },
        "AllowShortBlocksOnASingleLine": {
            "type": "bool",
            "doc": "<p>  Allows contracting simple braced statements to a single line.</p>\n<p>  E.g., this allows <code>if (a) { return; }</code> to be put on a single line.</p>\n"
        },
        "AllowShortCaseLabelsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, short case labels will be contracted to a single line.</p>\n"
        },
        "AllowShortFunctionsOnASingleLine": {
            "type": "ShortFunctionStyle",
            "doc": "<p>  Dependent on the value, <code>int f() { return 0; }</code> can be put\n  on a single line.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>SFS_None</code> (in configuration: <code>None</code>)\nNever merge functions into a single line.</li>\n<li><code>SFS_Empty</code> (in configuration: <code>Empty</code>)\nOnly merge empty functions.</li>\n<li><code>SFS_Inline</code> (in configuration: <code>Inline</code>)\nOnly merge functions defined inside a class. Implies &quot;empty&quot;.</li>\n<li><code>SFS_All</code> (in configuration: <code>All</code>)\nMerge all functions fitting on a single line.</li>\n</ul>\n",
            "options": [
                "None",
                "Empty",
                "Inline",
                "All"
            ]
        },
        "AllowShortIfStatementsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>if (a) return;</code> can be put on a single\n  line.</p>\n"
        },
        "AllowShortLoopsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>while (true) continue;</code> can be put on a\n  single line.</p>\n"
        },
        "AlwaysBreakAfterDefinitionReturnType": {
            "type": "DefinitionReturnTypeBreakingStyle",
            "doc": "<p>  The function definition return type breaking style to use.  This\n  option is deprecated and is retained for backwards compatibility.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>DRTBS_None</code> (in configuration: <code>None</code>)\nBreak after return type automatically.\n<code>PenaltyReturnTypeOnItsOwnLine</code> is taken into account.</li>\n<li><code>DRTBS_All</code> (in configuration: <code>All</code>)\nAlways break after the return type.</li>\n<li><code>DRTBS_TopLevel</code> (in configuration: <code>TopLevel</code>)\nAlways break after the return types of top-level functions.</li>\n</ul>\n",
            "options": [
                "None",
                "All",
                "TopLevel"
            ]
        },
        "AlwaysBreakAfterReturnType": {
            "type": "ReturnTypeBreakingStyle",
            "doc": "<p>  The function declaration return type breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>RTBS_None</code> (in configuration: <code>None</code>)\nBreak after return type automatically.\n<code>PenaltyReturnTypeOnItsOwnLine</code> is taken into account.</li>\n<li><code>RTBS_All</code> (in configuration: <code>All</code>)\nAlways break after the return type.</li>\n<li><code>RTBS_TopLevel</code> (in configuration: <code>TopLevel</code>)\nAlways break after the return types of top-level functions.</li>\n<li><code>RTBS_AllDefinitions</code> (in configuration: <code>AllDefinitions</code>)\nAlways break after the return type of function definitions.</li>\n<li><code>RTBS_TopLevelDefinitions</code> (in configuration: <code>TopLevelDefinitions</code>)\nAlways break after the return type of top-level definitions.</li>\n</ul>\n",
            "options": [
                "None",
                "All",
                "TopLevel",
                "AllDefinitions",
                "TopLevelDefinitions"
            ]
        },
        "AlwaysBreakBeforeMultilineStrings": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break before multiline string literals.</p>\n<p>  This flag is mean to make cases where there are multiple multiline strings\n  in a file look more consistent. Thus, it will only take effect if wrapping\n  the string at that point leads to it being indented\n  <code>ContinuationIndentWidth</code> spaces from the start of the line.</p>\n"
        },
        "AlwaysBreakTemplateDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break after the <code>template&lt;...&gt;</code> of a\n  template declaration.</p>\n"
        },
        "BinPackArguments": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function call&#39;s arguments will either be all on the\n  same line or will have one line each.</p>\n"
        },
        "BinPackParameters": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function declaration&#39;s or function definition&#39;s\n  parameters will either all be on the same line or will have one line each.</p>\n"
        },
        "BraceWrapping": {
            "type": "BraceWrappingFlags",
            "doc": "<p>  Control of individual brace wrapping cases.</p>\n<p>  If <code>BreakBeforeBraces</code> is set to <code>custom</code>, use this to specify how each\n  individual brace case should be handled. Otherwise, this is ignored.</p>\n<p>  Nested configuration flags:</p>\n<ul>\n<li><code>bool AfterClass</code> Wrap class definitions.</li>\n<li><code>bool AfterControlStatement</code> Wrap control statements (if/for/while/switch/..).</li>\n<li><code>bool AfterEnum</code> Wrap enum definitions.</li>\n<li><code>bool AfterFunction</code> Wrap function definitions.</li>\n<li><code>bool AfterNamespace</code> Wrap namespace definitions.</li>\n<li><code>bool AfterObjCDeclaration</code> Wrap ObjC definitions (@autoreleasepool, interfaces, ..).</li>\n<li><code>bool AfterStruct</code> Wrap struct definitions.</li>\n<li><code>bool AfterUnion</code> Wrap union definitions.</li>\n<li><code>bool BeforeCatch</code> Wrap before <code>catch</code>.</li>\n<li><code>bool BeforeElse</code> Wrap before <code>else</code>.</li>\n<li><code>bool IndentBraces</code> Indent the wrapped braces themselves.</li>\n</ul>\n",
            "options": [
                "AfterClass",
                "AfterControlStatement",
                "AfterEnum",
                "AfterFunction",
                "AfterNamespace",
                "AfterObjCDeclaration",
                "AfterStruct",
                "AfterUnion",
                "BeforeCatch",
                "BeforeElse",
                "IndentBraces"
            ]
        },
        "BreakAfterJavaFieldAnnotations": {
            "type": "bool",
            "doc": "<p>  Break after each annotation on a field in Java files.</p>\n"
        },
        "BreakBeforeBinaryOperators": {
            "type": "BinaryOperatorStyle",
            "doc": "<p>  The way to wrap binary operators.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>BOS_None</code> (in configuration: <code>None</code>)\nBreak after operators.</li>\n<li><code>BOS_NonAssignment</code> (in configuration: <code>NonAssignment</code>)\nBreak before operators that aren&#39;t assignments.</li>\n<li><code>BOS_All</code> (in configuration: <code>All</code>)\nBreak before operators.</li>\n</ul>\n",
            "options": [
                "None",
                "NonAssignment",
                "All"
            ]
        },
        "BreakBeforeBraces": {
            "type": "BraceBreakingStyle",
            "doc": "<p>  The brace breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>BS_Attach</code> (in configuration: <code>Attach</code>)\nAlways attach braces to surrounding context.</li>\n<li><code>BS_Linux</code> (in configuration: <code>Linux</code>)\nLike <code>Attach</code>, but break before braces on function, namespace and\nclass definitions.</li>\n<li><code>BS_Mozilla</code> (in configuration: <code>Mozilla</code>)\nLike <code>Attach</code>, but break before braces on enum, function, and record\ndefinitions.</li>\n<li><code>BS_Stroustrup</code> (in configuration: <code>Stroustrup</code>)\nLike <code>Attach</code>, but break before function definitions, &#39;catch&#39;, and &#39;else&#39;.</li>\n<li><code>BS_Allman</code> (in configuration: <code>Allman</code>)\nAlways break before braces.</li>\n<li><code>BS_GNU</code> (in configuration: <code>GNU</code>)\nAlways break before braces and add an extra level of indentation to\nbraces of control statements, not to those of class, function\nor other definitions.</li>\n<li><code>BS_WebKit</code> (in configuration: <code>WebKit</code>)\nLike <code>Attach</code>, but break before functions.</li>\n<li><code>BS_Custom</code> (in configuration: <code>Custom</code>)\nConfigure each individual brace in <code>BraceWrapping</code>.</li>\n</ul>\n",
            "options": [
                "Attach",
                "Linux",
                "Mozilla",
                "Stroustrup",
                "Allman",
                "GNU",
                "WebKit",
                "Custom"
            ]
        },
        "BreakBeforeTernaryOperators": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, ternary operators will be placed after line breaks.</p>\n"
        },
        "BreakConstructorInitializersBeforeComma": {
            "type": "bool",
            "doc": "<p>  Always break constructor initializers before commas and align\n  the commas with the colon.</p>\n"
        },
        "ColumnLimit": {
            "type": "unsigned",
            "doc": "<p>  The column limit.</p>\n<p>  A column limit of <code>0</code> means that there is no column limit. In this case,\n  clang-format will respect the input&#39;s line breaking decisions within\n  statements unless they contradict other rules.</p>\n"
        },
        "CommentPragmas": {
            "type": "std::string",
            "doc": "<p>  A regular expression that describes comments with special meaning,\n  which should not be split into lines or otherwise changed.</p>\n"
        },
        "ConstructorInitializerAllOnOneLineOrOnePerLine": {
            "type": "bool",
            "doc": "<p>  If the constructor initializers don&#39;t fit on a line, put each\n  initializer on its own line.</p>\n"
        },
        "ConstructorInitializerIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of constructor\n  initializer lists.</p>\n"
        },
        "ContinuationIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  Indent width for line continuations.</p>\n"
        },
        "Cpp11BracedListStyle": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, format braced lists as best suited for C++11 braced\n  lists.</p>\n<p>  Important differences:</p>\n<ul>\n<li>No spaces inside the braced list.</li>\n<li>No line break before the closing brace.</li>\n<li><p>Indentation with the continuation indent, not with the block indent.</p>\n<p>Fundamentally, C++11 braced lists are formatted exactly like function\ncalls would be formatted in their place. If the braced list follows a name\n(e.g. a type or variable name), clang-format formats as if the <code>{}</code> were\nthe parentheses of a function call with that name. If there is no name,\na zero-length name is assumed.</p>\n</li>\n</ul>\n"
        },
        "DerivePointerAlignment": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, analyze the formatted file for the most common\n  alignment of &amp; and *. <code>PointerAlignment</code> is then used only as fallback.</p>\n"
        },
        "DisableFormat": {
            "type": "bool",
            "doc": "<p>  Disables formatting completely.</p>\n"
        },
        "ExperimentalAutoDetectBinPacking": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format detects whether function calls and\n  definitions are formatted with one parameter per line.</p>\n<p>  Each call can be bin-packed, one-per-line or inconclusive. If it is\n  inconclusive, e.g. completely on one line, but a decision needs to be\n  made, clang-format analyzes whether there are other bin-packed cases in\n  the input file and act accordingly.</p>\n<p>  NOTE: This is an experimental flag, that might go away or be renamed. Do\n  not use this in config files, etc. Use at your own risk.</p>\n"
        },
        "ForEachMacros": {
            "type": "std::vector<std::string>",
            "doc": "<p>  A vector of macros that should be interpreted as foreach loops\n  instead of as function calls.</p>\n<p>  These are expected to be macros of the form:</p>\n<pre><code class=\"lang-  \">    FOREACH(&lt;variable-declaration&gt;, ...)\n      &lt;loop-body&gt;\n</code></pre>\n<p>  In the .clang-format configuration file, this can be configured like:</p>\n<pre><code class=\"lang-  \">    ForEachMacros: [&#39;RANGES_FOR&#39;, &#39;FOREACH&#39;]\n</code></pre>\n<p>  For example: BOOST_FOREACH.</p>\n"
        },
        "IncludeCategories": {
            "type": "std::vector<IncludeCategory>",
            "doc": "<p>  Regular expressions denoting the different #include categories used\n  for ordering #includes.</p>\n<p>  These regular expressions are matched against the filename of an include\n  (including the &lt;&gt; or &quot;&quot;) in order. The value belonging to the first\n  matching regular expression is assigned and #includes are sorted first\n  according to increasing category number and then alphabetically within\n  each category.</p>\n<p>  If none of the regular expressions match, UINT_MAX is assigned as\n  category. The main header for a source file automatically gets category 0,\n  so that it is kept at the beginning of the #includes\n  (http://llvm.org/docs/CodingStandards.html#include-style).</p>\n<p>  To configure this in the .clang-format file, use:</p>\n<pre><code class=\"lang-  \">    IncludeCategories:\n      - Regex:           &#39;^&quot;(llvm|llvm-c|clang|clang-c)/&#39;\n        Priority:        2\n      - Regex:           &#39;^(&lt;|&quot;(gtest|isl|json)/)&#39;\n        Priority:        3\n      - Regex:           &#39;.\\*&#39;\n        Priority:        1\n</code></pre>\n",
            "options": []
        },
        "IndentCaseLabels": {
            "type": "bool",
            "doc": "<p>  Indent case labels one level from the switch statement.</p>\n<p>  When <code>false</code>, use the same indentation level as for the switch statement.\n  Switch statement body is always indented one level more than case labels.</p>\n"
        },
        "IndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns to use for indentation.</p>\n"
        },
        "IndentWrappedFunctionNames": {
            "type": "bool",
            "doc": "<p>  Indent if a function definition or declaration is wrapped after the\n  type.</p>\n"
        },
        "KeepEmptyLinesAtTheStartOfBlocks": {
            "type": "bool",
            "doc": "<p>  If true, empty lines at the start of blocks are kept.</p>\n"
        },
        "Language": {
            "type": "LanguageKind",
            "doc": "<p>  Language, this format style is targeted at.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LK_None</code> (in configuration: <code>None</code>)\nDo not use.</li>\n<li><code>LK_Cpp</code> (in configuration: <code>Cpp</code>)\nShould be used for C, C++, ObjectiveC, ObjectiveC++.</li>\n<li><code>LK_Java</code> (in configuration: <code>Java</code>)\nShould be used for Java.</li>\n<li><code>LK_JavaScript</code> (in configuration: <code>JavaScript</code>)\nShould be used for JavaScript.</li>\n<li><code>LK_Proto</code> (in configuration: <code>Proto</code>)\nShould be used for Protocol Buffers\n(https://developers.google.com/protocol-buffers/).</li>\n</ul>\n",
            "options": [
                "None",
                "Cpp",
                "Java",
                "JavaScript",
                "Proto"
            ]
        },
        "MacroBlockBegin": {
            "type": "std::string",
            "doc": "<p>  A regular expression matching macros that start a block.</p>\n"
        },
        "MacroBlockEnd": {
            "type": "std::string",
            "doc": "<p>  A regular expression matching macros that end a block.</p>\n"
        },
        "MaxEmptyLinesToKeep": {
            "type": "unsigned",
            "doc": "<p>  The maximum number of consecutive empty lines to keep.</p>\n"
        },
        "NamespaceIndentation": {
            "type": "NamespaceIndentationKind",
            "doc": "<p>  The indentation used for namespaces.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>NI_None</code> (in configuration: <code>None</code>)\nDon&#39;t indent in namespaces.</li>\n<li><code>NI_Inner</code> (in configuration: <code>Inner</code>)\nIndent only in inner namespaces (nested in other namespaces).</li>\n<li><code>NI_All</code> (in configuration: <code>All</code>)\nIndent in all namespaces.</li>\n</ul>\n",
            "options": [
                "None",
                "Inner",
                "All"
            ]
        },
        "ObjCBlockIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of ObjC blocks.</p>\n"
        },
        "ObjCSpaceAfterProperty": {
            "type": "bool",
            "doc": "<p>  Add a space after <code>@property</code> in Objective-C, i.e. use\n  <code>\\@property (readonly)</code> instead of <code>\\@property(readonly)</code>.</p>\n"
        },
        "ObjCSpaceBeforeProtocolList": {
            "type": "bool",
            "doc": "<p>  Add a space in front of an Objective-C protocol list, i.e. use\n  <code>Foo &lt;Protocol&gt;</code> instead of <code>Foo&lt;Protocol&gt;</code>.</p>\n"
        },
        "PenaltyBreakBeforeFirstCallParameter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking a function call after &quot;call(&quot;.</p>\n"
        },
        "PenaltyBreakComment": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a comment.</p>\n"
        },
        "PenaltyBreakFirstLessLess": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking before the first <code>&lt;&lt;</code>.</p>\n"
        },
        "PenaltyBreakString": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a string literal.</p>\n"
        },
        "PenaltyExcessCharacter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each character outside of the column limit.</p>\n"
        },
        "PenaltyReturnTypeOnItsOwnLine": {
            "type": "unsigned",
            "doc": "<p>  Penalty for putting the return type of a function onto its own\n  line.</p>\n"
        },
        "PointerAlignment": {
            "type": "PointerAlignmentStyle",
            "doc": "<p>  Pointer and reference alignment style.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>PAS_Left</code> (in configuration: <code>Left</code>)\nAlign pointer to the left.</li>\n<li><code>PAS_Right</code> (in configuration: <code>Right</code>)\nAlign pointer to the right.</li>\n<li><code>PAS_Middle</code> (in configuration: <code>Middle</code>)\nAlign pointer in the middle.</li>\n</ul>\n",
            "options": [
                "Left",
                "Right",
                "Middle"
            ]
        },
        "SpaceAfterCStyleCast": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, a space may be inserted after C style casts.</p>\n"
        },
        "SpaceBeforeAssignmentOperators": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, spaces will be removed before assignment operators.</p>\n"
        },
        "SpaceBeforeParens": {
            "type": "SpaceBeforeParensOptions",
            "doc": "<p>  Defines in which cases to put a space before opening parentheses.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>SBPO_Never</code> (in configuration: <code>Never</code>)\nNever put a space before opening parentheses.</li>\n<li><code>SBPO_ControlStatements</code> (in configuration: <code>ControlStatements</code>)\nPut a space before opening parentheses only after control statement\nkeywords (<code>for/if/while...</code>).</li>\n<li><code>SBPO_Always</code> (in configuration: <code>Always</code>)\nAlways put a space before opening parentheses, except when it&#39;s\nprohibited by the syntax rules (in function-like macro definitions) or\nwhen determined by other style rules (after unary operators, opening\nparentheses, etc.)</li>\n</ul>\n",
            "options": [
                "Never",
                "ControlStatements",
                "Always"
            ]
        },
        "SpaceInEmptyParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into &#39;()&#39;.</p>\n"
        },
        "SpacesBeforeTrailingComments": {
            "type": "unsigned",
            "doc": "<p>  The number of spaces before trailing line comments\n  (<code>//</code> - comments).</p>\n<p>  This does not affect trailing block comments (<code>/**/</code> - comments) as those\n  commonly have different usage patterns and a number of special cases.</p>\n"
        },
        "SpacesInAngles": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after &#39;&lt;&#39; and before &#39;&gt;&#39; in\n  template argument lists</p>\n"
        },
        "SpacesInCStyleCastParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into C style casts.</p>\n"
        },
        "SpacesInContainerLiterals": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces are inserted inside container literals (e.g.\n  ObjC and Javascript array and dict literals).</p>\n"
        },
        "SpacesInParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after &#39;(&#39; and before &#39;)&#39;.</p>\n"
        },
        "SpacesInSquareBrackets": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after &#39;[&#39; and before &#39;]&#39;.</p>\n"
        },
        "Standard": {
            "type": "LanguageStandard",
            "doc": "<p>  Format compatible with this standard, e.g. use\n  <code>A&lt;A&lt;int&gt; &gt;</code> instead of <code>A&lt;A&lt;int&gt;&gt;</code> for LS_Cpp03.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LS_Cpp03</code> (in configuration: <code>Cpp03</code>)\nUse C++03-compatible syntax.</li>\n<li><code>LS_Cpp11</code> (in configuration: <code>Cpp11</code>)\nUse features of C++11 (e.g. <code>A&lt;A&lt;int&gt;&gt;</code> instead of\n<code>A&lt;A&lt;int&gt; &gt;</code>).</li>\n<li><code>LS_Auto</code> (in configuration: <code>Auto</code>)\nAutomatic detection based on the input.</li>\n</ul>\n",
            "options": [
                "Cpp03",
                "Cpp11",
                "Auto"
            ]
        },
        "TabWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns used for tab stops.</p>\n"
        },
        "UseTab": {
            "type": "UseTabStyle",
            "doc": "<p>  The way to use tab characters in the resulting file.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>UT_Never</code> (in configuration: <code>Never</code>)\nNever use tab.</li>\n<li><code>UT_ForIndentation</code> (in configuration: <code>ForIndentation</code>)\nUse tabs only for indentation.</li>\n<li><code>UT_Always</code> (in configuration: <code>Always</code>)\nUse tabs whenever we need to fill whitespace that spans at least from\none tab stop to the next one.</li>\n</ul>\n",
            "options": [
                "Never",
                "ForIndentation",
                "Always"
            ]
        }
    },
    "3.8.1": {
        "BasedOnStyle": {
            "type": "string",
            "doc": "<p>  The style used for all options not specifically set in the configuration.</p>\n<p>  This option is supported only in the <strong>clang-format</strong> configuration\n  (both within <code>-style=&#39;{...}&#39;</code> and the <code>.clang-format</code> file).</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LLVM</code>\nA style complying with the <a href=\"http://llvm.org/docs/CodingStandards.html\">LLVM coding standards</a></li>\n<li><code>Google</code>\nA style complying with <a href=\"http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml\">Google&#39;s C++ style guide</a></li>\n<li><code>Chromium</code>\nA style complying with <a href=\"http://www.chromium.org/developers/coding-style\">Chromium&#39;s style guide</a></li>\n<li><code>Mozilla</code>\nA style complying with <a href=\"https://developer.mozilla.org/en-US/docs/Developer_Guide/Coding_Style\">Mozilla&#39;s style guide</a></li>\n<li><code>WebKit</code>\nA style complying with <a href=\"http://www.webkit.org/coding/coding-style.html\">WebKit&#39;s style guide</a></li>\n</ul>\n",
            "options": [
                "LLVM",
                "Google",
                "Chromium",
                "Mozilla",
                "WebKit"
            ]
        },
        "AccessModifierOffset": {
            "type": "int",
            "doc": "<p>  The extra indent or outdent of access modifiers, e.g. <code>public:</code>.</p>\n"
        },
        "AlignAfterOpenBracket": {
            "type": "BracketAlignmentStyle",
            "doc": "<p>  If <code>true</code>, horizontally aligns arguments after an open bracket.</p>\n<p>  This applies to round brackets (parentheses), angle brackets and square\n  brackets. This will result in formattings like</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BAS_Align</code> (in configuration: <code>Align</code>)\nAlign parameters on the open bracket, e.g.:</p>\n<pre><code>  someLongFunction(argument1,\n                   argument2);\n</code></pre></li>\n<li><p><code>BAS_DontAlign</code> (in configuration: <code>DontAlign</code>)\nDon&#39;t align, instead use <code>ContinuationIndentWidth</code>, e.g.:</p>\n<pre><code>  someLongFunction(argument1,\n      argument2);\n</code></pre></li>\n<li><p><code>BAS_AlwaysBreak</code> (in configuration: <code>AlwaysBreak</code>)\nAlways break after an open bracket, if the parameters don&#39;t fit\non a single line, e.g.:</p>\n<pre><code>  someLongFunction(\n      argument1, argument2);\n</code></pre></li>\n</ul>\n",
            "options": [
                "Align",
                "DontAlign",
                "AlwaysBreak"
            ]
        },
        "AlignConsecutiveAssignments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns consecutive assignments.</p>\n<p>  This will align the assignment operators of consecutive lines. This\n  will result in formattings like</p>\n<pre><code class=\"lang-  \">    int aaaa = 12;\n    int b    = 23;\n    int ccc  = 23;\n</code></pre>\n"
        },
        "AlignConsecutiveDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns consecutive declarations.</p>\n<p>  This will align the declaration names of consecutive lines. This\n  will result in formattings like</p>\n<pre><code class=\"lang-  \">    int         aaaa = 12;\n    float       b = 23;\n    std::string ccc = 23;\n</code></pre>\n"
        },
        "AlignEscapedNewlinesLeft": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns escaped newlines as far left as possible.\n  Otherwise puts them into the right-most column.</p>\n"
        },
        "AlignOperands": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, horizontally align operands of binary and ternary\n  expressions.</p>\n"
        },
        "AlignTrailingComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns trailing comments.</p>\n"
        },
        "AllowAllParametersOfDeclarationOnNextLine": {
            "type": "bool",
            "doc": "<p>  Allow putting all parameters of a function declaration onto\n  the next line even if <code>BinPackParameters</code> is <code>false</code>.</p>\n"
        },
        "AllowShortBlocksOnASingleLine": {
            "type": "bool",
            "doc": "<p>  Allows contracting simple braced statements to a single line.</p>\n<p>  E.g., this allows <code>if (a) { return; }</code> to be put on a single line.</p>\n"
        },
        "AllowShortCaseLabelsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, short case labels will be contracted to a single line.</p>\n"
        },
        "AllowShortFunctionsOnASingleLine": {
            "type": "ShortFunctionStyle",
            "doc": "<p>  Dependent on the value, <code>int f() { return 0; }</code> can be put\n  on a single line.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>SFS_None</code> (in configuration: <code>None</code>)\nNever merge functions into a single line.</li>\n<li><code>SFS_Empty</code> (in configuration: <code>Empty</code>)\nOnly merge empty functions.</li>\n<li><code>SFS_Inline</code> (in configuration: <code>Inline</code>)\nOnly merge functions defined inside a class. Implies &quot;empty&quot;.</li>\n<li><code>SFS_All</code> (in configuration: <code>All</code>)\nMerge all functions fitting on a single line.</li>\n</ul>\n",
            "options": [
                "None",
                "Empty",
                "Inline",
                "All"
            ]
        },
        "AllowShortIfStatementsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>if (a) return;</code> can be put on a single\n  line.</p>\n"
        },
        "AllowShortLoopsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>while (true) continue;</code> can be put on a\n  single line.</p>\n"
        },
        "AlwaysBreakAfterDefinitionReturnType": {
            "type": "DefinitionReturnTypeBreakingStyle",
            "doc": "<p>  The function definition return type breaking style to use.  This\n  option is deprecated and is retained for backwards compatibility.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>DRTBS_None</code> (in configuration: <code>None</code>)\nBreak after return type automatically.\n<code>PenaltyReturnTypeOnItsOwnLine</code> is taken into account.</li>\n<li><code>DRTBS_All</code> (in configuration: <code>All</code>)\nAlways break after the return type.</li>\n<li><code>DRTBS_TopLevel</code> (in configuration: <code>TopLevel</code>)\nAlways break after the return types of top-level functions.</li>\n</ul>\n",
            "options": [
                "None",
                "All",
                "TopLevel"
            ]
        },
        "AlwaysBreakAfterReturnType": {
            "type": "ReturnTypeBreakingStyle",
            "doc": "<p>  The function declaration return type breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>RTBS_None</code> (in configuration: <code>None</code>)\nBreak after return type automatically.\n<code>PenaltyReturnTypeOnItsOwnLine</code> is taken into account.</li>\n<li><code>RTBS_All</code> (in configuration: <code>All</code>)\nAlways break after the return type.</li>\n<li><code>RTBS_TopLevel</code> (in configuration: <code>TopLevel</code>)\nAlways break after the return types of top-level functions.</li>\n<li><code>RTBS_AllDefinitions</code> (in configuration: <code>AllDefinitions</code>)\nAlways break after the return type of function definitions.</li>\n<li><code>RTBS_TopLevelDefinitions</code> (in configuration: <code>TopLevelDefinitions</code>)\nAlways break after the return type of top-level definitions.</li>\n</ul>\n",
            "options": [
                "None",
                "All",
                "TopLevel",
                "AllDefinitions",
                "TopLevelDefinitions"
            ]
        },
        "AlwaysBreakBeforeMultilineStrings": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break before multiline string literals.</p>\n<p>  This flag is mean to make cases where there are multiple multiline strings\n  in a file look more consistent. Thus, it will only take effect if wrapping\n  the string at that point leads to it being indented\n  <code>ContinuationIndentWidth</code> spaces from the start of the line.</p>\n"
        },
        "AlwaysBreakTemplateDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break after the <code>template&lt;...&gt;</code> of a\n  template declaration.</p>\n"
        },
        "BinPackArguments": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function call&#39;s arguments will either be all on the\n  same line or will have one line each.</p>\n"
        },
        "BinPackParameters": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function declaration&#39;s or function definition&#39;s\n  parameters will either all be on the same line or will have one line each.</p>\n"
        },
        "BraceWrapping": {
            "type": "BraceWrappingFlags",
            "doc": "<p>  Control of individual brace wrapping cases.</p>\n<p>  If <code>BreakBeforeBraces</code> is set to <code>custom</code>, use this to specify how each\n  individual brace case should be handled. Otherwise, this is ignored.</p>\n<p>  Nested configuration flags:</p>\n<ul>\n<li><code>bool AfterClass</code> Wrap class definitions.</li>\n<li><code>bool AfterControlStatement</code> Wrap control statements (if/for/while/switch/..).</li>\n<li><code>bool AfterEnum</code> Wrap enum definitions.</li>\n<li><code>bool AfterFunction</code> Wrap function definitions.</li>\n<li><code>bool AfterNamespace</code> Wrap namespace definitions.</li>\n<li><code>bool AfterObjCDeclaration</code> Wrap ObjC definitions (@autoreleasepool, interfaces, ..).</li>\n<li><code>bool AfterStruct</code> Wrap struct definitions.</li>\n<li><code>bool AfterUnion</code> Wrap union definitions.</li>\n<li><code>bool BeforeCatch</code> Wrap before <code>catch</code>.</li>\n<li><code>bool BeforeElse</code> Wrap before <code>else</code>.</li>\n<li><code>bool IndentBraces</code> Indent the wrapped braces themselves.</li>\n</ul>\n",
            "options": [
                "AfterClass",
                "AfterControlStatement",
                "AfterEnum",
                "AfterFunction",
                "AfterNamespace",
                "AfterObjCDeclaration",
                "AfterStruct",
                "AfterUnion",
                "BeforeCatch",
                "BeforeElse",
                "IndentBraces"
            ]
        },
        "BreakAfterJavaFieldAnnotations": {
            "type": "bool",
            "doc": "<p>  Break after each annotation on a field in Java files.</p>\n"
        },
        "BreakBeforeBinaryOperators": {
            "type": "BinaryOperatorStyle",
            "doc": "<p>  The way to wrap binary operators.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>BOS_None</code> (in configuration: <code>None</code>)\nBreak after operators.</li>\n<li><code>BOS_NonAssignment</code> (in configuration: <code>NonAssignment</code>)\nBreak before operators that aren&#39;t assignments.</li>\n<li><code>BOS_All</code> (in configuration: <code>All</code>)\nBreak before operators.</li>\n</ul>\n",
            "options": [
                "None",
                "NonAssignment",
                "All"
            ]
        },
        "BreakBeforeBraces": {
            "type": "BraceBreakingStyle",
            "doc": "<p>  The brace breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>BS_Attach</code> (in configuration: <code>Attach</code>)\nAlways attach braces to surrounding context.</li>\n<li><code>BS_Linux</code> (in configuration: <code>Linux</code>)\nLike <code>Attach</code>, but break before braces on function, namespace and\nclass definitions.</li>\n<li><code>BS_Mozilla</code> (in configuration: <code>Mozilla</code>)\nLike <code>Attach</code>, but break before braces on enum, function, and record\ndefinitions.</li>\n<li><code>BS_Stroustrup</code> (in configuration: <code>Stroustrup</code>)\nLike <code>Attach</code>, but break before function definitions, &#39;catch&#39;, and &#39;else&#39;.</li>\n<li><code>BS_Allman</code> (in configuration: <code>Allman</code>)\nAlways break before braces.</li>\n<li><code>BS_GNU</code> (in configuration: <code>GNU</code>)\nAlways break before braces and add an extra level of indentation to\nbraces of control statements, not to those of class, function\nor other definitions.</li>\n<li><code>BS_WebKit</code> (in configuration: <code>WebKit</code>)\nLike <code>Attach</code>, but break before functions.</li>\n<li><code>BS_Custom</code> (in configuration: <code>Custom</code>)\nConfigure each individual brace in <code>BraceWrapping</code>.</li>\n</ul>\n",
            "options": [
                "Attach",
                "Linux",
                "Mozilla",
                "Stroustrup",
                "Allman",
                "GNU",
                "WebKit",
                "Custom"
            ]
        },
        "BreakBeforeTernaryOperators": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, ternary operators will be placed after line breaks.</p>\n"
        },
        "BreakConstructorInitializersBeforeComma": {
            "type": "bool",
            "doc": "<p>  Always break constructor initializers before commas and align\n  the commas with the colon.</p>\n"
        },
        "ColumnLimit": {
            "type": "unsigned",
            "doc": "<p>  The column limit.</p>\n<p>  A column limit of <code>0</code> means that there is no column limit. In this case,\n  clang-format will respect the input&#39;s line breaking decisions within\n  statements unless they contradict other rules.</p>\n"
        },
        "CommentPragmas": {
            "type": "std::string",
            "doc": "<p>  A regular expression that describes comments with special meaning,\n  which should not be split into lines or otherwise changed.</p>\n"
        },
        "ConstructorInitializerAllOnOneLineOrOnePerLine": {
            "type": "bool",
            "doc": "<p>  If the constructor initializers don&#39;t fit on a line, put each\n  initializer on its own line.</p>\n"
        },
        "ConstructorInitializerIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of constructor\n  initializer lists.</p>\n"
        },
        "ContinuationIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  Indent width for line continuations.</p>\n"
        },
        "Cpp11BracedListStyle": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, format braced lists as best suited for C++11 braced\n  lists.</p>\n<p>  Important differences:</p>\n<ul>\n<li>No spaces inside the braced list.</li>\n<li>No line break before the closing brace.</li>\n<li><p>Indentation with the continuation indent, not with the block indent.</p>\n<p>Fundamentally, C++11 braced lists are formatted exactly like function\ncalls would be formatted in their place. If the braced list follows a name\n(e.g. a type or variable name), clang-format formats as if the <code>{}</code> were\nthe parentheses of a function call with that name. If there is no name,\na zero-length name is assumed.</p>\n</li>\n</ul>\n"
        },
        "DerivePointerAlignment": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, analyze the formatted file for the most common\n  alignment of &amp; and *. <code>PointerAlignment</code> is then used only as fallback.</p>\n"
        },
        "DisableFormat": {
            "type": "bool",
            "doc": "<p>  Disables formatting completely.</p>\n"
        },
        "ExperimentalAutoDetectBinPacking": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format detects whether function calls and\n  definitions are formatted with one parameter per line.</p>\n<p>  Each call can be bin-packed, one-per-line or inconclusive. If it is\n  inconclusive, e.g. completely on one line, but a decision needs to be\n  made, clang-format analyzes whether there are other bin-packed cases in\n  the input file and act accordingly.</p>\n<p>  NOTE: This is an experimental flag, that might go away or be renamed. Do\n  not use this in config files, etc. Use at your own risk.</p>\n"
        },
        "ForEachMacros": {
            "type": "std::vector<std::string>",
            "doc": "<p>  A vector of macros that should be interpreted as foreach loops\n  instead of as function calls.</p>\n<p>  These are expected to be macros of the form:</p>\n<pre><code class=\"lang-  \">    FOREACH(&lt;variable-declaration&gt;, ...)\n      &lt;loop-body&gt;\n</code></pre>\n<p>  In the .clang-format configuration file, this can be configured like:</p>\n<pre><code class=\"lang-  \">    ForEachMacros: [&#39;RANGES_FOR&#39;, &#39;FOREACH&#39;]\n</code></pre>\n<p>  For example: BOOST_FOREACH.</p>\n"
        },
        "IncludeCategories": {
            "type": "std::vector<IncludeCategory>",
            "doc": "<p>  Regular expressions denoting the different #include categories used\n  for ordering #includes.</p>\n<p>  These regular expressions are matched against the filename of an include\n  (including the &lt;&gt; or &quot;&quot;) in order. The value belonging to the first\n  matching regular expression is assigned and #includes are sorted first\n  according to increasing category number and then alphabetically within\n  each category.</p>\n<p>  If none of the regular expressions match, UINT_MAX is assigned as\n  category. The main header for a source file automatically gets category 0,\n  so that it is kept at the beginning of the #includes\n  (http://llvm.org/docs/CodingStandards.html#include-style).</p>\n<p>  To configure this in the .clang-format file, use:</p>\n<pre><code class=\"lang-  \">    IncludeCategories:\n      - Regex:           &#39;^&quot;(llvm|llvm-c|clang|clang-c)/&#39;\n        Priority:        2\n      - Regex:           &#39;^(&lt;|&quot;(gtest|isl|json)/)&#39;\n        Priority:        3\n      - Regex:           &#39;.\\*&#39;\n        Priority:        1\n</code></pre>\n",
            "options": []
        },
        "IndentCaseLabels": {
            "type": "bool",
            "doc": "<p>  Indent case labels one level from the switch statement.</p>\n<p>  When <code>false</code>, use the same indentation level as for the switch statement.\n  Switch statement body is always indented one level more than case labels.</p>\n"
        },
        "IndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns to use for indentation.</p>\n"
        },
        "IndentWrappedFunctionNames": {
            "type": "bool",
            "doc": "<p>  Indent if a function definition or declaration is wrapped after the\n  type.</p>\n"
        },
        "KeepEmptyLinesAtTheStartOfBlocks": {
            "type": "bool",
            "doc": "<p>  If true, empty lines at the start of blocks are kept.</p>\n"
        },
        "Language": {
            "type": "LanguageKind",
            "doc": "<p>  Language, this format style is targeted at.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LK_None</code> (in configuration: <code>None</code>)\nDo not use.</li>\n<li><code>LK_Cpp</code> (in configuration: <code>Cpp</code>)\nShould be used for C, C++, ObjectiveC, ObjectiveC++.</li>\n<li><code>LK_Java</code> (in configuration: <code>Java</code>)\nShould be used for Java.</li>\n<li><code>LK_JavaScript</code> (in configuration: <code>JavaScript</code>)\nShould be used for JavaScript.</li>\n<li><code>LK_Proto</code> (in configuration: <code>Proto</code>)\nShould be used for Protocol Buffers\n(https://developers.google.com/protocol-buffers/).</li>\n</ul>\n",
            "options": [
                "None",
                "Cpp",
                "Java",
                "JavaScript",
                "Proto"
            ]
        },
        "MacroBlockBegin": {
            "type": "std::string",
            "doc": "<p>  A regular expression matching macros that start a block.</p>\n"
        },
        "MacroBlockEnd": {
            "type": "std::string",
            "doc": "<p>  A regular expression matching macros that end a block.</p>\n"
        },
        "MaxEmptyLinesToKeep": {
            "type": "unsigned",
            "doc": "<p>  The maximum number of consecutive empty lines to keep.</p>\n"
        },
        "NamespaceIndentation": {
            "type": "NamespaceIndentationKind",
            "doc": "<p>  The indentation used for namespaces.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>NI_None</code> (in configuration: <code>None</code>)\nDon&#39;t indent in namespaces.</li>\n<li><code>NI_Inner</code> (in configuration: <code>Inner</code>)\nIndent only in inner namespaces (nested in other namespaces).</li>\n<li><code>NI_All</code> (in configuration: <code>All</code>)\nIndent in all namespaces.</li>\n</ul>\n",
            "options": [
                "None",
                "Inner",
                "All"
            ]
        },
        "ObjCBlockIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of ObjC blocks.</p>\n"
        },
        "ObjCSpaceAfterProperty": {
            "type": "bool",
            "doc": "<p>  Add a space after <code>@property</code> in Objective-C, i.e. use\n  <code>\\@property (readonly)</code> instead of <code>\\@property(readonly)</code>.</p>\n"
        },
        "ObjCSpaceBeforeProtocolList": {
            "type": "bool",
            "doc": "<p>  Add a space in front of an Objective-C protocol list, i.e. use\n  <code>Foo &lt;Protocol&gt;</code> instead of <code>Foo&lt;Protocol&gt;</code>.</p>\n"
        },
        "PenaltyBreakBeforeFirstCallParameter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking a function call after &quot;call(&quot;.</p>\n"
        },
        "PenaltyBreakComment": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a comment.</p>\n"
        },
        "PenaltyBreakFirstLessLess": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking before the first <code>&lt;&lt;</code>.</p>\n"
        },
        "PenaltyBreakString": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a string literal.</p>\n"
        },
        "PenaltyExcessCharacter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each character outside of the column limit.</p>\n"
        },
        "PenaltyReturnTypeOnItsOwnLine": {
            "type": "unsigned",
            "doc": "<p>  Penalty for putting the return type of a function onto its own\n  line.</p>\n"
        },
        "PointerAlignment": {
            "type": "PointerAlignmentStyle",
            "doc": "<p>  Pointer and reference alignment style.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>PAS_Left</code> (in configuration: <code>Left</code>)\nAlign pointer to the left.</li>\n<li><code>PAS_Right</code> (in configuration: <code>Right</code>)\nAlign pointer to the right.</li>\n<li><code>PAS_Middle</code> (in configuration: <code>Middle</code>)\nAlign pointer in the middle.</li>\n</ul>\n",
            "options": [
                "Left",
                "Right",
                "Middle"
            ]
        },
        "SpaceAfterCStyleCast": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, a space may be inserted after C style casts.</p>\n"
        },
        "SpaceBeforeAssignmentOperators": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, spaces will be removed before assignment operators.</p>\n"
        },
        "SpaceBeforeParens": {
            "type": "SpaceBeforeParensOptions",
            "doc": "<p>  Defines in which cases to put a space before opening parentheses.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>SBPO_Never</code> (in configuration: <code>Never</code>)\nNever put a space before opening parentheses.</li>\n<li><code>SBPO_ControlStatements</code> (in configuration: <code>ControlStatements</code>)\nPut a space before opening parentheses only after control statement\nkeywords (<code>for/if/while...</code>).</li>\n<li><code>SBPO_Always</code> (in configuration: <code>Always</code>)\nAlways put a space before opening parentheses, except when it&#39;s\nprohibited by the syntax rules (in function-like macro definitions) or\nwhen determined by other style rules (after unary operators, opening\nparentheses, etc.)</li>\n</ul>\n",
            "options": [
                "Never",
                "ControlStatements",
                "Always"
            ]
        },
        "SpaceInEmptyParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into &#39;()&#39;.</p>\n"
        },
        "SpacesBeforeTrailingComments": {
            "type": "unsigned",
            "doc": "<p>  The number of spaces before trailing line comments\n  (<code>//</code> - comments).</p>\n<p>  This does not affect trailing block comments (<code>/**/</code> - comments) as those\n  commonly have different usage patterns and a number of special cases.</p>\n"
        },
        "SpacesInAngles": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after &#39;&lt;&#39; and before &#39;&gt;&#39; in\n  template argument lists</p>\n"
        },
        "SpacesInCStyleCastParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into C style casts.</p>\n"
        },
        "SpacesInContainerLiterals": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces are inserted inside container literals (e.g.\n  ObjC and Javascript array and dict literals).</p>\n"
        },
        "SpacesInParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after &#39;(&#39; and before &#39;)&#39;.</p>\n"
        },
        "SpacesInSquareBrackets": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after &#39;[&#39; and before &#39;]&#39;.</p>\n"
        },
        "Standard": {
            "type": "LanguageStandard",
            "doc": "<p>  Format compatible with this standard, e.g. use\n  <code>A&lt;A&lt;int&gt; &gt;</code> instead of <code>A&lt;A&lt;int&gt;&gt;</code> for LS_Cpp03.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LS_Cpp03</code> (in configuration: <code>Cpp03</code>)\nUse C++03-compatible syntax.</li>\n<li><code>LS_Cpp11</code> (in configuration: <code>Cpp11</code>)\nUse features of C++11 (e.g. <code>A&lt;A&lt;int&gt;&gt;</code> instead of\n<code>A&lt;A&lt;int&gt; &gt;</code>).</li>\n<li><code>LS_Auto</code> (in configuration: <code>Auto</code>)\nAutomatic detection based on the input.</li>\n</ul>\n",
            "options": [
                "Cpp03",
                "Cpp11",
                "Auto"
            ]
        },
        "TabWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns used for tab stops.</p>\n"
        },
        "UseTab": {
            "type": "UseTabStyle",
            "doc": "<p>  The way to use tab characters in the resulting file.</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>UT_Never</code> (in configuration: <code>Never</code>)\nNever use tab.</li>\n<li><code>UT_ForIndentation</code> (in configuration: <code>ForIndentation</code>)\nUse tabs only for indentation.</li>\n<li><code>UT_Always</code> (in configuration: <code>Always</code>)\nUse tabs whenever we need to fill whitespace that spans at least from\none tab stop to the next one.</li>\n</ul>\n",
            "options": [
                "Never",
                "ForIndentation",
                "Always"
            ]
        }
    },
    "3.9.0": {
        "BasedOnStyle": {
            "type": "string",
            "doc": "<p>  The style used for all options not specifically set in the configuration.</p>\n<p>  This option is supported only in the <strong>clang-format</strong> configuration\n  (both within <code>-style=&#39;{...}&#39;</code> and the <code>.clang-format</code> file).</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LLVM</code>\nA style complying with the <a href=\"http://llvm.org/docs/CodingStandards.html\">LLVM coding standards</a></li>\n<li><code>Google</code>\nA style complying with <a href=\"http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml\">Google&#39;s C++ style guide</a></li>\n<li><code>Chromium</code>\nA style complying with <a href=\"http://www.chromium.org/developers/coding-style\">Chromium&#39;s style guide</a></li>\n<li><code>Mozilla</code>\nA style complying with <a href=\"https://developer.mozilla.org/en-US/docs/Developer_Guide/Coding_Style\">Mozilla&#39;s style guide</a></li>\n<li><code>WebKit</code>\nA style complying with <a href=\"http://www.webkit.org/coding/coding-style.html\">WebKit&#39;s style guide</a></li>\n</ul>\n",
            "options": [
                "LLVM",
                "Google",
                "Chromium",
                "Mozilla",
                "WebKit"
            ]
        },
        "AccessModifierOffset": {
            "type": "int",
            "doc": "<p>  The extra indent or outdent of access modifiers, e.g. <code>public:</code>.</p>\n"
        },
        "AlignAfterOpenBracket": {
            "type": "BracketAlignmentStyle",
            "doc": "<p>  If <code>true</code>, horizontally aligns arguments after an open bracket.</p>\n<p>  This applies to round brackets (parentheses), angle brackets and square\n  brackets.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BAS_Align</code> (in configuration: <code>Align</code>)\nAlign parameters on the open bracket, e.g.:</p>\n<pre><code>  someLongFunction(argument1,\n                   argument2);\n</code></pre></li>\n<li><p><code>BAS_DontAlign</code> (in configuration: <code>DontAlign</code>)\nDon&#39;t align, instead use <code>ContinuationIndentWidth</code>, e.g.:</p>\n<pre><code>  someLongFunction(argument1,\n      argument2);\n</code></pre></li>\n<li><p><code>BAS_AlwaysBreak</code> (in configuration: <code>AlwaysBreak</code>)\nAlways break after an open bracket, if the parameters don&#39;t fit\non a single line, e.g.:</p>\n<pre><code>  someLongFunction(\n      argument1, argument2);\n</code></pre></li>\n</ul>\n",
            "options": [
                "Align",
                "DontAlign",
                "AlwaysBreak"
            ]
        },
        "AlignConsecutiveAssignments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns consecutive assignments.</p>\n<p>  This will align the assignment operators of consecutive lines. This\n  will result in formattings like</p>\n<pre><code class=\"lang-  \">    int aaaa = 12;\n    int b    = 23;\n    int ccc  = 23;\n</code></pre>\n"
        },
        "AlignConsecutiveDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns consecutive declarations.</p>\n<p>  This will align the declaration names of consecutive lines. This\n  will result in formattings like</p>\n<pre><code class=\"lang-  \">    int         aaaa = 12;\n    float       b = 23;\n    std::string ccc = 23;\n</code></pre>\n"
        },
        "AlignEscapedNewlinesLeft": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns escaped newlines as far left as possible.\n  Otherwise puts them into the right-most column.</p>\n"
        },
        "AlignOperands": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, horizontally align operands of binary and ternary\n  expressions.</p>\n<p>  Specifically, this aligns operands of a single expression that needs to be\n  split over multiple lines, e.g.:</p>\n<pre><code class=\"lang-  \">    int aaa = bbbbbbbbbbbbbbb +\n              ccccccccccccccc;\n</code></pre>\n"
        },
        "AlignTrailingComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns trailing comments.</p>\n"
        },
        "AllowAllParametersOfDeclarationOnNextLine": {
            "type": "bool",
            "doc": "<p>  Allow putting all parameters of a function declaration onto\n  the next line even if <code>BinPackParameters</code> is <code>false</code>.</p>\n"
        },
        "AllowShortBlocksOnASingleLine": {
            "type": "bool",
            "doc": "<p>  Allows contracting simple braced statements to a single line.</p>\n<p>  E.g., this allows <code>if (a) { return; }</code> to be put on a single line.</p>\n"
        },
        "AllowShortCaseLabelsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, short case labels will be contracted to a single line.</p>\n"
        },
        "AllowShortFunctionsOnASingleLine": {
            "type": "ShortFunctionStyle",
            "doc": "<p>  Dependent on the value, <code>int f() { return 0; }</code> can be put on a\n  single line.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>SFS_None</code> (in configuration: <code>None</code>)\nNever merge functions into a single line.</p>\n</li>\n<li><p><code>SFS_Empty</code> (in configuration: <code>Empty</code>)\nOnly merge empty functions.</p>\n</li>\n<li><p><code>SFS_Inline</code> (in configuration: <code>Inline</code>)\nOnly merge functions defined inside a class. Implies &quot;empty&quot;.</p>\n</li>\n<li><p><code>SFS_All</code> (in configuration: <code>All</code>)\nMerge all functions fitting on a single line.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "Empty",
                "Inline",
                "All"
            ]
        },
        "AllowShortIfStatementsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>if (a) return;</code> can be put on a single line.</p>\n"
        },
        "AllowShortLoopsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>while (true) continue;</code> can be put on a single\n  line.</p>\n"
        },
        "AlwaysBreakAfterDefinitionReturnType": {
            "type": "DefinitionReturnTypeBreakingStyle",
            "doc": "<p>  The function definition return type breaking style to use.  This\n  option is deprecated and is retained for backwards compatibility.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>DRTBS_None</code> (in configuration: <code>None</code>)\nBreak after return type automatically.\n<code>PenaltyReturnTypeOnItsOwnLine</code> is taken into account.</p>\n</li>\n<li><p><code>DRTBS_All</code> (in configuration: <code>All</code>)\nAlways break after the return type.</p>\n</li>\n<li><p><code>DRTBS_TopLevel</code> (in configuration: <code>TopLevel</code>)\nAlways break after the return types of top-level functions.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "All",
                "TopLevel"
            ]
        },
        "AlwaysBreakAfterReturnType": {
            "type": "ReturnTypeBreakingStyle",
            "doc": "<p>  The function declaration return type breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>RTBS_None</code> (in configuration: <code>None</code>)\nBreak after return type automatically.\n<code>PenaltyReturnTypeOnItsOwnLine</code> is taken into account.</p>\n</li>\n<li><p><code>RTBS_All</code> (in configuration: <code>All</code>)\nAlways break after the return type.</p>\n</li>\n<li><p><code>RTBS_TopLevel</code> (in configuration: <code>TopLevel</code>)\nAlways break after the return types of top-level functions.</p>\n</li>\n<li><p><code>RTBS_AllDefinitions</code> (in configuration: <code>AllDefinitions</code>)\nAlways break after the return type of function definitions.</p>\n</li>\n<li><p><code>RTBS_TopLevelDefinitions</code> (in configuration: <code>TopLevelDefinitions</code>)\nAlways break after the return type of top-level definitions.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "All",
                "TopLevel",
                "AllDefinitions",
                "TopLevelDefinitions"
            ]
        },
        "AlwaysBreakBeforeMultilineStrings": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break before multiline string literals.</p>\n<p>  This flag is mean to make cases where there are multiple multiline strings\n  in a file look more consistent. Thus, it will only take effect if wrapping\n  the string at that point leads to it being indented\n  <code>ContinuationIndentWidth</code> spaces from the start of the line.</p>\n"
        },
        "AlwaysBreakTemplateDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break after the <code>template&lt;...&gt;</code> of a template\n  declaration.</p>\n"
        },
        "BinPackArguments": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function call&#39;s arguments will either be all on the\n  same line or will have one line each.</p>\n"
        },
        "BinPackParameters": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function declaration&#39;s or function definition&#39;s\n  parameters will either all be on the same line or will have one line each.</p>\n"
        },
        "BraceWrapping": {
            "type": "BraceWrappingFlags",
            "doc": "<p>  Control of individual brace wrapping cases.</p>\n<p>  If <code>BreakBeforeBraces</code> is set to <code>BS_Custom</code>, use this to specify how\n  each individual brace case should be handled. Otherwise, this is ignored.</p>\n<p>  Nested configuration flags:</p>\n<ul>\n<li><code>bool AfterClass</code> Wrap class definitions.</li>\n<li><code>bool AfterControlStatement</code> Wrap control statements (<code>if</code>/<code>for</code>/<code>while</code>/<code>switch</code>/..).</li>\n<li><code>bool AfterEnum</code> Wrap enum definitions.</li>\n<li><code>bool AfterFunction</code> Wrap function definitions.</li>\n<li><code>bool AfterNamespace</code> Wrap namespace definitions.</li>\n<li><code>bool AfterObjCDeclaration</code> Wrap ObjC definitions (<code>@autoreleasepool</code>, interfaces, ..).</li>\n<li><code>bool AfterStruct</code> Wrap struct definitions.</li>\n<li><code>bool AfterUnion</code> Wrap union definitions.</li>\n<li><code>bool BeforeCatch</code> Wrap before <code>catch</code>.</li>\n<li><code>bool BeforeElse</code> Wrap before <code>else</code>.</li>\n<li><code>bool IndentBraces</code> Indent the wrapped braces themselves.</li>\n</ul>\n",
            "options": [
                "AfterClass",
                "AfterControlStatement",
                "AfterEnum",
                "AfterFunction",
                "AfterNamespace",
                "AfterObjCDeclaration",
                "AfterStruct",
                "AfterUnion",
                "BeforeCatch",
                "BeforeElse",
                "IndentBraces"
            ]
        },
        "BreakAfterJavaFieldAnnotations": {
            "type": "bool",
            "doc": "<p>  Break after each annotation on a field in Java files.</p>\n"
        },
        "BreakBeforeBinaryOperators": {
            "type": "BinaryOperatorStyle",
            "doc": "<p>  The way to wrap binary operators.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BOS_None</code> (in configuration: <code>None</code>)\nBreak after operators.</p>\n</li>\n<li><p><code>BOS_NonAssignment</code> (in configuration: <code>NonAssignment</code>)\nBreak before operators that aren&#39;t assignments.</p>\n</li>\n<li><p><code>BOS_All</code> (in configuration: <code>All</code>)\nBreak before operators.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "NonAssignment",
                "All"
            ]
        },
        "BreakBeforeBraces": {
            "type": "BraceBreakingStyle",
            "doc": "<p>  The brace breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BS_Attach</code> (in configuration: <code>Attach</code>)\nAlways attach braces to surrounding context.</p>\n</li>\n<li><p><code>BS_Linux</code> (in configuration: <code>Linux</code>)\nLike <code>Attach</code>, but break before braces on function, namespace and\nclass definitions.</p>\n</li>\n<li><p><code>BS_Mozilla</code> (in configuration: <code>Mozilla</code>)\nLike <code>Attach</code>, but break before braces on enum, function, and record\ndefinitions.</p>\n</li>\n<li><p><code>BS_Stroustrup</code> (in configuration: <code>Stroustrup</code>)\nLike <code>Attach</code>, but break before function definitions, <code>catch</code>, and\n<code>else</code>.</p>\n</li>\n<li><p><code>BS_Allman</code> (in configuration: <code>Allman</code>)\nAlways break before braces.</p>\n</li>\n<li><p><code>BS_GNU</code> (in configuration: <code>GNU</code>)\nAlways break before braces and add an extra level of indentation to\nbraces of control statements, not to those of class, function\nor other definitions.</p>\n</li>\n<li><p><code>BS_WebKit</code> (in configuration: <code>WebKit</code>)\nLike <code>Attach</code>, but break before functions.</p>\n</li>\n<li><p><code>BS_Custom</code> (in configuration: <code>Custom</code>)\nConfigure each individual brace in `BraceWrapping`.</p>\n</li>\n</ul>\n",
            "options": [
                "Attach",
                "Linux",
                "Mozilla",
                "Stroustrup",
                "Allman",
                "GNU",
                "WebKit",
                "Custom"
            ]
        },
        "BreakBeforeTernaryOperators": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, ternary operators will be placed after line breaks.</p>\n"
        },
        "BreakConstructorInitializersBeforeComma": {
            "type": "bool",
            "doc": "<p>  Always break constructor initializers before commas and align\n  the commas with the colon.</p>\n"
        },
        "BreakStringLiterals": {
            "type": "bool",
            "doc": "<p>  Allow breaking string literals when formatting.</p>\n"
        },
        "ColumnLimit": {
            "type": "unsigned",
            "doc": "<p>  The column limit.</p>\n<p>  A column limit of <code>0</code> means that there is no column limit. In this case,\n  clang-format will respect the input&#39;s line breaking decisions within\n  statements unless they contradict other rules.</p>\n"
        },
        "CommentPragmas": {
            "type": "std::string",
            "doc": "<p>  A regular expression that describes comments with special meaning,\n  which should not be split into lines or otherwise changed.</p>\n"
        },
        "ConstructorInitializerAllOnOneLineOrOnePerLine": {
            "type": "bool",
            "doc": "<p>  If the constructor initializers don&#39;t fit on a line, put each\n  initializer on its own line.</p>\n"
        },
        "ConstructorInitializerIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of constructor\n  initializer lists.</p>\n"
        },
        "ContinuationIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  Indent width for line continuations.</p>\n"
        },
        "Cpp11BracedListStyle": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, format braced lists as best suited for C++11 braced\n  lists.</p>\n<p>  Important differences:</p>\n<ul>\n<li>No spaces inside the braced list.</li>\n<li>No line break before the closing brace.</li>\n<li><p>Indentation with the continuation indent, not with the block indent.</p>\n<p>Fundamentally, C++11 braced lists are formatted exactly like function\ncalls would be formatted in their place. If the braced list follows a name\n(e.g. a type or variable name), clang-format formats as if the <code>{}</code> were\nthe parentheses of a function call with that name. If there is no name,\na zero-length name is assumed.</p>\n</li>\n</ul>\n"
        },
        "DerivePointerAlignment": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, analyze the formatted file for the most common\n  alignment of <code>&amp;</code> and <code>\\*</code>. <code>PointerAlignment</code> is then used only as\n  fallback.</p>\n"
        },
        "DisableFormat": {
            "type": "bool",
            "doc": "<p>  Disables formatting completely.</p>\n"
        },
        "ExperimentalAutoDetectBinPacking": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format detects whether function calls and\n  definitions are formatted with one parameter per line.</p>\n<p>  Each call can be bin-packed, one-per-line or inconclusive. If it is\n  inconclusive, e.g. completely on one line, but a decision needs to be\n  made, clang-format analyzes whether there are other bin-packed cases in\n  the input file and act accordingly.</p>\n<p>  NOTE: This is an experimental flag, that might go away or be renamed. Do\n  not use this in config files, etc. Use at your own risk.</p>\n"
        },
        "ForEachMacros": {
            "type": "std::vector<std::string>",
            "doc": "<p>  A vector of macros that should be interpreted as foreach loops\n  instead of as function calls.</p>\n<p>  These are expected to be macros of the form:</p>\n<pre><code class=\"lang-  \">    FOREACH(&lt;variable-declaration&gt;, ...)\n      &lt;loop-body&gt;\n</code></pre>\n<p>  In the .clang-format configuration file, this can be configured like:</p>\n<pre><code class=\"lang-  \">    ForEachMacros: [&#39;RANGES_FOR&#39;, &#39;FOREACH&#39;]\n</code></pre>\n<p>  For example: BOOST_FOREACH.</p>\n"
        },
        "IncludeCategories": {
            "type": "std::vector<IncludeCategory>",
            "doc": "<p>  Regular expressions denoting the different <code>#include</code> categories\n  used for ordering <code>#includes</code>.</p>\n<p>  These regular expressions are matched against the filename of an include\n  (including the &lt;&gt; or &quot;&quot;) in order. The value belonging to the first\n  matching regular expression is assigned and <code>#includes</code> are sorted first\n  according to increasing category number and then alphabetically within\n  each category.</p>\n<p>  If none of the regular expressions match, INT_MAX is assigned as\n  category. The main header for a source file automatically gets category 0.\n  so that it is generally kept at the beginning of the <code>#includes</code>\n  (http://llvm.org/docs/CodingStandards.html#include-style). However, you\n  can also assign negative priorities if you have certain headers that\n  always need to be first.</p>\n<p>  To configure this in the .clang-format file, use:</p>\n<pre><code class=\"lang-  \">    IncludeCategories:\n      - Regex:           &#39;^&quot;(llvm|llvm-c|clang|clang-c)/&#39;\n        Priority:        2\n      - Regex:           &#39;^(&lt;|&quot;(gtest|isl|json)/)&#39;\n        Priority:        3\n      - Regex:           &#39;.\\*&#39;\n        Priority:        1\n</code></pre>\n",
            "options": []
        },
        "IncludeIsMainRegex": {
            "type": "std::string",
            "doc": "<p>  Specify a regular expression of suffixes that are allowed in the\n  file-to-main-include mapping.</p>\n<p>  When guessing whether a #include is the &quot;main&quot; include (to assign\n  category 0, see above), use this regex of allowed suffixes to the header\n  stem. A partial match is done, so that:</p>\n<ul>\n<li>&quot;&quot; means &quot;arbitrary suffix&quot;</li>\n<li><p>&quot;$&quot; means &quot;no suffix&quot;</p>\n<p>For example, if configured to &quot;(_test)?$&quot;, then a header a.h would be seen\nas the &quot;main&quot; include in both a.cc and a_test.cc.</p>\n</li>\n</ul>\n"
        },
        "IndentCaseLabels": {
            "type": "bool",
            "doc": "<p>  Indent case labels one level from the switch statement.</p>\n<p>  When <code>false</code>, use the same indentation level as for the switch statement.\n  Switch statement body is always indented one level more than case labels.</p>\n"
        },
        "IndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns to use for indentation.</p>\n"
        },
        "IndentWrappedFunctionNames": {
            "type": "bool",
            "doc": "<p>  Indent if a function definition or declaration is wrapped after the\n  type.</p>\n"
        },
        "JavaScriptQuotes": {
            "type": "JavaScriptQuoteStyle",
            "doc": "<p>  The JavaScriptQuoteStyle to use for JavaScript strings.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>JSQS_Leave</code> (in configuration: <code>Leave</code>)\nLeave string quotes as they are.</p>\n</li>\n<li><p><code>JSQS_Single</code> (in configuration: <code>Single</code>)\nAlways use single quotes.</p>\n</li>\n<li><p><code>JSQS_Double</code> (in configuration: <code>Double</code>)\nAlways use double quotes.</p>\n</li>\n</ul>\n",
            "options": [
                "Leave",
                "Single",
                "Double"
            ]
        },
        "KeepEmptyLinesAtTheStartOfBlocks": {
            "type": "bool",
            "doc": "<p>  If true, empty lines at the start of blocks are kept.</p>\n"
        },
        "Language": {
            "type": "LanguageKind",
            "doc": "<p>  Language, this format style is targeted at.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>LK_None</code> (in configuration: <code>None</code>)\nDo not use.</p>\n</li>\n<li><p><code>LK_Cpp</code> (in configuration: <code>Cpp</code>)\nShould be used for C, C++, ObjectiveC, ObjectiveC++.</p>\n</li>\n<li><p><code>LK_Java</code> (in configuration: <code>Java</code>)\nShould be used for Java.</p>\n</li>\n<li><p><code>LK_JavaScript</code> (in configuration: <code>JavaScript</code>)\nShould be used for JavaScript.</p>\n</li>\n<li><p><code>LK_Proto</code> (in configuration: <code>Proto</code>)\nShould be used for Protocol Buffers\n(https://developers.google.com/protocol-buffers/).</p>\n</li>\n<li><p><code>LK_TableGen</code> (in configuration: <code>TableGen</code>)\nShould be used for TableGen code.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "Cpp",
                "Java",
                "JavaScript",
                "Proto",
                "TableGen"
            ]
        },
        "MacroBlockBegin": {
            "type": "std::string",
            "doc": "<p>  A regular expression matching macros that start a block.</p>\n"
        },
        "MacroBlockEnd": {
            "type": "std::string",
            "doc": "<p>  A regular expression matching macros that end a block.</p>\n"
        },
        "MaxEmptyLinesToKeep": {
            "type": "unsigned",
            "doc": "<p>  The maximum number of consecutive empty lines to keep.</p>\n"
        },
        "NamespaceIndentation": {
            "type": "NamespaceIndentationKind",
            "doc": "<p>  The indentation used for namespaces.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>NI_None</code> (in configuration: <code>None</code>)\nDon&#39;t indent in namespaces.</p>\n</li>\n<li><p><code>NI_Inner</code> (in configuration: <code>Inner</code>)\nIndent only in inner namespaces (nested in other namespaces).</p>\n</li>\n<li><p><code>NI_All</code> (in configuration: <code>All</code>)\nIndent in all namespaces.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "Inner",
                "All"
            ]
        },
        "ObjCBlockIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of ObjC blocks.</p>\n"
        },
        "ObjCSpaceAfterProperty": {
            "type": "bool",
            "doc": "<p>  Add a space after <code>@property</code> in Objective-C, i.e. use\n  <code>@property (readonly)</code> instead of <code>@property(readonly)</code>.</p>\n"
        },
        "ObjCSpaceBeforeProtocolList": {
            "type": "bool",
            "doc": "<p>  Add a space in front of an Objective-C protocol list, i.e. use\n  <code>Foo &lt;Protocol&gt;</code> instead of <code>Foo&lt;Protocol&gt;</code>.</p>\n"
        },
        "PenaltyBreakBeforeFirstCallParameter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking a function call after <code>call(</code>.</p>\n"
        },
        "PenaltyBreakComment": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a comment.</p>\n"
        },
        "PenaltyBreakFirstLessLess": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking before the first <code>&lt;&lt;</code>.</p>\n"
        },
        "PenaltyBreakString": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a string literal.</p>\n"
        },
        "PenaltyExcessCharacter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each character outside of the column limit.</p>\n"
        },
        "PenaltyReturnTypeOnItsOwnLine": {
            "type": "unsigned",
            "doc": "<p>  Penalty for putting the return type of a function onto its own\n  line.</p>\n"
        },
        "PointerAlignment": {
            "type": "PointerAlignmentStyle",
            "doc": "<p>  Pointer and reference alignment style.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>PAS_Left</code> (in configuration: <code>Left</code>)\nAlign pointer to the left.</p>\n</li>\n<li><p><code>PAS_Right</code> (in configuration: <code>Right</code>)\nAlign pointer to the right.</p>\n</li>\n<li><p><code>PAS_Middle</code> (in configuration: <code>Middle</code>)\nAlign pointer in the middle.</p>\n</li>\n</ul>\n",
            "options": [
                "Left",
                "Right",
                "Middle"
            ]
        },
        "ReflowComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format will attempt to re-flow comments.</p>\n"
        },
        "SortIncludes": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format will sort <code>#includes</code>.</p>\n"
        },
        "SpaceAfterCStyleCast": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, a space may be inserted after C style casts.</p>\n"
        },
        "SpaceBeforeAssignmentOperators": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, spaces will be removed before assignment operators.</p>\n"
        },
        "SpaceBeforeParens": {
            "type": "SpaceBeforeParensOptions",
            "doc": "<p>  Defines in which cases to put a space before opening parentheses.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>SBPO_Never</code> (in configuration: <code>Never</code>)\nNever put a space before opening parentheses.</p>\n</li>\n<li><p><code>SBPO_ControlStatements</code> (in configuration: <code>ControlStatements</code>)\nPut a space before opening parentheses only after control statement\nkeywords (<code>for/if/while...</code>).</p>\n</li>\n<li><p><code>SBPO_Always</code> (in configuration: <code>Always</code>)\nAlways put a space before opening parentheses, except when it&#39;s\nprohibited by the syntax rules (in function-like macro definitions) or\nwhen determined by other style rules (after unary operators, opening\nparentheses, etc.)</p>\n</li>\n</ul>\n",
            "options": [
                "Never",
                "ControlStatements",
                "Always"
            ]
        },
        "SpaceInEmptyParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into <code>()</code>.</p>\n"
        },
        "SpacesBeforeTrailingComments": {
            "type": "unsigned",
            "doc": "<p>  The number of spaces before trailing line comments\n  (<code>//</code> - comments).</p>\n<p>  This does not affect trailing block comments (<code>/*</code> - comments) as\n  those commonly have different usage patterns and a number of special\n  cases.</p>\n"
        },
        "SpacesInAngles": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>&lt;</code> and before <code>&gt;</code>\n  in template argument lists.</p>\n"
        },
        "SpacesInCStyleCastParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into C style casts.</p>\n"
        },
        "SpacesInContainerLiterals": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces are inserted inside container literals (e.g.\n  ObjC and Javascript array and dict literals).</p>\n"
        },
        "SpacesInParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>(</code> and before <code>)</code>.</p>\n"
        },
        "SpacesInSquareBrackets": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>[</code> and before <code>]</code>.</p>\n"
        },
        "Standard": {
            "type": "LanguageStandard",
            "doc": "<p>  Format compatible with this standard, e.g. use <code>A&lt;A&lt;int&gt; &gt;</code>\n  instead of <code>A&lt;A&lt;int&gt;&gt;</code> for <code>LS_Cpp03</code>.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>LS_Cpp03</code> (in configuration: <code>Cpp03</code>)\nUse C++03-compatible syntax.</p>\n</li>\n<li><p><code>LS_Cpp11</code> (in configuration: <code>Cpp11</code>)\nUse features of C++11 (e.g. <code>A&lt;A&lt;int&gt;&gt;</code> instead of <code>A&lt;A&lt;int&gt; &gt;</code>).</p>\n</li>\n<li><p><code>LS_Auto</code> (in configuration: <code>Auto</code>)\nAutomatic detection based on the input.</p>\n</li>\n</ul>\n",
            "options": [
                "Cpp03",
                "Cpp11",
                "Auto"
            ]
        },
        "TabWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns used for tab stops.</p>\n"
        },
        "UseTab": {
            "type": "UseTabStyle",
            "doc": "<p>  The way to use tab characters in the resulting file.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>UT_Never</code> (in configuration: <code>Never</code>)\nNever use tab.</p>\n</li>\n<li><p><code>UT_ForIndentation</code> (in configuration: <code>ForIndentation</code>)\nUse tabs only for indentation.</p>\n</li>\n<li><p><code>UT_Always</code> (in configuration: <code>Always</code>)\nUse tabs whenever we need to fill whitespace that spans at least from\none tab stop to the next one.</p>\n</li>\n</ul>\n",
            "options": [
                "Never",
                "ForIndentation",
                "Always"
            ]
        }
    },
    "3.9.1": {
        "BasedOnStyle": {
            "type": "string",
            "doc": "<p>  The style used for all options not specifically set in the configuration.</p>\n<p>  This option is supported only in the <strong>clang-format</strong> configuration\n  (both within <code>-style=&#39;{...}&#39;</code> and the <code>.clang-format</code> file).</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LLVM</code>\nA style complying with the <a href=\"http://llvm.org/docs/CodingStandards.html\">LLVM coding standards</a></li>\n<li><code>Google</code>\nA style complying with <a href=\"http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml\">Google&#39;s C++ style guide</a></li>\n<li><code>Chromium</code>\nA style complying with <a href=\"http://www.chromium.org/developers/coding-style\">Chromium&#39;s style guide</a></li>\n<li><code>Mozilla</code>\nA style complying with <a href=\"https://developer.mozilla.org/en-US/docs/Developer_Guide/Coding_Style\">Mozilla&#39;s style guide</a></li>\n<li><code>WebKit</code>\nA style complying with <a href=\"http://www.webkit.org/coding/coding-style.html\">WebKit&#39;s style guide</a></li>\n</ul>\n",
            "options": [
                "LLVM",
                "Google",
                "Chromium",
                "Mozilla",
                "WebKit"
            ]
        },
        "AccessModifierOffset": {
            "type": "int",
            "doc": "<p>  The extra indent or outdent of access modifiers, e.g. <code>public:</code>.</p>\n"
        },
        "AlignAfterOpenBracket": {
            "type": "BracketAlignmentStyle",
            "doc": "<p>  If <code>true</code>, horizontally aligns arguments after an open bracket.</p>\n<p>  This applies to round brackets (parentheses), angle brackets and square\n  brackets.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BAS_Align</code> (in configuration: <code>Align</code>)\nAlign parameters on the open bracket, e.g.:</p>\n<pre><code>  someLongFunction(argument1,\n                   argument2);\n</code></pre></li>\n<li><p><code>BAS_DontAlign</code> (in configuration: <code>DontAlign</code>)\nDon&#39;t align, instead use <code>ContinuationIndentWidth</code>, e.g.:</p>\n<pre><code>  someLongFunction(argument1,\n      argument2);\n</code></pre></li>\n<li><p><code>BAS_AlwaysBreak</code> (in configuration: <code>AlwaysBreak</code>)\nAlways break after an open bracket, if the parameters don&#39;t fit\non a single line, e.g.:</p>\n<pre><code>  someLongFunction(\n      argument1, argument2);\n</code></pre></li>\n</ul>\n",
            "options": [
                "Align",
                "DontAlign",
                "AlwaysBreak"
            ]
        },
        "AlignConsecutiveAssignments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns consecutive assignments.</p>\n<p>  This will align the assignment operators of consecutive lines. This\n  will result in formattings like</p>\n<pre><code class=\"lang-  \">    int aaaa = 12;\n    int b    = 23;\n    int ccc  = 23;\n</code></pre>\n"
        },
        "AlignConsecutiveDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns consecutive declarations.</p>\n<p>  This will align the declaration names of consecutive lines. This\n  will result in formattings like</p>\n<pre><code class=\"lang-  \">    int         aaaa = 12;\n    float       b = 23;\n    std::string ccc = 23;\n</code></pre>\n"
        },
        "AlignEscapedNewlinesLeft": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns escaped newlines as far left as possible.\n  Otherwise puts them into the right-most column.</p>\n"
        },
        "AlignOperands": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, horizontally align operands of binary and ternary\n  expressions.</p>\n<p>  Specifically, this aligns operands of a single expression that needs to be\n  split over multiple lines, e.g.:</p>\n<pre><code class=\"lang-  \">    int aaa = bbbbbbbbbbbbbbb +\n              ccccccccccccccc;\n</code></pre>\n"
        },
        "AlignTrailingComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns trailing comments.</p>\n"
        },
        "AllowAllParametersOfDeclarationOnNextLine": {
            "type": "bool",
            "doc": "<p>  Allow putting all parameters of a function declaration onto\n  the next line even if <code>BinPackParameters</code> is <code>false</code>.</p>\n"
        },
        "AllowShortBlocksOnASingleLine": {
            "type": "bool",
            "doc": "<p>  Allows contracting simple braced statements to a single line.</p>\n<p>  E.g., this allows <code>if (a) { return; }</code> to be put on a single line.</p>\n"
        },
        "AllowShortCaseLabelsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, short case labels will be contracted to a single line.</p>\n"
        },
        "AllowShortFunctionsOnASingleLine": {
            "type": "ShortFunctionStyle",
            "doc": "<p>  Dependent on the value, <code>int f() { return 0; }</code> can be put on a\n  single line.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>SFS_None</code> (in configuration: <code>None</code>)\nNever merge functions into a single line.</p>\n</li>\n<li><p><code>SFS_Empty</code> (in configuration: <code>Empty</code>)\nOnly merge empty functions.</p>\n</li>\n<li><p><code>SFS_Inline</code> (in configuration: <code>Inline</code>)\nOnly merge functions defined inside a class. Implies &quot;empty&quot;.</p>\n</li>\n<li><p><code>SFS_All</code> (in configuration: <code>All</code>)\nMerge all functions fitting on a single line.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "Empty",
                "Inline",
                "All"
            ]
        },
        "AllowShortIfStatementsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>if (a) return;</code> can be put on a single line.</p>\n"
        },
        "AllowShortLoopsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>while (true) continue;</code> can be put on a single\n  line.</p>\n"
        },
        "AlwaysBreakAfterDefinitionReturnType": {
            "type": "DefinitionReturnTypeBreakingStyle",
            "doc": "<p>  The function definition return type breaking style to use.  This\n  option is deprecated and is retained for backwards compatibility.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>DRTBS_None</code> (in configuration: <code>None</code>)\nBreak after return type automatically.\n<code>PenaltyReturnTypeOnItsOwnLine</code> is taken into account.</p>\n</li>\n<li><p><code>DRTBS_All</code> (in configuration: <code>All</code>)\nAlways break after the return type.</p>\n</li>\n<li><p><code>DRTBS_TopLevel</code> (in configuration: <code>TopLevel</code>)\nAlways break after the return types of top-level functions.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "All",
                "TopLevel"
            ]
        },
        "AlwaysBreakAfterReturnType": {
            "type": "ReturnTypeBreakingStyle",
            "doc": "<p>  The function declaration return type breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>RTBS_None</code> (in configuration: <code>None</code>)\nBreak after return type automatically.\n<code>PenaltyReturnTypeOnItsOwnLine</code> is taken into account.</p>\n</li>\n<li><p><code>RTBS_All</code> (in configuration: <code>All</code>)\nAlways break after the return type.</p>\n</li>\n<li><p><code>RTBS_TopLevel</code> (in configuration: <code>TopLevel</code>)\nAlways break after the return types of top-level functions.</p>\n</li>\n<li><p><code>RTBS_AllDefinitions</code> (in configuration: <code>AllDefinitions</code>)\nAlways break after the return type of function definitions.</p>\n</li>\n<li><p><code>RTBS_TopLevelDefinitions</code> (in configuration: <code>TopLevelDefinitions</code>)\nAlways break after the return type of top-level definitions.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "All",
                "TopLevel",
                "AllDefinitions",
                "TopLevelDefinitions"
            ]
        },
        "AlwaysBreakBeforeMultilineStrings": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break before multiline string literals.</p>\n<p>  This flag is mean to make cases where there are multiple multiline strings\n  in a file look more consistent. Thus, it will only take effect if wrapping\n  the string at that point leads to it being indented\n  <code>ContinuationIndentWidth</code> spaces from the start of the line.</p>\n"
        },
        "AlwaysBreakTemplateDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break after the <code>template&lt;...&gt;</code> of a template\n  declaration.</p>\n"
        },
        "BinPackArguments": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function call&#39;s arguments will either be all on the\n  same line or will have one line each.</p>\n"
        },
        "BinPackParameters": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function declaration&#39;s or function definition&#39;s\n  parameters will either all be on the same line or will have one line each.</p>\n"
        },
        "BraceWrapping": {
            "type": "BraceWrappingFlags",
            "doc": "<p>  Control of individual brace wrapping cases.</p>\n<p>  If <code>BreakBeforeBraces</code> is set to <code>BS_Custom</code>, use this to specify how\n  each individual brace case should be handled. Otherwise, this is ignored.</p>\n<p>  Nested configuration flags:</p>\n<ul>\n<li><code>bool AfterClass</code> Wrap class definitions.</li>\n<li><code>bool AfterControlStatement</code> Wrap control statements (<code>if</code>/<code>for</code>/<code>while</code>/<code>switch</code>/..).</li>\n<li><code>bool AfterEnum</code> Wrap enum definitions.</li>\n<li><code>bool AfterFunction</code> Wrap function definitions.</li>\n<li><code>bool AfterNamespace</code> Wrap namespace definitions.</li>\n<li><code>bool AfterObjCDeclaration</code> Wrap ObjC definitions (<code>@autoreleasepool</code>, interfaces, ..).</li>\n<li><code>bool AfterStruct</code> Wrap struct definitions.</li>\n<li><code>bool AfterUnion</code> Wrap union definitions.</li>\n<li><code>bool BeforeCatch</code> Wrap before <code>catch</code>.</li>\n<li><code>bool BeforeElse</code> Wrap before <code>else</code>.</li>\n<li><code>bool IndentBraces</code> Indent the wrapped braces themselves.</li>\n</ul>\n",
            "options": [
                "AfterClass",
                "AfterControlStatement",
                "AfterEnum",
                "AfterFunction",
                "AfterNamespace",
                "AfterObjCDeclaration",
                "AfterStruct",
                "AfterUnion",
                "BeforeCatch",
                "BeforeElse",
                "IndentBraces"
            ]
        },
        "BreakAfterJavaFieldAnnotations": {
            "type": "bool",
            "doc": "<p>  Break after each annotation on a field in Java files.</p>\n"
        },
        "BreakBeforeBinaryOperators": {
            "type": "BinaryOperatorStyle",
            "doc": "<p>  The way to wrap binary operators.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BOS_None</code> (in configuration: <code>None</code>)\nBreak after operators.</p>\n</li>\n<li><p><code>BOS_NonAssignment</code> (in configuration: <code>NonAssignment</code>)\nBreak before operators that aren&#39;t assignments.</p>\n</li>\n<li><p><code>BOS_All</code> (in configuration: <code>All</code>)\nBreak before operators.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "NonAssignment",
                "All"
            ]
        },
        "BreakBeforeBraces": {
            "type": "BraceBreakingStyle",
            "doc": "<p>  The brace breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BS_Attach</code> (in configuration: <code>Attach</code>)\nAlways attach braces to surrounding context.</p>\n</li>\n<li><p><code>BS_Linux</code> (in configuration: <code>Linux</code>)\nLike <code>Attach</code>, but break before braces on function, namespace and\nclass definitions.</p>\n</li>\n<li><p><code>BS_Mozilla</code> (in configuration: <code>Mozilla</code>)\nLike <code>Attach</code>, but break before braces on enum, function, and record\ndefinitions.</p>\n</li>\n<li><p><code>BS_Stroustrup</code> (in configuration: <code>Stroustrup</code>)\nLike <code>Attach</code>, but break before function definitions, <code>catch</code>, and\n<code>else</code>.</p>\n</li>\n<li><p><code>BS_Allman</code> (in configuration: <code>Allman</code>)\nAlways break before braces.</p>\n</li>\n<li><p><code>BS_GNU</code> (in configuration: <code>GNU</code>)\nAlways break before braces and add an extra level of indentation to\nbraces of control statements, not to those of class, function\nor other definitions.</p>\n</li>\n<li><p><code>BS_WebKit</code> (in configuration: <code>WebKit</code>)\nLike <code>Attach</code>, but break before functions.</p>\n</li>\n<li><p><code>BS_Custom</code> (in configuration: <code>Custom</code>)\nConfigure each individual brace in `BraceWrapping`.</p>\n</li>\n</ul>\n",
            "options": [
                "Attach",
                "Linux",
                "Mozilla",
                "Stroustrup",
                "Allman",
                "GNU",
                "WebKit",
                "Custom"
            ]
        },
        "BreakBeforeTernaryOperators": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, ternary operators will be placed after line breaks.</p>\n"
        },
        "BreakConstructorInitializersBeforeComma": {
            "type": "bool",
            "doc": "<p>  Always break constructor initializers before commas and align\n  the commas with the colon.</p>\n"
        },
        "BreakStringLiterals": {
            "type": "bool",
            "doc": "<p>  Allow breaking string literals when formatting.</p>\n"
        },
        "ColumnLimit": {
            "type": "unsigned",
            "doc": "<p>  The column limit.</p>\n<p>  A column limit of <code>0</code> means that there is no column limit. In this case,\n  clang-format will respect the input&#39;s line breaking decisions within\n  statements unless they contradict other rules.</p>\n"
        },
        "CommentPragmas": {
            "type": "std::string",
            "doc": "<p>  A regular expression that describes comments with special meaning,\n  which should not be split into lines or otherwise changed.</p>\n"
        },
        "ConstructorInitializerAllOnOneLineOrOnePerLine": {
            "type": "bool",
            "doc": "<p>  If the constructor initializers don&#39;t fit on a line, put each\n  initializer on its own line.</p>\n"
        },
        "ConstructorInitializerIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of constructor\n  initializer lists.</p>\n"
        },
        "ContinuationIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  Indent width for line continuations.</p>\n"
        },
        "Cpp11BracedListStyle": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, format braced lists as best suited for C++11 braced\n  lists.</p>\n<p>  Important differences:</p>\n<ul>\n<li>No spaces inside the braced list.</li>\n<li>No line break before the closing brace.</li>\n<li><p>Indentation with the continuation indent, not with the block indent.</p>\n<p>Fundamentally, C++11 braced lists are formatted exactly like function\ncalls would be formatted in their place. If the braced list follows a name\n(e.g. a type or variable name), clang-format formats as if the <code>{}</code> were\nthe parentheses of a function call with that name. If there is no name,\na zero-length name is assumed.</p>\n</li>\n</ul>\n"
        },
        "DerivePointerAlignment": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, analyze the formatted file for the most common\n  alignment of <code>&amp;</code> and <code>\\*</code>. <code>PointerAlignment</code> is then used only as\n  fallback.</p>\n"
        },
        "DisableFormat": {
            "type": "bool",
            "doc": "<p>  Disables formatting completely.</p>\n"
        },
        "ExperimentalAutoDetectBinPacking": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format detects whether function calls and\n  definitions are formatted with one parameter per line.</p>\n<p>  Each call can be bin-packed, one-per-line or inconclusive. If it is\n  inconclusive, e.g. completely on one line, but a decision needs to be\n  made, clang-format analyzes whether there are other bin-packed cases in\n  the input file and act accordingly.</p>\n<p>  NOTE: This is an experimental flag, that might go away or be renamed. Do\n  not use this in config files, etc. Use at your own risk.</p>\n"
        },
        "ForEachMacros": {
            "type": "std::vector<std::string>",
            "doc": "<p>  A vector of macros that should be interpreted as foreach loops\n  instead of as function calls.</p>\n<p>  These are expected to be macros of the form:</p>\n<pre><code class=\"lang-  \">    FOREACH(&lt;variable-declaration&gt;, ...)\n      &lt;loop-body&gt;\n</code></pre>\n<p>  In the .clang-format configuration file, this can be configured like:</p>\n<pre><code class=\"lang-  \">    ForEachMacros: [&#39;RANGES_FOR&#39;, &#39;FOREACH&#39;]\n</code></pre>\n<p>  For example: BOOST_FOREACH.</p>\n"
        },
        "IncludeCategories": {
            "type": "std::vector<IncludeCategory>",
            "doc": "<p>  Regular expressions denoting the different <code>#include</code> categories\n  used for ordering <code>#includes</code>.</p>\n<p>  These regular expressions are matched against the filename of an include\n  (including the &lt;&gt; or &quot;&quot;) in order. The value belonging to the first\n  matching regular expression is assigned and <code>#includes</code> are sorted first\n  according to increasing category number and then alphabetically within\n  each category.</p>\n<p>  If none of the regular expressions match, INT_MAX is assigned as\n  category. The main header for a source file automatically gets category 0.\n  so that it is generally kept at the beginning of the <code>#includes</code>\n  (http://llvm.org/docs/CodingStandards.html#include-style). However, you\n  can also assign negative priorities if you have certain headers that\n  always need to be first.</p>\n<p>  To configure this in the .clang-format file, use:</p>\n<pre><code class=\"lang-  \">    IncludeCategories:\n      - Regex:           &#39;^&quot;(llvm|llvm-c|clang|clang-c)/&#39;\n        Priority:        2\n      - Regex:           &#39;^(&lt;|&quot;(gtest|isl|json)/)&#39;\n        Priority:        3\n      - Regex:           &#39;.\\*&#39;\n        Priority:        1\n</code></pre>\n",
            "options": []
        },
        "IncludeIsMainRegex": {
            "type": "std::string",
            "doc": "<p>  Specify a regular expression of suffixes that are allowed in the\n  file-to-main-include mapping.</p>\n<p>  When guessing whether a #include is the &quot;main&quot; include (to assign\n  category 0, see above), use this regex of allowed suffixes to the header\n  stem. A partial match is done, so that:</p>\n<ul>\n<li>&quot;&quot; means &quot;arbitrary suffix&quot;</li>\n<li><p>&quot;$&quot; means &quot;no suffix&quot;</p>\n<p>For example, if configured to &quot;(_test)?$&quot;, then a header a.h would be seen\nas the &quot;main&quot; include in both a.cc and a_test.cc.</p>\n</li>\n</ul>\n"
        },
        "IndentCaseLabels": {
            "type": "bool",
            "doc": "<p>  Indent case labels one level from the switch statement.</p>\n<p>  When <code>false</code>, use the same indentation level as for the switch statement.\n  Switch statement body is always indented one level more than case labels.</p>\n"
        },
        "IndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns to use for indentation.</p>\n"
        },
        "IndentWrappedFunctionNames": {
            "type": "bool",
            "doc": "<p>  Indent if a function definition or declaration is wrapped after the\n  type.</p>\n"
        },
        "JavaScriptQuotes": {
            "type": "JavaScriptQuoteStyle",
            "doc": "<p>  The JavaScriptQuoteStyle to use for JavaScript strings.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>JSQS_Leave</code> (in configuration: <code>Leave</code>)\nLeave string quotes as they are.</p>\n</li>\n<li><p><code>JSQS_Single</code> (in configuration: <code>Single</code>)\nAlways use single quotes.</p>\n</li>\n<li><p><code>JSQS_Double</code> (in configuration: <code>Double</code>)\nAlways use double quotes.</p>\n</li>\n</ul>\n",
            "options": [
                "Leave",
                "Single",
                "Double"
            ]
        },
        "KeepEmptyLinesAtTheStartOfBlocks": {
            "type": "bool",
            "doc": "<p>  If true, empty lines at the start of blocks are kept.</p>\n"
        },
        "Language": {
            "type": "LanguageKind",
            "doc": "<p>  Language, this format style is targeted at.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>LK_None</code> (in configuration: <code>None</code>)\nDo not use.</p>\n</li>\n<li><p><code>LK_Cpp</code> (in configuration: <code>Cpp</code>)\nShould be used for C, C++, ObjectiveC, ObjectiveC++.</p>\n</li>\n<li><p><code>LK_Java</code> (in configuration: <code>Java</code>)\nShould be used for Java.</p>\n</li>\n<li><p><code>LK_JavaScript</code> (in configuration: <code>JavaScript</code>)\nShould be used for JavaScript.</p>\n</li>\n<li><p><code>LK_Proto</code> (in configuration: <code>Proto</code>)\nShould be used for Protocol Buffers\n(https://developers.google.com/protocol-buffers/).</p>\n</li>\n<li><p><code>LK_TableGen</code> (in configuration: <code>TableGen</code>)\nShould be used for TableGen code.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "Cpp",
                "Java",
                "JavaScript",
                "Proto",
                "TableGen"
            ]
        },
        "MacroBlockBegin": {
            "type": "std::string",
            "doc": "<p>  A regular expression matching macros that start a block.</p>\n"
        },
        "MacroBlockEnd": {
            "type": "std::string",
            "doc": "<p>  A regular expression matching macros that end a block.</p>\n"
        },
        "MaxEmptyLinesToKeep": {
            "type": "unsigned",
            "doc": "<p>  The maximum number of consecutive empty lines to keep.</p>\n"
        },
        "NamespaceIndentation": {
            "type": "NamespaceIndentationKind",
            "doc": "<p>  The indentation used for namespaces.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>NI_None</code> (in configuration: <code>None</code>)\nDon&#39;t indent in namespaces.</p>\n</li>\n<li><p><code>NI_Inner</code> (in configuration: <code>Inner</code>)\nIndent only in inner namespaces (nested in other namespaces).</p>\n</li>\n<li><p><code>NI_All</code> (in configuration: <code>All</code>)\nIndent in all namespaces.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "Inner",
                "All"
            ]
        },
        "ObjCBlockIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of ObjC blocks.</p>\n"
        },
        "ObjCSpaceAfterProperty": {
            "type": "bool",
            "doc": "<p>  Add a space after <code>@property</code> in Objective-C, i.e. use\n  <code>@property (readonly)</code> instead of <code>@property(readonly)</code>.</p>\n"
        },
        "ObjCSpaceBeforeProtocolList": {
            "type": "bool",
            "doc": "<p>  Add a space in front of an Objective-C protocol list, i.e. use\n  <code>Foo &lt;Protocol&gt;</code> instead of <code>Foo&lt;Protocol&gt;</code>.</p>\n"
        },
        "PenaltyBreakBeforeFirstCallParameter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking a function call after <code>call(</code>.</p>\n"
        },
        "PenaltyBreakComment": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a comment.</p>\n"
        },
        "PenaltyBreakFirstLessLess": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking before the first <code>&lt;&lt;</code>.</p>\n"
        },
        "PenaltyBreakString": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a string literal.</p>\n"
        },
        "PenaltyExcessCharacter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each character outside of the column limit.</p>\n"
        },
        "PenaltyReturnTypeOnItsOwnLine": {
            "type": "unsigned",
            "doc": "<p>  Penalty for putting the return type of a function onto its own\n  line.</p>\n"
        },
        "PointerAlignment": {
            "type": "PointerAlignmentStyle",
            "doc": "<p>  Pointer and reference alignment style.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>PAS_Left</code> (in configuration: <code>Left</code>)\nAlign pointer to the left.</p>\n</li>\n<li><p><code>PAS_Right</code> (in configuration: <code>Right</code>)\nAlign pointer to the right.</p>\n</li>\n<li><p><code>PAS_Middle</code> (in configuration: <code>Middle</code>)\nAlign pointer in the middle.</p>\n</li>\n</ul>\n",
            "options": [
                "Left",
                "Right",
                "Middle"
            ]
        },
        "ReflowComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format will attempt to re-flow comments.</p>\n"
        },
        "SortIncludes": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format will sort <code>#includes</code>.</p>\n"
        },
        "SpaceAfterCStyleCast": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, a space may be inserted after C style casts.</p>\n"
        },
        "SpaceBeforeAssignmentOperators": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, spaces will be removed before assignment operators.</p>\n"
        },
        "SpaceBeforeParens": {
            "type": "SpaceBeforeParensOptions",
            "doc": "<p>  Defines in which cases to put a space before opening parentheses.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>SBPO_Never</code> (in configuration: <code>Never</code>)\nNever put a space before opening parentheses.</p>\n</li>\n<li><p><code>SBPO_ControlStatements</code> (in configuration: <code>ControlStatements</code>)\nPut a space before opening parentheses only after control statement\nkeywords (<code>for/if/while...</code>).</p>\n</li>\n<li><p><code>SBPO_Always</code> (in configuration: <code>Always</code>)\nAlways put a space before opening parentheses, except when it&#39;s\nprohibited by the syntax rules (in function-like macro definitions) or\nwhen determined by other style rules (after unary operators, opening\nparentheses, etc.)</p>\n</li>\n</ul>\n",
            "options": [
                "Never",
                "ControlStatements",
                "Always"
            ]
        },
        "SpaceInEmptyParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into <code>()</code>.</p>\n"
        },
        "SpacesBeforeTrailingComments": {
            "type": "unsigned",
            "doc": "<p>  The number of spaces before trailing line comments\n  (<code>//</code> - comments).</p>\n<p>  This does not affect trailing block comments (<code>/*</code> - comments) as\n  those commonly have different usage patterns and a number of special\n  cases.</p>\n"
        },
        "SpacesInAngles": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>&lt;</code> and before <code>&gt;</code>\n  in template argument lists.</p>\n"
        },
        "SpacesInCStyleCastParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into C style casts.</p>\n"
        },
        "SpacesInContainerLiterals": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces are inserted inside container literals (e.g.\n  ObjC and Javascript array and dict literals).</p>\n"
        },
        "SpacesInParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>(</code> and before <code>)</code>.</p>\n"
        },
        "SpacesInSquareBrackets": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>[</code> and before <code>]</code>.</p>\n"
        },
        "Standard": {
            "type": "LanguageStandard",
            "doc": "<p>  Format compatible with this standard, e.g. use <code>A&lt;A&lt;int&gt; &gt;</code>\n  instead of <code>A&lt;A&lt;int&gt;&gt;</code> for <code>LS_Cpp03</code>.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>LS_Cpp03</code> (in configuration: <code>Cpp03</code>)\nUse C++03-compatible syntax.</p>\n</li>\n<li><p><code>LS_Cpp11</code> (in configuration: <code>Cpp11</code>)\nUse features of C++11 (e.g. <code>A&lt;A&lt;int&gt;&gt;</code> instead of <code>A&lt;A&lt;int&gt; &gt;</code>).</p>\n</li>\n<li><p><code>LS_Auto</code> (in configuration: <code>Auto</code>)\nAutomatic detection based on the input.</p>\n</li>\n</ul>\n",
            "options": [
                "Cpp03",
                "Cpp11",
                "Auto"
            ]
        },
        "TabWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns used for tab stops.</p>\n"
        },
        "UseTab": {
            "type": "UseTabStyle",
            "doc": "<p>  The way to use tab characters in the resulting file.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>UT_Never</code> (in configuration: <code>Never</code>)\nNever use tab.</p>\n</li>\n<li><p><code>UT_ForIndentation</code> (in configuration: <code>ForIndentation</code>)\nUse tabs only for indentation.</p>\n</li>\n<li><p><code>UT_Always</code> (in configuration: <code>Always</code>)\nUse tabs whenever we need to fill whitespace that spans at least from\none tab stop to the next one.</p>\n</li>\n</ul>\n",
            "options": [
                "Never",
                "ForIndentation",
                "Always"
            ]
        }
    },
    "4.0.0": {
        "BasedOnStyle": {
            "type": "string",
            "doc": "<p>  The style used for all options not specifically set in the configuration.</p>\n<p>  This option is supported only in the <strong>clang-format</strong> configuration\n  (both within <code>-style=&#39;{...}&#39;</code> and the <code>.clang-format</code> file).</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LLVM</code>\nA style complying with the <a href=\"http://llvm.org/docs/CodingStandards.html\">LLVM coding standards</a></li>\n<li><code>Google</code>\nA style complying with <a href=\"http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml\">Google&#39;s C++ style guide</a></li>\n<li><code>Chromium</code>\nA style complying with <a href=\"http://www.chromium.org/developers/coding-style\">Chromium&#39;s style guide</a></li>\n<li><code>Mozilla</code>\nA style complying with <a href=\"https://developer.mozilla.org/en-US/docs/Developer_Guide/Coding_Style\">Mozilla&#39;s style guide</a></li>\n<li><code>WebKit</code>\nA style complying with <a href=\"http://www.webkit.org/coding/coding-style.html\">WebKit&#39;s style guide</a></li>\n</ul>\n",
            "options": [
                "LLVM",
                "Google",
                "Chromium",
                "Mozilla",
                "WebKit"
            ]
        },
        "AccessModifierOffset": {
            "type": "int",
            "doc": "<p>  The extra indent or outdent of access modifiers, e.g. <code>public:</code>.</p>\n"
        },
        "AlignAfterOpenBracket": {
            "type": "BracketAlignmentStyle",
            "doc": "<p>  If <code>true</code>, horizontally aligns arguments after an open bracket.</p>\n<p>  This applies to round brackets (parentheses), angle brackets and square\n  brackets.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BAS_Align</code> (in configuration: <code>Align</code>)\nAlign parameters on the open bracket, e.g.:</p>\n<pre><code>  someLongFunction(argument1,\n                   argument2);\n</code></pre></li>\n<li><p><code>BAS_DontAlign</code> (in configuration: <code>DontAlign</code>)\nDon&#39;t align, instead use <code>ContinuationIndentWidth</code>, e.g.:</p>\n<pre><code>  someLongFunction(argument1,\n      argument2);\n</code></pre></li>\n<li><p><code>BAS_AlwaysBreak</code> (in configuration: <code>AlwaysBreak</code>)\nAlways break after an open bracket, if the parameters don&#39;t fit\non a single line, e.g.:</p>\n<pre><code>  someLongFunction(\n      argument1, argument2);\n</code></pre></li>\n</ul>\n",
            "options": [
                "Align",
                "DontAlign",
                "AlwaysBreak"
            ]
        },
        "AlignConsecutiveAssignments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns consecutive assignments.</p>\n<p>  This will align the assignment operators of consecutive lines. This\n  will result in formattings like</p>\n<pre><code class=\"lang-  \">    int aaaa = 12;\n    int b    = 23;\n    int ccc  = 23;\n</code></pre>\n"
        },
        "AlignConsecutiveDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns consecutive declarations.</p>\n<p>  This will align the declaration names of consecutive lines. This\n  will result in formattings like</p>\n<pre><code class=\"lang-  \">    int         aaaa = 12;\n    float       b = 23;\n    std::string ccc = 23;\n</code></pre>\n"
        },
        "AlignEscapedNewlinesLeft": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns escaped newlines as far left as possible.\n  Otherwise puts them into the right-most column.</p>\n"
        },
        "AlignOperands": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, horizontally align operands of binary and ternary\n  expressions.</p>\n<p>  Specifically, this aligns operands of a single expression that needs to be\n  split over multiple lines, e.g.:</p>\n<pre><code class=\"lang-  \">    int aaa = bbbbbbbbbbbbbbb +\n              ccccccccccccccc;\n</code></pre>\n"
        },
        "AlignTrailingComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns trailing comments.</p>\n"
        },
        "AllowAllParametersOfDeclarationOnNextLine": {
            "type": "bool",
            "doc": "<p>  Allow putting all parameters of a function declaration onto\n  the next line even if <code>BinPackParameters</code> is <code>false</code>.</p>\n"
        },
        "AllowShortBlocksOnASingleLine": {
            "type": "bool",
            "doc": "<p>  Allows contracting simple braced statements to a single line.</p>\n<p>  E.g., this allows <code>if (a) { return; }</code> to be put on a single line.</p>\n"
        },
        "AllowShortCaseLabelsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, short case labels will be contracted to a single line.</p>\n"
        },
        "AllowShortFunctionsOnASingleLine": {
            "type": "ShortFunctionStyle",
            "doc": "<p>  Dependent on the value, <code>int f() { return 0; }</code> can be put on a\n  single line.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>SFS_None</code> (in configuration: <code>None</code>)\nNever merge functions into a single line.</p>\n</li>\n<li><p><code>SFS_Empty</code> (in configuration: <code>Empty</code>)\nOnly merge empty functions.</p>\n</li>\n<li><p><code>SFS_Inline</code> (in configuration: <code>Inline</code>)\nOnly merge functions defined inside a class. Implies &quot;empty&quot;.</p>\n</li>\n<li><p><code>SFS_All</code> (in configuration: <code>All</code>)\nMerge all functions fitting on a single line.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "Empty",
                "Inline",
                "All"
            ]
        },
        "AllowShortIfStatementsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>if (a) return;</code> can be put on a single line.</p>\n"
        },
        "AllowShortLoopsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>while (true) continue;</code> can be put on a single\n  line.</p>\n"
        },
        "AlwaysBreakAfterDefinitionReturnType": {
            "type": "DefinitionReturnTypeBreakingStyle",
            "doc": "<p>  The function definition return type breaking style to use.  This\n  option is deprecated and is retained for backwards compatibility.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>DRTBS_None</code> (in configuration: <code>None</code>)\nBreak after return type automatically.\n<code>PenaltyReturnTypeOnItsOwnLine</code> is taken into account.</p>\n</li>\n<li><p><code>DRTBS_All</code> (in configuration: <code>All</code>)\nAlways break after the return type.</p>\n</li>\n<li><p><code>DRTBS_TopLevel</code> (in configuration: <code>TopLevel</code>)\nAlways break after the return types of top-level functions.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "All",
                "TopLevel"
            ]
        },
        "AlwaysBreakAfterReturnType": {
            "type": "ReturnTypeBreakingStyle",
            "doc": "<p>  The function declaration return type breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>RTBS_None</code> (in configuration: <code>None</code>)\nBreak after return type automatically.\n<code>PenaltyReturnTypeOnItsOwnLine</code> is taken into account.</p>\n</li>\n<li><p><code>RTBS_All</code> (in configuration: <code>All</code>)\nAlways break after the return type.</p>\n</li>\n<li><p><code>RTBS_TopLevel</code> (in configuration: <code>TopLevel</code>)\nAlways break after the return types of top-level functions.</p>\n</li>\n<li><p><code>RTBS_AllDefinitions</code> (in configuration: <code>AllDefinitions</code>)\nAlways break after the return type of function definitions.</p>\n</li>\n<li><p><code>RTBS_TopLevelDefinitions</code> (in configuration: <code>TopLevelDefinitions</code>)\nAlways break after the return type of top-level definitions.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "All",
                "TopLevel",
                "AllDefinitions",
                "TopLevelDefinitions"
            ]
        },
        "AlwaysBreakBeforeMultilineStrings": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break before multiline string literals.</p>\n<p>  This flag is mean to make cases where there are multiple multiline strings\n  in a file look more consistent. Thus, it will only take effect if wrapping\n  the string at that point leads to it being indented\n  <code>ContinuationIndentWidth</code> spaces from the start of the line.</p>\n"
        },
        "AlwaysBreakTemplateDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break after the <code>template&lt;...&gt;</code> of a template\n  declaration.</p>\n"
        },
        "BinPackArguments": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function call&#39;s arguments will either be all on the\n  same line or will have one line each.</p>\n"
        },
        "BinPackParameters": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function declaration&#39;s or function definition&#39;s\n  parameters will either all be on the same line or will have one line each.</p>\n"
        },
        "BraceWrapping": {
            "type": "BraceWrappingFlags",
            "doc": "<p>  Control of individual brace wrapping cases.</p>\n<p>  If <code>BreakBeforeBraces</code> is set to <code>BS_Custom</code>, use this to specify how\n  each individual brace case should be handled. Otherwise, this is ignored.</p>\n<p>  Nested configuration flags:</p>\n<ul>\n<li><code>bool AfterClass</code> Wrap class definitions.</li>\n<li><code>bool AfterControlStatement</code> Wrap control statements (<code>if</code>/<code>for</code>/<code>while</code>/<code>switch</code>/..).</li>\n<li><code>bool AfterEnum</code> Wrap enum definitions.</li>\n<li><code>bool AfterFunction</code> Wrap function definitions.</li>\n<li><code>bool AfterNamespace</code> Wrap namespace definitions.</li>\n<li><code>bool AfterObjCDeclaration</code> Wrap ObjC definitions (<code>@autoreleasepool</code>, interfaces, ..).</li>\n<li><code>bool AfterStruct</code> Wrap struct definitions.</li>\n<li><code>bool AfterUnion</code> Wrap union definitions.</li>\n<li><code>bool BeforeCatch</code> Wrap before <code>catch</code>.</li>\n<li><code>bool BeforeElse</code> Wrap before <code>else</code>.</li>\n<li><code>bool IndentBraces</code> Indent the wrapped braces themselves.</li>\n</ul>\n",
            "options": [
                "AfterClass",
                "AfterControlStatement",
                "AfterEnum",
                "AfterFunction",
                "AfterNamespace",
                "AfterObjCDeclaration",
                "AfterStruct",
                "AfterUnion",
                "BeforeCatch",
                "BeforeElse",
                "IndentBraces"
            ]
        },
        "BreakAfterJavaFieldAnnotations": {
            "type": "bool",
            "doc": "<p>  Break after each annotation on a field in Java files.</p>\n"
        },
        "BreakBeforeBinaryOperators": {
            "type": "BinaryOperatorStyle",
            "doc": "<p>  The way to wrap binary operators.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BOS_None</code> (in configuration: <code>None</code>)\nBreak after operators.</p>\n</li>\n<li><p><code>BOS_NonAssignment</code> (in configuration: <code>NonAssignment</code>)\nBreak before operators that aren&#39;t assignments.</p>\n</li>\n<li><p><code>BOS_All</code> (in configuration: <code>All</code>)\nBreak before operators.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "NonAssignment",
                "All"
            ]
        },
        "BreakBeforeBraces": {
            "type": "BraceBreakingStyle",
            "doc": "<p>  The brace breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BS_Attach</code> (in configuration: <code>Attach</code>)\nAlways attach braces to surrounding context.</p>\n</li>\n<li><p><code>BS_Linux</code> (in configuration: <code>Linux</code>)\nLike <code>Attach</code>, but break before braces on function, namespace and\nclass definitions.</p>\n</li>\n<li><p><code>BS_Mozilla</code> (in configuration: <code>Mozilla</code>)\nLike <code>Attach</code>, but break before braces on enum, function, and record\ndefinitions.</p>\n</li>\n<li><p><code>BS_Stroustrup</code> (in configuration: <code>Stroustrup</code>)\nLike <code>Attach</code>, but break before function definitions, <code>catch</code>, and\n<code>else</code>.</p>\n</li>\n<li><p><code>BS_Allman</code> (in configuration: <code>Allman</code>)\nAlways break before braces.</p>\n</li>\n<li><p><code>BS_GNU</code> (in configuration: <code>GNU</code>)\nAlways break before braces and add an extra level of indentation to\nbraces of control statements, not to those of class, function\nor other definitions.</p>\n</li>\n<li><p><code>BS_WebKit</code> (in configuration: <code>WebKit</code>)\nLike <code>Attach</code>, but break before functions.</p>\n</li>\n<li><p><code>BS_Custom</code> (in configuration: <code>Custom</code>)\nConfigure each individual brace in `BraceWrapping`.</p>\n</li>\n</ul>\n",
            "options": [
                "Attach",
                "Linux",
                "Mozilla",
                "Stroustrup",
                "Allman",
                "GNU",
                "WebKit",
                "Custom"
            ]
        },
        "BreakBeforeTernaryOperators": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, ternary operators will be placed after line breaks.</p>\n"
        },
        "BreakConstructorInitializersBeforeComma": {
            "type": "bool",
            "doc": "<p>  Always break constructor initializers before commas and align\n  the commas with the colon.</p>\n"
        },
        "BreakStringLiterals": {
            "type": "bool",
            "doc": "<p>  Allow breaking string literals when formatting.</p>\n"
        },
        "ColumnLimit": {
            "type": "unsigned",
            "doc": "<p>  The column limit.</p>\n<p>  A column limit of <code>0</code> means that there is no column limit. In this case,\n  clang-format will respect the input&#39;s line breaking decisions within\n  statements unless they contradict other rules.</p>\n"
        },
        "CommentPragmas": {
            "type": "std::string",
            "doc": "<p>  A regular expression that describes comments with special meaning,\n  which should not be split into lines or otherwise changed.</p>\n"
        },
        "ConstructorInitializerAllOnOneLineOrOnePerLine": {
            "type": "bool",
            "doc": "<p>  If the constructor initializers don&#39;t fit on a line, put each\n  initializer on its own line.</p>\n"
        },
        "ConstructorInitializerIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of constructor\n  initializer lists.</p>\n"
        },
        "ContinuationIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  Indent width for line continuations.</p>\n"
        },
        "Cpp11BracedListStyle": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, format braced lists as best suited for C++11 braced\n  lists.</p>\n<p>  Important differences:</p>\n<ul>\n<li>No spaces inside the braced list.</li>\n<li>No line break before the closing brace.</li>\n<li><p>Indentation with the continuation indent, not with the block indent.</p>\n<p>Fundamentally, C++11 braced lists are formatted exactly like function\ncalls would be formatted in their place. If the braced list follows a name\n(e.g. a type or variable name), clang-format formats as if the <code>{}</code> were\nthe parentheses of a function call with that name. If there is no name,\na zero-length name is assumed.</p>\n</li>\n</ul>\n"
        },
        "DerivePointerAlignment": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, analyze the formatted file for the most common\n  alignment of <code>&amp;</code> and <code>\\*</code>. <code>PointerAlignment</code> is then used only as\n  fallback.</p>\n"
        },
        "DisableFormat": {
            "type": "bool",
            "doc": "<p>  Disables formatting completely.</p>\n"
        },
        "ExperimentalAutoDetectBinPacking": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format detects whether function calls and\n  definitions are formatted with one parameter per line.</p>\n<p>  Each call can be bin-packed, one-per-line or inconclusive. If it is\n  inconclusive, e.g. completely on one line, but a decision needs to be\n  made, clang-format analyzes whether there are other bin-packed cases in\n  the input file and act accordingly.</p>\n<p>  NOTE: This is an experimental flag, that might go away or be renamed. Do\n  not use this in config files, etc. Use at your own risk.</p>\n"
        },
        "ForEachMacros": {
            "type": "std::vector<std::string>",
            "doc": "<p>  A vector of macros that should be interpreted as foreach loops\n  instead of as function calls.</p>\n<p>  These are expected to be macros of the form:</p>\n<pre><code class=\"lang-  \">    FOREACH(&lt;variable-declaration&gt;, ...)\n      &lt;loop-body&gt;\n</code></pre>\n<p>  In the .clang-format configuration file, this can be configured like:</p>\n<pre><code class=\"lang-  \">    ForEachMacros: [&#39;RANGES_FOR&#39;, &#39;FOREACH&#39;]\n</code></pre>\n<p>  For example: BOOST_FOREACH.</p>\n"
        },
        "IncludeCategories": {
            "type": "std::vector<IncludeCategory>",
            "doc": "<p>  Regular expressions denoting the different <code>#include</code> categories\n  used for ordering <code>#includes</code>.</p>\n<p>  These regular expressions are matched against the filename of an include\n  (including the &lt;&gt; or &quot;&quot;) in order. The value belonging to the first\n  matching regular expression is assigned and <code>#includes</code> are sorted first\n  according to increasing category number and then alphabetically within\n  each category.</p>\n<p>  If none of the regular expressions match, INT_MAX is assigned as\n  category. The main header for a source file automatically gets category 0.\n  so that it is generally kept at the beginning of the <code>#includes</code>\n  (http://llvm.org/docs/CodingStandards.html#include-style). However, you\n  can also assign negative priorities if you have certain headers that\n  always need to be first.</p>\n<p>  To configure this in the .clang-format file, use:</p>\n<pre><code class=\"lang-  \">    IncludeCategories:\n      - Regex:           &#39;^&quot;(llvm|llvm-c|clang|clang-c)/&#39;\n        Priority:        2\n      - Regex:           &#39;^(&lt;|&quot;(gtest|isl|json)/)&#39;\n        Priority:        3\n      - Regex:           &#39;.\\*&#39;\n        Priority:        1\n</code></pre>\n",
            "options": []
        },
        "IncludeIsMainRegex": {
            "type": "std::string",
            "doc": "<p>  Specify a regular expression of suffixes that are allowed in the\n  file-to-main-include mapping.</p>\n<p>  When guessing whether a #include is the &quot;main&quot; include (to assign\n  category 0, see above), use this regex of allowed suffixes to the header\n  stem. A partial match is done, so that:</p>\n<ul>\n<li>&quot;&quot; means &quot;arbitrary suffix&quot;</li>\n<li><p>&quot;$&quot; means &quot;no suffix&quot;</p>\n<p>For example, if configured to &quot;(_test)?$&quot;, then a header a.h would be seen\nas the &quot;main&quot; include in both a.cc and a_test.cc.</p>\n</li>\n</ul>\n"
        },
        "IndentCaseLabels": {
            "type": "bool",
            "doc": "<p>  Indent case labels one level from the switch statement.</p>\n<p>  When <code>false</code>, use the same indentation level as for the switch statement.\n  Switch statement body is always indented one level more than case labels.</p>\n"
        },
        "IndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns to use for indentation.</p>\n"
        },
        "IndentWrappedFunctionNames": {
            "type": "bool",
            "doc": "<p>  Indent if a function definition or declaration is wrapped after the\n  type.</p>\n"
        },
        "JavaScriptQuotes": {
            "type": "JavaScriptQuoteStyle",
            "doc": "<p>  The JavaScriptQuoteStyle to use for JavaScript strings.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>JSQS_Leave</code> (in configuration: <code>Leave</code>)\nLeave string quotes as they are.</p>\n</li>\n<li><p><code>JSQS_Single</code> (in configuration: <code>Single</code>)\nAlways use single quotes.</p>\n</li>\n<li><p><code>JSQS_Double</code> (in configuration: <code>Double</code>)\nAlways use double quotes.</p>\n</li>\n</ul>\n",
            "options": [
                "Leave",
                "Single",
                "Double"
            ]
        },
        "KeepEmptyLinesAtTheStartOfBlocks": {
            "type": "bool",
            "doc": "<p>  If true, empty lines at the start of blocks are kept.</p>\n"
        },
        "Language": {
            "type": "LanguageKind",
            "doc": "<p>  Language, this format style is targeted at.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>LK_None</code> (in configuration: <code>None</code>)\nDo not use.</p>\n</li>\n<li><p><code>LK_Cpp</code> (in configuration: <code>Cpp</code>)\nShould be used for C, C++, ObjectiveC, ObjectiveC++.</p>\n</li>\n<li><p><code>LK_Java</code> (in configuration: <code>Java</code>)\nShould be used for Java.</p>\n</li>\n<li><p><code>LK_JavaScript</code> (in configuration: <code>JavaScript</code>)\nShould be used for JavaScript.</p>\n</li>\n<li><p><code>LK_Proto</code> (in configuration: <code>Proto</code>)\nShould be used for Protocol Buffers\n(https://developers.google.com/protocol-buffers/).</p>\n</li>\n<li><p><code>LK_TableGen</code> (in configuration: <code>TableGen</code>)\nShould be used for TableGen code.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "Cpp",
                "Java",
                "JavaScript",
                "Proto",
                "TableGen"
            ]
        },
        "MacroBlockBegin": {
            "type": "std::string",
            "doc": "<p>  A regular expression matching macros that start a block.</p>\n"
        },
        "MacroBlockEnd": {
            "type": "std::string",
            "doc": "<p>  A regular expression matching macros that end a block.</p>\n"
        },
        "MaxEmptyLinesToKeep": {
            "type": "unsigned",
            "doc": "<p>  The maximum number of consecutive empty lines to keep.</p>\n"
        },
        "NamespaceIndentation": {
            "type": "NamespaceIndentationKind",
            "doc": "<p>  The indentation used for namespaces.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>NI_None</code> (in configuration: <code>None</code>)\nDon&#39;t indent in namespaces.</p>\n</li>\n<li><p><code>NI_Inner</code> (in configuration: <code>Inner</code>)\nIndent only in inner namespaces (nested in other namespaces).</p>\n</li>\n<li><p><code>NI_All</code> (in configuration: <code>All</code>)\nIndent in all namespaces.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "Inner",
                "All"
            ]
        },
        "ObjCBlockIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of ObjC blocks.</p>\n"
        },
        "ObjCSpaceAfterProperty": {
            "type": "bool",
            "doc": "<p>  Add a space after <code>@property</code> in Objective-C, i.e. use\n  <code>@property (readonly)</code> instead of <code>@property(readonly)</code>.</p>\n"
        },
        "ObjCSpaceBeforeProtocolList": {
            "type": "bool",
            "doc": "<p>  Add a space in front of an Objective-C protocol list, i.e. use\n  <code>Foo &lt;Protocol&gt;</code> instead of <code>Foo&lt;Protocol&gt;</code>.</p>\n"
        },
        "PenaltyBreakBeforeFirstCallParameter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking a function call after <code>call(</code>.</p>\n"
        },
        "PenaltyBreakComment": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a comment.</p>\n"
        },
        "PenaltyBreakFirstLessLess": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking before the first <code>&lt;&lt;</code>.</p>\n"
        },
        "PenaltyBreakString": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a string literal.</p>\n"
        },
        "PenaltyExcessCharacter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each character outside of the column limit.</p>\n"
        },
        "PenaltyReturnTypeOnItsOwnLine": {
            "type": "unsigned",
            "doc": "<p>  Penalty for putting the return type of a function onto its own\n  line.</p>\n"
        },
        "PointerAlignment": {
            "type": "PointerAlignmentStyle",
            "doc": "<p>  Pointer and reference alignment style.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>PAS_Left</code> (in configuration: <code>Left</code>)\nAlign pointer to the left.</p>\n</li>\n<li><p><code>PAS_Right</code> (in configuration: <code>Right</code>)\nAlign pointer to the right.</p>\n</li>\n<li><p><code>PAS_Middle</code> (in configuration: <code>Middle</code>)\nAlign pointer in the middle.</p>\n</li>\n</ul>\n",
            "options": [
                "Left",
                "Right",
                "Middle"
            ]
        },
        "ReflowComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format will attempt to re-flow comments.</p>\n"
        },
        "SortIncludes": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format will sort <code>#includes</code>.</p>\n"
        },
        "SpaceAfterCStyleCast": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, a space may be inserted after C style casts.</p>\n"
        },
        "SpaceAfterTemplateKeyword": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, a space will be inserted after the &#39;template&#39; keyword.</p>\n"
        },
        "SpaceBeforeAssignmentOperators": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, spaces will be removed before assignment operators.</p>\n"
        },
        "SpaceBeforeParens": {
            "type": "SpaceBeforeParensOptions",
            "doc": "<p>  Defines in which cases to put a space before opening parentheses.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>SBPO_Never</code> (in configuration: <code>Never</code>)\nNever put a space before opening parentheses.</p>\n</li>\n<li><p><code>SBPO_ControlStatements</code> (in configuration: <code>ControlStatements</code>)\nPut a space before opening parentheses only after control statement\nkeywords (<code>for/if/while...</code>).</p>\n</li>\n<li><p><code>SBPO_Always</code> (in configuration: <code>Always</code>)\nAlways put a space before opening parentheses, except when it&#39;s\nprohibited by the syntax rules (in function-like macro definitions) or\nwhen determined by other style rules (after unary operators, opening\nparentheses, etc.)</p>\n</li>\n</ul>\n",
            "options": [
                "Never",
                "ControlStatements",
                "Always"
            ]
        },
        "SpaceInEmptyParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into <code>()</code>.</p>\n"
        },
        "SpacesBeforeTrailingComments": {
            "type": "unsigned",
            "doc": "<p>  The number of spaces before trailing line comments\n  (<code>//</code> - comments).</p>\n<p>  This does not affect trailing block comments (<code>/*</code> - comments) as\n  those commonly have different usage patterns and a number of special\n  cases.</p>\n"
        },
        "SpacesInAngles": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>&lt;</code> and before <code>&gt;</code>\n  in template argument lists.</p>\n"
        },
        "SpacesInCStyleCastParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into C style casts.</p>\n"
        },
        "SpacesInContainerLiterals": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces are inserted inside container literals (e.g.\n  ObjC and Javascript array and dict literals).</p>\n"
        },
        "SpacesInParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>(</code> and before <code>)</code>.</p>\n"
        },
        "SpacesInSquareBrackets": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>[</code> and before <code>]</code>.</p>\n"
        },
        "Standard": {
            "type": "LanguageStandard",
            "doc": "<p>  Format compatible with this standard, e.g. use <code>A&lt;A&lt;int&gt; &gt;</code>\n  instead of <code>A&lt;A&lt;int&gt;&gt;</code> for <code>LS_Cpp03</code>.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>LS_Cpp03</code> (in configuration: <code>Cpp03</code>)\nUse C++03-compatible syntax.</p>\n</li>\n<li><p><code>LS_Cpp11</code> (in configuration: <code>Cpp11</code>)\nUse features of C++11 (e.g. <code>A&lt;A&lt;int&gt;&gt;</code> instead of <code>A&lt;A&lt;int&gt; &gt;</code>).</p>\n</li>\n<li><p><code>LS_Auto</code> (in configuration: <code>Auto</code>)\nAutomatic detection based on the input.</p>\n</li>\n</ul>\n",
            "options": [
                "Cpp03",
                "Cpp11",
                "Auto"
            ]
        },
        "TabWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns used for tab stops.</p>\n"
        },
        "UseTab": {
            "type": "UseTabStyle",
            "doc": "<p>  The way to use tab characters in the resulting file.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>UT_Never</code> (in configuration: <code>Never</code>)\nNever use tab.</p>\n</li>\n<li><p><code>UT_ForIndentation</code> (in configuration: <code>ForIndentation</code>)\nUse tabs only for indentation.</p>\n</li>\n<li><p><code>UT_Always</code> (in configuration: <code>Always</code>)\nUse tabs whenever we need to fill whitespace that spans at least from\none tab stop to the next one.</p>\n</li>\n</ul>\n",
            "options": [
                "Never",
                "ForIndentation",
                "Always"
            ]
        }
    },
    "4.0.1": {
        "BasedOnStyle": {
            "type": "string",
            "doc": "<p>  The style used for all options not specifically set in the configuration.</p>\n<p>  This option is supported only in the <strong>clang-format</strong> configuration\n  (both within <code>-style=&#39;{...}&#39;</code> and the <code>.clang-format</code> file).</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LLVM</code>\nA style complying with the <a href=\"http://llvm.org/docs/CodingStandards.html\">LLVM coding standards</a></li>\n<li><code>Google</code>\nA style complying with <a href=\"http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml\">Google&#39;s C++ style guide</a></li>\n<li><code>Chromium</code>\nA style complying with <a href=\"http://www.chromium.org/developers/coding-style\">Chromium&#39;s style guide</a></li>\n<li><code>Mozilla</code>\nA style complying with <a href=\"https://developer.mozilla.org/en-US/docs/Developer_Guide/Coding_Style\">Mozilla&#39;s style guide</a></li>\n<li><code>WebKit</code>\nA style complying with <a href=\"http://www.webkit.org/coding/coding-style.html\">WebKit&#39;s style guide</a></li>\n</ul>\n",
            "options": [
                "LLVM",
                "Google",
                "Chromium",
                "Mozilla",
                "WebKit"
            ]
        },
        "AccessModifierOffset": {
            "type": "int",
            "doc": "<p>  The extra indent or outdent of access modifiers, e.g. <code>public:</code>.</p>\n"
        },
        "AlignAfterOpenBracket": {
            "type": "BracketAlignmentStyle",
            "doc": "<p>  If <code>true</code>, horizontally aligns arguments after an open bracket.</p>\n<p>  This applies to round brackets (parentheses), angle brackets and square\n  brackets.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BAS_Align</code> (in configuration: <code>Align</code>)\nAlign parameters on the open bracket, e.g.:</p>\n<pre><code>  someLongFunction(argument1,\n                   argument2);\n</code></pre></li>\n<li><p><code>BAS_DontAlign</code> (in configuration: <code>DontAlign</code>)\nDon&#39;t align, instead use <code>ContinuationIndentWidth</code>, e.g.:</p>\n<pre><code>  someLongFunction(argument1,\n      argument2);\n</code></pre></li>\n<li><p><code>BAS_AlwaysBreak</code> (in configuration: <code>AlwaysBreak</code>)\nAlways break after an open bracket, if the parameters don&#39;t fit\non a single line, e.g.:</p>\n<pre><code>  someLongFunction(\n      argument1, argument2);\n</code></pre></li>\n</ul>\n",
            "options": [
                "Align",
                "DontAlign",
                "AlwaysBreak"
            ]
        },
        "AlignConsecutiveAssignments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns consecutive assignments.</p>\n<p>  This will align the assignment operators of consecutive lines. This\n  will result in formattings like</p>\n<pre><code class=\"lang-  \">    int aaaa = 12;\n    int b    = 23;\n    int ccc  = 23;\n</code></pre>\n"
        },
        "AlignConsecutiveDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns consecutive declarations.</p>\n<p>  This will align the declaration names of consecutive lines. This\n  will result in formattings like</p>\n<pre><code class=\"lang-  \">    int         aaaa = 12;\n    float       b = 23;\n    std::string ccc = 23;\n</code></pre>\n"
        },
        "AlignEscapedNewlinesLeft": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns escaped newlines as far left as possible.\n  Otherwise puts them into the right-most column.</p>\n"
        },
        "AlignOperands": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, horizontally align operands of binary and ternary\n  expressions.</p>\n<p>  Specifically, this aligns operands of a single expression that needs to be\n  split over multiple lines, e.g.:</p>\n<pre><code class=\"lang-  \">    int aaa = bbbbbbbbbbbbbbb +\n              ccccccccccccccc;\n</code></pre>\n"
        },
        "AlignTrailingComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns trailing comments.</p>\n"
        },
        "AllowAllParametersOfDeclarationOnNextLine": {
            "type": "bool",
            "doc": "<p>  Allow putting all parameters of a function declaration onto\n  the next line even if <code>BinPackParameters</code> is <code>false</code>.</p>\n"
        },
        "AllowShortBlocksOnASingleLine": {
            "type": "bool",
            "doc": "<p>  Allows contracting simple braced statements to a single line.</p>\n<p>  E.g., this allows <code>if (a) { return; }</code> to be put on a single line.</p>\n"
        },
        "AllowShortCaseLabelsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, short case labels will be contracted to a single line.</p>\n"
        },
        "AllowShortFunctionsOnASingleLine": {
            "type": "ShortFunctionStyle",
            "doc": "<p>  Dependent on the value, <code>int f() { return 0; }</code> can be put on a\n  single line.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>SFS_None</code> (in configuration: <code>None</code>)\nNever merge functions into a single line.</p>\n</li>\n<li><p><code>SFS_Empty</code> (in configuration: <code>Empty</code>)\nOnly merge empty functions.</p>\n</li>\n<li><p><code>SFS_Inline</code> (in configuration: <code>Inline</code>)\nOnly merge functions defined inside a class. Implies &quot;empty&quot;.</p>\n</li>\n<li><p><code>SFS_All</code> (in configuration: <code>All</code>)\nMerge all functions fitting on a single line.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "Empty",
                "Inline",
                "All"
            ]
        },
        "AllowShortIfStatementsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>if (a) return;</code> can be put on a single line.</p>\n"
        },
        "AllowShortLoopsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>while (true) continue;</code> can be put on a single\n  line.</p>\n"
        },
        "AlwaysBreakAfterDefinitionReturnType": {
            "type": "DefinitionReturnTypeBreakingStyle",
            "doc": "<p>  The function definition return type breaking style to use.  This\n  option is deprecated and is retained for backwards compatibility.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>DRTBS_None</code> (in configuration: <code>None</code>)\nBreak after return type automatically.\n<code>PenaltyReturnTypeOnItsOwnLine</code> is taken into account.</p>\n</li>\n<li><p><code>DRTBS_All</code> (in configuration: <code>All</code>)\nAlways break after the return type.</p>\n</li>\n<li><p><code>DRTBS_TopLevel</code> (in configuration: <code>TopLevel</code>)\nAlways break after the return types of top-level functions.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "All",
                "TopLevel"
            ]
        },
        "AlwaysBreakAfterReturnType": {
            "type": "ReturnTypeBreakingStyle",
            "doc": "<p>  The function declaration return type breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>RTBS_None</code> (in configuration: <code>None</code>)\nBreak after return type automatically.\n<code>PenaltyReturnTypeOnItsOwnLine</code> is taken into account.</p>\n</li>\n<li><p><code>RTBS_All</code> (in configuration: <code>All</code>)\nAlways break after the return type.</p>\n</li>\n<li><p><code>RTBS_TopLevel</code> (in configuration: <code>TopLevel</code>)\nAlways break after the return types of top-level functions.</p>\n</li>\n<li><p><code>RTBS_AllDefinitions</code> (in configuration: <code>AllDefinitions</code>)\nAlways break after the return type of function definitions.</p>\n</li>\n<li><p><code>RTBS_TopLevelDefinitions</code> (in configuration: <code>TopLevelDefinitions</code>)\nAlways break after the return type of top-level definitions.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "All",
                "TopLevel",
                "AllDefinitions",
                "TopLevelDefinitions"
            ]
        },
        "AlwaysBreakBeforeMultilineStrings": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break before multiline string literals.</p>\n<p>  This flag is mean to make cases where there are multiple multiline strings\n  in a file look more consistent. Thus, it will only take effect if wrapping\n  the string at that point leads to it being indented\n  <code>ContinuationIndentWidth</code> spaces from the start of the line.</p>\n"
        },
        "AlwaysBreakTemplateDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break after the <code>template&lt;...&gt;</code> of a template\n  declaration.</p>\n"
        },
        "BinPackArguments": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function call&#39;s arguments will either be all on the\n  same line or will have one line each.</p>\n"
        },
        "BinPackParameters": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function declaration&#39;s or function definition&#39;s\n  parameters will either all be on the same line or will have one line each.</p>\n"
        },
        "BraceWrapping": {
            "type": "BraceWrappingFlags",
            "doc": "<p>  Control of individual brace wrapping cases.</p>\n<p>  If <code>BreakBeforeBraces</code> is set to <code>BS_Custom</code>, use this to specify how\n  each individual brace case should be handled. Otherwise, this is ignored.</p>\n<p>  Nested configuration flags:</p>\n<ul>\n<li><code>bool AfterClass</code> Wrap class definitions.</li>\n<li><code>bool AfterControlStatement</code> Wrap control statements (<code>if</code>/<code>for</code>/<code>while</code>/<code>switch</code>/..).</li>\n<li><code>bool AfterEnum</code> Wrap enum definitions.</li>\n<li><code>bool AfterFunction</code> Wrap function definitions.</li>\n<li><code>bool AfterNamespace</code> Wrap namespace definitions.</li>\n<li><code>bool AfterObjCDeclaration</code> Wrap ObjC definitions (<code>@autoreleasepool</code>, interfaces, ..).</li>\n<li><code>bool AfterStruct</code> Wrap struct definitions.</li>\n<li><code>bool AfterUnion</code> Wrap union definitions.</li>\n<li><code>bool BeforeCatch</code> Wrap before <code>catch</code>.</li>\n<li><code>bool BeforeElse</code> Wrap before <code>else</code>.</li>\n<li><code>bool IndentBraces</code> Indent the wrapped braces themselves.</li>\n</ul>\n",
            "options": [
                "AfterClass",
                "AfterControlStatement",
                "AfterEnum",
                "AfterFunction",
                "AfterNamespace",
                "AfterObjCDeclaration",
                "AfterStruct",
                "AfterUnion",
                "BeforeCatch",
                "BeforeElse",
                "IndentBraces"
            ]
        },
        "BreakAfterJavaFieldAnnotations": {
            "type": "bool",
            "doc": "<p>  Break after each annotation on a field in Java files.</p>\n"
        },
        "BreakBeforeBinaryOperators": {
            "type": "BinaryOperatorStyle",
            "doc": "<p>  The way to wrap binary operators.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BOS_None</code> (in configuration: <code>None</code>)\nBreak after operators.</p>\n</li>\n<li><p><code>BOS_NonAssignment</code> (in configuration: <code>NonAssignment</code>)\nBreak before operators that aren&#39;t assignments.</p>\n</li>\n<li><p><code>BOS_All</code> (in configuration: <code>All</code>)\nBreak before operators.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "NonAssignment",
                "All"
            ]
        },
        "BreakBeforeBraces": {
            "type": "BraceBreakingStyle",
            "doc": "<p>  The brace breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BS_Attach</code> (in configuration: <code>Attach</code>)\nAlways attach braces to surrounding context.</p>\n</li>\n<li><p><code>BS_Linux</code> (in configuration: <code>Linux</code>)\nLike <code>Attach</code>, but break before braces on function, namespace and\nclass definitions.</p>\n</li>\n<li><p><code>BS_Mozilla</code> (in configuration: <code>Mozilla</code>)\nLike <code>Attach</code>, but break before braces on enum, function, and record\ndefinitions.</p>\n</li>\n<li><p><code>BS_Stroustrup</code> (in configuration: <code>Stroustrup</code>)\nLike <code>Attach</code>, but break before function definitions, <code>catch</code>, and\n<code>else</code>.</p>\n</li>\n<li><p><code>BS_Allman</code> (in configuration: <code>Allman</code>)\nAlways break before braces.</p>\n</li>\n<li><p><code>BS_GNU</code> (in configuration: <code>GNU</code>)\nAlways break before braces and add an extra level of indentation to\nbraces of control statements, not to those of class, function\nor other definitions.</p>\n</li>\n<li><p><code>BS_WebKit</code> (in configuration: <code>WebKit</code>)\nLike <code>Attach</code>, but break before functions.</p>\n</li>\n<li><p><code>BS_Custom</code> (in configuration: <code>Custom</code>)\nConfigure each individual brace in `BraceWrapping`.</p>\n</li>\n</ul>\n",
            "options": [
                "Attach",
                "Linux",
                "Mozilla",
                "Stroustrup",
                "Allman",
                "GNU",
                "WebKit",
                "Custom"
            ]
        },
        "BreakBeforeTernaryOperators": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, ternary operators will be placed after line breaks.</p>\n"
        },
        "BreakConstructorInitializersBeforeComma": {
            "type": "bool",
            "doc": "<p>  Always break constructor initializers before commas and align\n  the commas with the colon.</p>\n"
        },
        "BreakStringLiterals": {
            "type": "bool",
            "doc": "<p>  Allow breaking string literals when formatting.</p>\n"
        },
        "ColumnLimit": {
            "type": "unsigned",
            "doc": "<p>  The column limit.</p>\n<p>  A column limit of <code>0</code> means that there is no column limit. In this case,\n  clang-format will respect the input&#39;s line breaking decisions within\n  statements unless they contradict other rules.</p>\n"
        },
        "CommentPragmas": {
            "type": "std::string",
            "doc": "<p>  A regular expression that describes comments with special meaning,\n  which should not be split into lines or otherwise changed.</p>\n"
        },
        "ConstructorInitializerAllOnOneLineOrOnePerLine": {
            "type": "bool",
            "doc": "<p>  If the constructor initializers don&#39;t fit on a line, put each\n  initializer on its own line.</p>\n"
        },
        "ConstructorInitializerIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of constructor\n  initializer lists.</p>\n"
        },
        "ContinuationIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  Indent width for line continuations.</p>\n"
        },
        "Cpp11BracedListStyle": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, format braced lists as best suited for C++11 braced\n  lists.</p>\n<p>  Important differences:</p>\n<ul>\n<li>No spaces inside the braced list.</li>\n<li>No line break before the closing brace.</li>\n<li><p>Indentation with the continuation indent, not with the block indent.</p>\n<p>Fundamentally, C++11 braced lists are formatted exactly like function\ncalls would be formatted in their place. If the braced list follows a name\n(e.g. a type or variable name), clang-format formats as if the <code>{}</code> were\nthe parentheses of a function call with that name. If there is no name,\na zero-length name is assumed.</p>\n</li>\n</ul>\n"
        },
        "DerivePointerAlignment": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, analyze the formatted file for the most common\n  alignment of <code>&amp;</code> and <code>\\*</code>. <code>PointerAlignment</code> is then used only as\n  fallback.</p>\n"
        },
        "DisableFormat": {
            "type": "bool",
            "doc": "<p>  Disables formatting completely.</p>\n"
        },
        "ExperimentalAutoDetectBinPacking": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format detects whether function calls and\n  definitions are formatted with one parameter per line.</p>\n<p>  Each call can be bin-packed, one-per-line or inconclusive. If it is\n  inconclusive, e.g. completely on one line, but a decision needs to be\n  made, clang-format analyzes whether there are other bin-packed cases in\n  the input file and act accordingly.</p>\n<p>  NOTE: This is an experimental flag, that might go away or be renamed. Do\n  not use this in config files, etc. Use at your own risk.</p>\n"
        },
        "ForEachMacros": {
            "type": "std::vector<std::string>",
            "doc": "<p>  A vector of macros that should be interpreted as foreach loops\n  instead of as function calls.</p>\n<p>  These are expected to be macros of the form:</p>\n<pre><code class=\"lang-  \">    FOREACH(&lt;variable-declaration&gt;, ...)\n      &lt;loop-body&gt;\n</code></pre>\n<p>  In the .clang-format configuration file, this can be configured like:</p>\n<pre><code class=\"lang-  \">    ForEachMacros: [&#39;RANGES_FOR&#39;, &#39;FOREACH&#39;]\n</code></pre>\n<p>  For example: BOOST_FOREACH.</p>\n"
        },
        "IncludeCategories": {
            "type": "std::vector<IncludeCategory>",
            "doc": "<p>  Regular expressions denoting the different <code>#include</code> categories\n  used for ordering <code>#includes</code>.</p>\n<p>  These regular expressions are matched against the filename of an include\n  (including the &lt;&gt; or &quot;&quot;) in order. The value belonging to the first\n  matching regular expression is assigned and <code>#includes</code> are sorted first\n  according to increasing category number and then alphabetically within\n  each category.</p>\n<p>  If none of the regular expressions match, INT_MAX is assigned as\n  category. The main header for a source file automatically gets category 0.\n  so that it is generally kept at the beginning of the <code>#includes</code>\n  (http://llvm.org/docs/CodingStandards.html#include-style). However, you\n  can also assign negative priorities if you have certain headers that\n  always need to be first.</p>\n<p>  To configure this in the .clang-format file, use:</p>\n<pre><code class=\"lang-  \">    IncludeCategories:\n      - Regex:           &#39;^&quot;(llvm|llvm-c|clang|clang-c)/&#39;\n        Priority:        2\n      - Regex:           &#39;^(&lt;|&quot;(gtest|isl|json)/)&#39;\n        Priority:        3\n      - Regex:           &#39;.\\*&#39;\n        Priority:        1\n</code></pre>\n",
            "options": []
        },
        "IncludeIsMainRegex": {
            "type": "std::string",
            "doc": "<p>  Specify a regular expression of suffixes that are allowed in the\n  file-to-main-include mapping.</p>\n<p>  When guessing whether a #include is the &quot;main&quot; include (to assign\n  category 0, see above), use this regex of allowed suffixes to the header\n  stem. A partial match is done, so that:</p>\n<ul>\n<li>&quot;&quot; means &quot;arbitrary suffix&quot;</li>\n<li><p>&quot;$&quot; means &quot;no suffix&quot;</p>\n<p>For example, if configured to &quot;(_test)?$&quot;, then a header a.h would be seen\nas the &quot;main&quot; include in both a.cc and a_test.cc.</p>\n</li>\n</ul>\n"
        },
        "IndentCaseLabels": {
            "type": "bool",
            "doc": "<p>  Indent case labels one level from the switch statement.</p>\n<p>  When <code>false</code>, use the same indentation level as for the switch statement.\n  Switch statement body is always indented one level more than case labels.</p>\n"
        },
        "IndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns to use for indentation.</p>\n"
        },
        "IndentWrappedFunctionNames": {
            "type": "bool",
            "doc": "<p>  Indent if a function definition or declaration is wrapped after the\n  type.</p>\n"
        },
        "JavaScriptQuotes": {
            "type": "JavaScriptQuoteStyle",
            "doc": "<p>  The JavaScriptQuoteStyle to use for JavaScript strings.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>JSQS_Leave</code> (in configuration: <code>Leave</code>)\nLeave string quotes as they are.</p>\n</li>\n<li><p><code>JSQS_Single</code> (in configuration: <code>Single</code>)\nAlways use single quotes.</p>\n</li>\n<li><p><code>JSQS_Double</code> (in configuration: <code>Double</code>)\nAlways use double quotes.</p>\n</li>\n</ul>\n",
            "options": [
                "Leave",
                "Single",
                "Double"
            ]
        },
        "KeepEmptyLinesAtTheStartOfBlocks": {
            "type": "bool",
            "doc": "<p>  If true, empty lines at the start of blocks are kept.</p>\n"
        },
        "Language": {
            "type": "LanguageKind",
            "doc": "<p>  Language, this format style is targeted at.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>LK_None</code> (in configuration: <code>None</code>)\nDo not use.</p>\n</li>\n<li><p><code>LK_Cpp</code> (in configuration: <code>Cpp</code>)\nShould be used for C, C++, ObjectiveC, ObjectiveC++.</p>\n</li>\n<li><p><code>LK_Java</code> (in configuration: <code>Java</code>)\nShould be used for Java.</p>\n</li>\n<li><p><code>LK_JavaScript</code> (in configuration: <code>JavaScript</code>)\nShould be used for JavaScript.</p>\n</li>\n<li><p><code>LK_Proto</code> (in configuration: <code>Proto</code>)\nShould be used for Protocol Buffers\n(https://developers.google.com/protocol-buffers/).</p>\n</li>\n<li><p><code>LK_TableGen</code> (in configuration: <code>TableGen</code>)\nShould be used for TableGen code.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "Cpp",
                "Java",
                "JavaScript",
                "Proto",
                "TableGen"
            ]
        },
        "MacroBlockBegin": {
            "type": "std::string",
            "doc": "<p>  A regular expression matching macros that start a block.</p>\n"
        },
        "MacroBlockEnd": {
            "type": "std::string",
            "doc": "<p>  A regular expression matching macros that end a block.</p>\n"
        },
        "MaxEmptyLinesToKeep": {
            "type": "unsigned",
            "doc": "<p>  The maximum number of consecutive empty lines to keep.</p>\n"
        },
        "NamespaceIndentation": {
            "type": "NamespaceIndentationKind",
            "doc": "<p>  The indentation used for namespaces.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>NI_None</code> (in configuration: <code>None</code>)\nDon&#39;t indent in namespaces.</p>\n</li>\n<li><p><code>NI_Inner</code> (in configuration: <code>Inner</code>)\nIndent only in inner namespaces (nested in other namespaces).</p>\n</li>\n<li><p><code>NI_All</code> (in configuration: <code>All</code>)\nIndent in all namespaces.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "Inner",
                "All"
            ]
        },
        "ObjCBlockIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of ObjC blocks.</p>\n"
        },
        "ObjCSpaceAfterProperty": {
            "type": "bool",
            "doc": "<p>  Add a space after <code>@property</code> in Objective-C, i.e. use\n  <code>@property (readonly)</code> instead of <code>@property(readonly)</code>.</p>\n"
        },
        "ObjCSpaceBeforeProtocolList": {
            "type": "bool",
            "doc": "<p>  Add a space in front of an Objective-C protocol list, i.e. use\n  <code>Foo &lt;Protocol&gt;</code> instead of <code>Foo&lt;Protocol&gt;</code>.</p>\n"
        },
        "PenaltyBreakBeforeFirstCallParameter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking a function call after <code>call(</code>.</p>\n"
        },
        "PenaltyBreakComment": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a comment.</p>\n"
        },
        "PenaltyBreakFirstLessLess": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking before the first <code>&lt;&lt;</code>.</p>\n"
        },
        "PenaltyBreakString": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a string literal.</p>\n"
        },
        "PenaltyExcessCharacter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each character outside of the column limit.</p>\n"
        },
        "PenaltyReturnTypeOnItsOwnLine": {
            "type": "unsigned",
            "doc": "<p>  Penalty for putting the return type of a function onto its own\n  line.</p>\n"
        },
        "PointerAlignment": {
            "type": "PointerAlignmentStyle",
            "doc": "<p>  Pointer and reference alignment style.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>PAS_Left</code> (in configuration: <code>Left</code>)\nAlign pointer to the left.</p>\n</li>\n<li><p><code>PAS_Right</code> (in configuration: <code>Right</code>)\nAlign pointer to the right.</p>\n</li>\n<li><p><code>PAS_Middle</code> (in configuration: <code>Middle</code>)\nAlign pointer in the middle.</p>\n</li>\n</ul>\n",
            "options": [
                "Left",
                "Right",
                "Middle"
            ]
        },
        "ReflowComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format will attempt to re-flow comments.</p>\n"
        },
        "SortIncludes": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format will sort <code>#includes</code>.</p>\n"
        },
        "SpaceAfterCStyleCast": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, a space may be inserted after C style casts.</p>\n"
        },
        "SpaceAfterTemplateKeyword": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, a space will be inserted after the &#39;template&#39; keyword.</p>\n"
        },
        "SpaceBeforeAssignmentOperators": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, spaces will be removed before assignment operators.</p>\n"
        },
        "SpaceBeforeParens": {
            "type": "SpaceBeforeParensOptions",
            "doc": "<p>  Defines in which cases to put a space before opening parentheses.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>SBPO_Never</code> (in configuration: <code>Never</code>)\nNever put a space before opening parentheses.</p>\n</li>\n<li><p><code>SBPO_ControlStatements</code> (in configuration: <code>ControlStatements</code>)\nPut a space before opening parentheses only after control statement\nkeywords (<code>for/if/while...</code>).</p>\n</li>\n<li><p><code>SBPO_Always</code> (in configuration: <code>Always</code>)\nAlways put a space before opening parentheses, except when it&#39;s\nprohibited by the syntax rules (in function-like macro definitions) or\nwhen determined by other style rules (after unary operators, opening\nparentheses, etc.)</p>\n</li>\n</ul>\n",
            "options": [
                "Never",
                "ControlStatements",
                "Always"
            ]
        },
        "SpaceInEmptyParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into <code>()</code>.</p>\n"
        },
        "SpacesBeforeTrailingComments": {
            "type": "unsigned",
            "doc": "<p>  The number of spaces before trailing line comments\n  (<code>//</code> - comments).</p>\n<p>  This does not affect trailing block comments (<code>/*</code> - comments) as\n  those commonly have different usage patterns and a number of special\n  cases.</p>\n"
        },
        "SpacesInAngles": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>&lt;</code> and before <code>&gt;</code>\n  in template argument lists.</p>\n"
        },
        "SpacesInCStyleCastParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into C style casts.</p>\n"
        },
        "SpacesInContainerLiterals": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces are inserted inside container literals (e.g.\n  ObjC and Javascript array and dict literals).</p>\n"
        },
        "SpacesInParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>(</code> and before <code>)</code>.</p>\n"
        },
        "SpacesInSquareBrackets": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>[</code> and before <code>]</code>.</p>\n"
        },
        "Standard": {
            "type": "LanguageStandard",
            "doc": "<p>  Format compatible with this standard, e.g. use <code>A&lt;A&lt;int&gt; &gt;</code>\n  instead of <code>A&lt;A&lt;int&gt;&gt;</code> for <code>LS_Cpp03</code>.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>LS_Cpp03</code> (in configuration: <code>Cpp03</code>)\nUse C++03-compatible syntax.</p>\n</li>\n<li><p><code>LS_Cpp11</code> (in configuration: <code>Cpp11</code>)\nUse features of C++11, C++14 and C++1z (e.g. <code>A&lt;A&lt;int&gt;&gt;</code> instead of \n<code>A&lt;A&lt;int&gt; &gt;</code>).</p>\n</li>\n<li><p><code>LS_Auto</code> (in configuration: <code>Auto</code>)\nAutomatic detection based on the input.</p>\n</li>\n</ul>\n",
            "options": [
                "Cpp03",
                "Cpp11",
                "Auto"
            ]
        },
        "TabWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns used for tab stops.</p>\n"
        },
        "UseTab": {
            "type": "UseTabStyle",
            "doc": "<p>  The way to use tab characters in the resulting file.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>UT_Never</code> (in configuration: <code>Never</code>)\nNever use tab.</p>\n</li>\n<li><p><code>UT_ForIndentation</code> (in configuration: <code>ForIndentation</code>)\nUse tabs only for indentation.</p>\n</li>\n<li><p><code>UT_Always</code> (in configuration: <code>Always</code>)\nUse tabs whenever we need to fill whitespace that spans at least from\none tab stop to the next one.</p>\n</li>\n</ul>\n",
            "options": [
                "Never",
                "ForIndentation",
                "Always"
            ]
        }
    },
    "5.0.0": {
        "BasedOnStyle": {
            "type": "string",
            "doc": "<p>  The style used for all options not specifically set in the configuration.</p>\n<p>  This option is supported only in the <strong>clang-format</strong> configuration\n  (both within <code>-style=&#39;{...}&#39;</code> and the <code>.clang-format</code> file).</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LLVM</code>\nA style complying with the <a href=\"http://llvm.org/docs/CodingStandards.html\">LLVM coding standards</a></li>\n<li><code>Google</code>\nA style complying with <a href=\"http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml\">Google&#39;s C++ style guide</a></li>\n<li><code>Chromium</code>\nA style complying with <a href=\"http://www.chromium.org/developers/coding-style\">Chromium&#39;s style guide</a></li>\n<li><code>Mozilla</code>\nA style complying with <a href=\"https://developer.mozilla.org/en-US/docs/Developer_Guide/Coding_Style\">Mozilla&#39;s style guide</a></li>\n<li><code>WebKit</code>\nA style complying with <a href=\"http://www.webkit.org/coding/coding-style.html\">WebKit&#39;s style guide</a></li>\n</ul>\n",
            "options": [
                "LLVM",
                "Google",
                "Chromium",
                "Mozilla",
                "WebKit"
            ]
        },
        "AccessModifierOffset": {
            "type": "int",
            "doc": "<p>  The extra indent or outdent of access modifiers, e.g. <code>public:</code>.</p>\n"
        },
        "AlignAfterOpenBracket": {
            "type": "BracketAlignmentStyle",
            "doc": "<p>  If <code>true</code>, horizontally aligns arguments after an open bracket.</p>\n<p>  This applies to round brackets (parentheses), angle brackets and square\n  brackets.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BAS_Align</code> (in configuration: <code>Align</code>)\nAlign parameters on the open bracket, e.g.:</p>\n<pre><code>  someLongFunction(argument1,\n                   argument2);\n</code></pre></li>\n<li><p><code>BAS_DontAlign</code> (in configuration: <code>DontAlign</code>)\nDon&#39;t align, instead use <code>ContinuationIndentWidth</code>, e.g.:</p>\n<pre><code>  someLongFunction(argument1,\n      argument2);\n</code></pre></li>\n<li><p><code>BAS_AlwaysBreak</code> (in configuration: <code>AlwaysBreak</code>)\nAlways break after an open bracket, if the parameters don&#39;t fit\non a single line, e.g.:</p>\n<pre><code>  someLongFunction(\n      argument1, argument2);\n</code></pre></li>\n</ul>\n",
            "options": [
                "Align",
                "DontAlign",
                "AlwaysBreak"
            ]
        },
        "AlignConsecutiveAssignments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns consecutive assignments.</p>\n<p>  This will align the assignment operators of consecutive lines. This\n  will result in formattings like</p>\n<pre><code class=\"lang-  \">    int aaaa = 12;\n    int b    = 23;\n    int ccc  = 23;\n</code></pre>\n"
        },
        "AlignConsecutiveDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns consecutive declarations.</p>\n<p>  This will align the declaration names of consecutive lines. This\n  will result in formattings like</p>\n<pre><code class=\"lang-  \">    int         aaaa = 12;\n    float       b = 23;\n    std::string ccc = 23;\n</code></pre>\n"
        },
        "AlignEscapedNewlines": {
            "type": "EscapedNewlineAlignmentStyle",
            "doc": "<p>  Options for aligning backslashes in escaped newlines.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>ENAS_DontAlign</code> (in configuration: <code>DontAlign</code>)\nDon&#39;t align escaped newlines.</p>\n<pre><code>  #define A \\\n    int aaaa; \\\n    int b; \\\n    int dddddddddd;\n</code></pre></li>\n<li><p><code>ENAS_Left</code> (in configuration: <code>Left</code>)\nAlign escaped newlines as far left as possible.</p>\n<pre><code>  true:\n  #define A   \\\n    int aaaa; \\\n    int b;    \\\n    int dddddddddd;\n</code></pre><p>  false:</p>\n</li>\n<li><p><code>ENAS_Right</code> (in configuration: <code>Right</code>)\nAlign escaped newlines in the right-most column.</p>\n<pre><code>  #define A                                                                      \\\n    int aaaa;                                                                    \\\n    int b;                                                                       \\\n    int dddddddddd;\n</code></pre></li>\n</ul>\n",
            "options": [
                "DontAlign",
                "Left",
                "Right"
            ]
        },
        "AlignOperands": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, horizontally align operands of binary and ternary\n  expressions.</p>\n<p>  Specifically, this aligns operands of a single expression that needs to be\n  split over multiple lines, e.g.:</p>\n<pre><code class=\"lang-  \">    int aaa = bbbbbbbbbbbbbbb +\n              ccccccccccccccc;\n</code></pre>\n"
        },
        "AlignTrailingComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns trailing comments.</p>\n<pre><code class=\"lang-  \">    true:                                   false:\n    int a;     // My comment a      vs.     int a; // My comment a\n    int b = 2; // comment  b                int b = 2; // comment about b\n</code></pre>\n"
        },
        "AllowAllParametersOfDeclarationOnNextLine": {
            "type": "bool",
            "doc": "<p>  Allow putting all parameters of a function declaration onto\n  the next line even if <code>BinPackParameters</code> is <code>false</code>.</p>\n<pre><code class=\"lang-  \">    true:                                   false:\n    myFunction(foo,                 vs.     myFunction(foo, bar, plop);\n               bar,\n               plop);\n</code></pre>\n"
        },
        "AllowShortBlocksOnASingleLine": {
            "type": "bool",
            "doc": "<p>  Allows contracting simple braced statements to a single line.</p>\n<p>  E.g., this allows <code>if (a) { return; }</code> to be put on a single line.</p>\n"
        },
        "AllowShortCaseLabelsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, short case labels will be contracted to a single line.</p>\n<pre><code class=\"lang-  \">    true:                                   false:\n    switch (a) {                    vs.     switch (a) {\n    case 1: x = 1; break;                   case 1:\n    case 2: return;                           x = 1;\n    }                                         break;\n                                            case 2:\n                                              return;\n                                            }\n</code></pre>\n"
        },
        "AllowShortFunctionsOnASingleLine": {
            "type": "ShortFunctionStyle",
            "doc": "<p>  Dependent on the value, <code>int f() { return 0; }</code> can be put on a\n  single line.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>SFS_None</code> (in configuration: <code>None</code>)\nNever merge functions into a single line.</p>\n</li>\n<li><p><code>SFS_InlineOnly</code> (in configuration: <code>InlineOnly</code>)\nOnly merge functions defined inside a class. Same as &quot;inline&quot;,\nexcept it does not implies &quot;empty&quot;: i.e. top level empty functions\nare not merged either.</p>\n<pre><code>  class Foo {\n    void f() { foo(); }\n  };\n  void f() {\n    foo();\n  }\n  void f() {\n  }\n</code></pre></li>\n<li><p><code>SFS_Empty</code> (in configuration: <code>Empty</code>)\nOnly merge empty functions.</p>\n<pre><code>  void f() {}\n  void f2() {\n    bar2();\n  }\n</code></pre></li>\n<li><p><code>SFS_Inline</code> (in configuration: <code>Inline</code>)\nOnly merge functions defined inside a class. Implies &quot;empty&quot;.</p>\n<pre><code>  class Foo {\n    void f() { foo(); }\n  };\n  void f() {\n    foo();\n  }\n  void f() {}\n</code></pre></li>\n<li><p><code>SFS_All</code> (in configuration: <code>All</code>)\nMerge all functions fitting on a single line.</p>\n<pre><code>  class Foo {\n    void f() { foo(); }\n  };\n  void f() { bar(); }\n</code></pre></li>\n</ul>\n",
            "options": [
                "None",
                "InlineOnly",
                "Empty",
                "Inline",
                "All"
            ]
        },
        "AllowShortIfStatementsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>if (a) return;</code> can be put on a single line.</p>\n"
        },
        "AllowShortLoopsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>while (true) continue;</code> can be put on a single\n  line.</p>\n"
        },
        "AlwaysBreakAfterDefinitionReturnType": {
            "type": "DefinitionReturnTypeBreakingStyle",
            "doc": "<p>  The function definition return type breaking style to use.  This\n  option is <strong>deprecated</strong> and is retained for backwards compatibility.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>DRTBS_None</code> (in configuration: <code>None</code>)\nBreak after return type automatically.\n<code>PenaltyReturnTypeOnItsOwnLine</code> is taken into account.</p>\n</li>\n<li><p><code>DRTBS_All</code> (in configuration: <code>All</code>)\nAlways break after the return type.</p>\n</li>\n<li><p><code>DRTBS_TopLevel</code> (in configuration: <code>TopLevel</code>)\nAlways break after the return types of top-level functions.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "All",
                "TopLevel"
            ]
        },
        "AlwaysBreakAfterReturnType": {
            "type": "ReturnTypeBreakingStyle",
            "doc": "<p>  The function declaration return type breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>RTBS_None</code> (in configuration: <code>None</code>)\nBreak after return type automatically.\n<code>PenaltyReturnTypeOnItsOwnLine</code> is taken into account.</p>\n<pre><code>  class A {\n    int f() { return 0; };\n  };\n  int f();\n  int f() { return 1; }\n</code></pre></li>\n<li><p><code>RTBS_All</code> (in configuration: <code>All</code>)\nAlways break after the return type.</p>\n<pre><code>  class A {\n    int\n    f() {\n      return 0;\n    };\n  };\n  int\n  f();\n  int\n  f() {\n    return 1;\n  }\n</code></pre></li>\n<li><p><code>RTBS_TopLevel</code> (in configuration: <code>TopLevel</code>)\nAlways break after the return types of top-level functions.</p>\n<pre><code>  class A {\n    int f() { return 0; };\n  };\n  int\n  f();\n  int\n  f() {\n    return 1;\n  }\n</code></pre></li>\n<li><p><code>RTBS_AllDefinitions</code> (in configuration: <code>AllDefinitions</code>)\nAlways break after the return type of function definitions.</p>\n<pre><code>  class A {\n    int\n    f() {\n      return 0;\n    };\n  };\n  int f();\n  int\n  f() {\n    return 1;\n  }\n</code></pre></li>\n<li><p><code>RTBS_TopLevelDefinitions</code> (in configuration: <code>TopLevelDefinitions</code>)\nAlways break after the return type of top-level definitions.</p>\n<pre><code>  class A {\n    int f() { return 0; };\n  };\n  int f();\n  int\n  f() {\n    return 1;\n  }\n</code></pre></li>\n</ul>\n",
            "options": [
                "None",
                "All",
                "TopLevel",
                "AllDefinitions",
                "TopLevelDefinitions"
            ]
        },
        "AlwaysBreakBeforeMultilineStrings": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break before multiline string literals.</p>\n<p>  This flag is mean to make cases where there are multiple multiline strings\n  in a file look more consistent. Thus, it will only take effect if wrapping\n  the string at that point leads to it being indented\n  <code>ContinuationIndentWidth</code> spaces from the start of the line.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     aaaa =                         vs.     aaaa = &quot;bbbb&quot;\n         &quot;bbbb&quot;                                    &quot;cccc&quot;;\n         &quot;cccc&quot;;\n</code></pre>\n"
        },
        "AlwaysBreakTemplateDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break after the <code>template&lt;...&gt;</code> of a template\n  declaration.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     template &lt;typename T&gt;          vs.     template &lt;typename T&gt; class C {};\n     class C {};\n</code></pre>\n"
        },
        "BinPackArguments": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function call&#39;s arguments will either be all on the\n  same line or will have one line each.</p>\n<pre><code class=\"lang-  \">    true:\n    void f() {\n      f(aaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaa,\n        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\n    }\n</code></pre>\n<pre><code>false:\nvoid f() {\n  f(aaaaaaaaaaaaaaaaaaaa,\n    aaaaaaaaaaaaaaaaaaaa,\n    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\n}\n</code></pre>"
        },
        "BinPackParameters": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function declaration&#39;s or function definition&#39;s\n  parameters will either all be on the same line or will have one line each.</p>\n<pre><code class=\"lang-  \">    true:\n    void f(int aaaaaaaaaaaaaaaaaaaa, int aaaaaaaaaaaaaaaaaaaa,\n           int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\n</code></pre>\n<pre><code>false:\nvoid f(int aaaaaaaaaaaaaaaaaaaa,\n       int aaaaaaaaaaaaaaaaaaaa,\n       int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\n</code></pre>"
        },
        "BraceWrapping": {
            "type": "BraceWrappingFlags",
            "doc": "<p>  Control of individual brace wrapping cases.</p>\n<p>  If <code>BreakBeforeBraces</code> is set to <code>BS_Custom</code>, use this to specify how\n  each individual brace case should be handled. Otherwise, this is ignored.</p>\n<p>  Nested configuration flags:</p>\n<ul>\n<li><p><code>bool AfterClass</code> Wrap class definitions.</p>\n<pre><code>  true:\n  class foo {};\n</code></pre><p>  false:\n  class foo\n  {};</p>\n</li>\n<li><p><code>bool AfterControlStatement</code> Wrap control statements (<code>if</code>/<code>for</code>/<code>while</code>/<code>switch</code>/..).</p>\n<pre><code>  true:\n  if (foo())\n  {\n  } else\n  {}\n  for (int i = 0; i &lt; 10; ++i)\n  {}\n</code></pre><p>  false:\n  if (foo()) {\n  } else {\n  }\n  for (int i = 0; i &lt; 10; ++i) {\n  }</p>\n</li>\n<li><p><code>bool AfterEnum</code> Wrap enum definitions.</p>\n<pre><code>  true:\n  enum X : int\n  {\n    B\n  };\n</code></pre><p>  false:\n  enum X : int { B };</p>\n</li>\n<li><p><code>bool AfterFunction</code> Wrap function definitions.</p>\n<pre><code>  true:\n  void foo()\n  {\n    bar();\n    bar2();\n  }\n</code></pre><p>  false:\n  void foo() {</p>\n<pre><code>bar();\nbar2();\n</code></pre><p>  }</p>\n</li>\n<li><p><code>bool AfterNamespace</code> Wrap namespace definitions.</p>\n<pre><code>  true:\n  namespace\n  {\n  int foo();\n  int bar();\n  }\n</code></pre><p>  false:\n  namespace {\n  int foo();\n  int bar();\n  }</p>\n</li>\n<li><p><code>bool AfterObjCDeclaration</code> Wrap ObjC definitions (<code>@autoreleasepool</code>, interfaces, ..).</p>\n</li>\n<li><p><code>bool AfterStruct</code> Wrap struct definitions.</p>\n<pre><code>  true:\n  struct foo\n  {\n    int x;\n  };\n</code></pre><p>  false:\n  struct foo {</p>\n<pre><code>int x;\n</code></pre><p>  };</p>\n</li>\n<li><p><code>bool AfterUnion</code> Wrap union definitions.</p>\n<pre><code>  true:\n  union foo\n  {\n    int x;\n  }\n</code></pre><p>  false:\n  union foo {</p>\n<pre><code>int x;\n</code></pre><p>  }</p>\n</li>\n<li><p><code>bool BeforeCatch</code> Wrap before <code>catch</code>.</p>\n<pre><code>  true:\n  try {\n    foo();\n  }\n  catch () {\n  }\n</code></pre><p>  false:\n  try {</p>\n<pre><code>foo();\n</code></pre><p>  } catch () {\n  }</p>\n</li>\n<li><p><code>bool BeforeElse</code> Wrap before <code>else</code>.</p>\n<pre><code>  true:\n  if (foo()) {\n  }\n  else {\n  }\n</code></pre><p>  false:\n  if (foo()) {\n  } else {\n  }</p>\n</li>\n<li><p><code>bool IndentBraces</code> Indent the wrapped braces themselves.</p>\n</li>\n<li><p><code>bool SplitEmptyFunctionBody</code> If <code>false</code>, empty function body can be put on a single line.\nThis option is used only if the opening brace of the function has\nalready been wrapped, i.e. the `AfterFunction` brace wrapping mode is\nset, and the function could/should not be put on a single line (as per\n`AllowShortFunctionsOnASingleLine` and constructor formatting options).</p>\n<pre><code>  int f()   vs.   inf f()\n  {}              {\n                  }\n</code></pre></li>\n</ul>\n",
            "options": [
                "AfterClass",
                "AfterControlStatement",
                "AfterEnum",
                "AfterFunction",
                "AfterNamespace",
                "AfterObjCDeclaration",
                "AfterStruct",
                "AfterUnion",
                "BeforeCatch",
                "BeforeElse",
                "IndentBraces",
                "SplitEmptyFunctionBody"
            ]
        },
        "BreakAfterJavaFieldAnnotations": {
            "type": "bool",
            "doc": "<p>  Break after each annotation on a field in Java files.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     @Partial                       vs.     @Partial @Mock DataLoad loader;\n     @Mock\n     DataLoad loader;\n</code></pre>\n"
        },
        "BreakBeforeBinaryOperators": {
            "type": "BinaryOperatorStyle",
            "doc": "<p>  The way to wrap binary operators.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BOS_None</code> (in configuration: <code>None</code>)\nBreak after operators.</p>\n<pre><code>   LooooooooooongType loooooooooooooooooooooongVariable =\n       someLooooooooooooooooongFunction();\n</code></pre><p>   bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +</p>\n<pre><code>                    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==\n                aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &amp;&amp;\n            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &gt;\n                ccccccccccccccccccccccccccccccccccccccccc;\n</code></pre></li>\n<li><p><code>BOS_NonAssignment</code> (in configuration: <code>NonAssignment</code>)\nBreak before operators that aren&#39;t assignments.</p>\n<pre><code>   LooooooooooongType loooooooooooooooooooooongVariable =\n       someLooooooooooooooooongFunction();\n</code></pre><p>   bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</p>\n<pre><code>                    + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n                == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n            &amp;&amp; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n                   &gt; ccccccccccccccccccccccccccccccccccccccccc;\n</code></pre></li>\n<li><p><code>BOS_All</code> (in configuration: <code>All</code>)\nBreak before operators.</p>\n<pre><code>   LooooooooooongType loooooooooooooooooooooongVariable\n       = someLooooooooooooooooongFunction();\n</code></pre><p>   bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</p>\n<pre><code>                    + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n                == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n            &amp;&amp; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n                   &gt; ccccccccccccccccccccccccccccccccccccccccc;\n</code></pre></li>\n</ul>\n",
            "options": [
                "None",
                "NonAssignment",
                "All"
            ]
        },
        "BreakBeforeBraces": {
            "type": "BraceBreakingStyle",
            "doc": "<p>  The brace breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BS_Attach</code> (in configuration: <code>Attach</code>)\nAlways attach braces to surrounding context.</p>\n<pre><code>  try {\n    foo();\n  } catch () {\n  }\n  void foo() { bar(); }\n  class foo {};\n  if (foo()) {\n  } else {\n  }\n  enum X : int { A, B };\n</code></pre></li>\n<li><p><code>BS_Linux</code> (in configuration: <code>Linux</code>)\nLike <code>Attach</code>, but break before braces on function, namespace and\nclass definitions.</p>\n<pre><code>  try {\n    foo();\n  } catch () {\n  }\n  void foo() { bar(); }\n  class foo\n  {\n  };\n  if (foo()) {\n  } else {\n  }\n  enum X : int { A, B };\n</code></pre></li>\n<li><p><code>BS_Mozilla</code> (in configuration: <code>Mozilla</code>)\nLike <code>Attach</code>, but break before braces on enum, function, and record\ndefinitions.</p>\n<pre><code>  try {\n    foo();\n  } catch () {\n  }\n  void foo() { bar(); }\n  class foo\n  {\n  };\n  if (foo()) {\n  } else {\n  }\n  enum X : int { A, B };\n</code></pre></li>\n<li><p><code>BS_Stroustrup</code> (in configuration: <code>Stroustrup</code>)\nLike <code>Attach</code>, but break before function definitions, <code>catch</code>, and\n<code>else</code>.</p>\n<pre><code>  try {\n    foo();\n  } catch () {\n  }\n  void foo() { bar(); }\n  class foo\n  {\n  };\n  if (foo()) {\n  } else {\n  }\n  enum X : int\n  {\n    A,\n    B\n  };\n</code></pre></li>\n<li><p><code>BS_Allman</code> (in configuration: <code>Allman</code>)\nAlways break before braces.</p>\n<pre><code>  try {\n    foo();\n  }\n  catch () {\n  }\n  void foo() { bar(); }\n  class foo {\n  };\n  if (foo()) {\n  }\n  else {\n  }\n  enum X : int { A, B };\n</code></pre></li>\n<li><p><code>BS_GNU</code> (in configuration: <code>GNU</code>)\nAlways break before braces and add an extra level of indentation to\nbraces of control statements, not to those of class, function\nor other definitions.</p>\n<pre><code>  try\n    {\n      foo();\n    }\n  catch ()\n    {\n    }\n  void foo() { bar(); }\n  class foo\n  {\n  };\n  if (foo())\n    {\n    }\n  else\n    {\n    }\n  enum X : int\n  {\n    A,\n    B\n  };\n</code></pre></li>\n<li><p><code>BS_WebKit</code> (in configuration: <code>WebKit</code>)\nLike <code>Attach</code>, but break before functions.</p>\n<pre><code>  try {\n    foo();\n  } catch () {\n  }\n  void foo() { bar(); }\n  class foo {\n  };\n  if (foo()) {\n  } else {\n  }\n  enum X : int { A, B };\n</code></pre></li>\n<li><p><code>BS_Custom</code> (in configuration: <code>Custom</code>)\nConfigure each individual brace in `BraceWrapping`.</p>\n</li>\n</ul>\n",
            "options": [
                "Attach",
                "Linux",
                "Mozilla",
                "Stroustrup",
                "Allman",
                "GNU",
                "WebKit",
                "Custom"
            ]
        },
        "BreakBeforeInheritanceComma": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, in the class inheritance expression clang-format will\n  break before <code>:</code> and <code>,</code> if there is multiple inheritance.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     class MyClass                  vs.     class MyClass : public X, public Y {\n         : public X                         };\n         , public Y {\n     };\n</code></pre>\n"
        },
        "BreakBeforeTernaryOperators": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, ternary operators will be placed after line breaks.</p>\n<pre><code class=\"lang-  \">     true:\n     veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription\n         ? firstValue\n         : SecondValueVeryVeryVeryVeryLong;\n</code></pre>\n<pre><code> false:\n veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ?\n     firstValue :\n     SecondValueVeryVeryVeryVeryLong;\n</code></pre>"
        },
        "BreakConstructorInitializers": {
            "type": "BreakConstructorInitializersStyle",
            "doc": "<p>  The constructor initializers style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BCIS_BeforeColon</code> (in configuration: <code>BeforeColon</code>)\nBreak constructor initializers before the colon and after the commas.</p>\n<pre><code>Constructor()\n    : initializer1(),\n      initializer2()\n</code></pre></li>\n<li><p><code>BCIS_BeforeComma</code> (in configuration: <code>BeforeComma</code>)\nBreak constructor initializers before the colon and commas, and align\nthe commas with the colon.</p>\n<pre><code>Constructor()\n    : initializer1()\n    , initializer2()\n</code></pre></li>\n<li><p><code>BCIS_AfterColon</code> (in configuration: <code>AfterColon</code>)\nBreak constructor initializers after the colon and commas.</p>\n<pre><code>Constructor() :\n    initializer1(),\n    initializer2()\n</code></pre></li>\n</ul>\n",
            "options": [
                "BeforeColon",
                "BeforeComma",
                "AfterColon"
            ]
        },
        "BreakStringLiterals": {
            "type": "bool",
            "doc": "<p>  Allow breaking string literals when formatting.</p>\n"
        },
        "ColumnLimit": {
            "type": "unsigned",
            "doc": "<p>  The column limit.</p>\n<p>  A column limit of <code>0</code> means that there is no column limit. In this case,\n  clang-format will respect the input&#39;s line breaking decisions within\n  statements unless they contradict other rules.</p>\n"
        },
        "CommentPragmas": {
            "type": "std::string",
            "doc": "<p>  A regular expression that describes comments with special meaning,\n  which should not be split into lines or otherwise changed.</p>\n<pre><code class=\"lang-  \">     // CommentPragmas: &#39;^ FOOBAR pragma:&#39;\n     // Will leave the following line unaffected\n     #include &lt;vector&gt; // FOOBAR pragma: keep\n</code></pre>\n"
        },
        "CompactNamespaces": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, consecutive namespace declarations will be on the same\n  line. If <code>false</code>, each namespace is declared on a new line.</p>\n<pre><code class=\"lang-  \">    true:\n    namespace Foo { namespace Bar {\n    }}\n</code></pre>\n<pre><code>false:\nnamespace Foo {\nnamespace Bar {\n}\n}\n</code></pre><p>  If it does not fit on a single line, the overflowing namespaces get\n  wrapped:</p>\n<pre><code class=\"lang-  \">    namespace Foo { namespace Bar {\n    namespace Extra {\n    }}}\n</code></pre>\n"
        },
        "ConstructorInitializerAllOnOneLineOrOnePerLine": {
            "type": "bool",
            "doc": "<p>  If the constructor initializers don&#39;t fit on a line, put each\n  initializer on its own line.</p>\n<pre><code class=\"lang-  \">    true:\n    SomeClass::Constructor()\n        : aaaaaaaa(aaaaaaaa), aaaaaaaa(aaaaaaaa), aaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaa) {\n      return 0;\n    }\n</code></pre>\n<pre><code>false:\nSomeClass::Constructor()\n    : aaaaaaaa(aaaaaaaa), aaaaaaaa(aaaaaaaa),\n      aaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaa) {\n  return 0;\n}\n</code></pre>"
        },
        "ConstructorInitializerIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of constructor\n  initializer lists.</p>\n"
        },
        "ContinuationIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  Indent width for line continuations.</p>\n<pre><code class=\"lang-  \">     ContinuationIndentWidth: 2\n</code></pre>\n<pre><code> int i =         //  VeryVeryVeryVeryVeryLongComment\n   longFunction( // Again a long comment\n     arg);\n</code></pre>"
        },
        "Cpp11BracedListStyle": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, format braced lists as best suited for C++11 braced\n  lists.</p>\n<p>  Important differences:</p>\n<ul>\n<li>No spaces inside the braced list.</li>\n<li>No line break before the closing brace.</li>\n<li><p>Indentation with the continuation indent, not with the block indent.</p>\n<p>Fundamentally, C++11 braced lists are formatted exactly like function\ncalls would be formatted in their place. If the braced list follows a name\n(e.g. a type or variable name), clang-format formats as if the <code>{}</code> were\nthe parentheses of a function call with that name. If there is no name,\na zero-length name is assumed.</p>\n<pre><code> true:                                  false:\n vector&lt;int&gt; x{1, 2, 3, 4};     vs.     vector&lt;int&gt; x{ 1, 2, 3, 4 };\n vector&lt;T&gt; x{{}, {}, {}, {}};           vector&lt;T&gt; x{ {}, {}, {}, {} };\n f(MyMap[{composite, key}]);            f(MyMap[{ composite, key }]);\n new int[3]{1, 2, 3};                   new int[3]{ 1, 2, 3 };\n</code></pre></li>\n</ul>\n"
        },
        "DerivePointerAlignment": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, analyze the formatted file for the most common\n  alignment of <code>&amp;</code> and <code>*</code>.\n  Pointer and reference alignment styles are going to be updated according\n  to the preferences found in the file.\n  <code>PointerAlignment</code> is then used only as fallback.</p>\n"
        },
        "DisableFormat": {
            "type": "bool",
            "doc": "<p>  Disables formatting completely.</p>\n"
        },
        "ExperimentalAutoDetectBinPacking": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format detects whether function calls and\n  definitions are formatted with one parameter per line.</p>\n<p>  Each call can be bin-packed, one-per-line or inconclusive. If it is\n  inconclusive, e.g. completely on one line, but a decision needs to be\n  made, clang-format analyzes whether there are other bin-packed cases in\n  the input file and act accordingly.</p>\n<p>  NOTE: This is an experimental flag, that might go away or be renamed. Do\n  not use this in config files, etc. Use at your own risk.</p>\n"
        },
        "FixNamespaceComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format adds missing namespace end comments and\n  fixes invalid existing ones.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     namespace a {                  vs.     namespace a {\n     foo();                                 foo();\n     } // namespace a;                      }\n</code></pre>\n"
        },
        "ForEachMacros": {
            "type": "std::vector<std::string>",
            "doc": "<p>  A vector of macros that should be interpreted as foreach loops\n  instead of as function calls.</p>\n<p>  These are expected to be macros of the form:</p>\n<pre><code class=\"lang-  \">    FOREACH(&lt;variable-declaration&gt;, ...)\n      &lt;loop-body&gt;\n</code></pre>\n<p>  In the .clang-format configuration file, this can be configured like:</p>\n<pre><code class=\"lang-  \">    ForEachMacros: [&#39;RANGES_FOR&#39;, &#39;FOREACH&#39;]\n</code></pre>\n<p>  For example: BOOST_FOREACH.</p>\n"
        },
        "IncludeCategories": {
            "type": "std::vector<IncludeCategory>",
            "doc": "<p>  Regular expressions denoting the different <code>#include</code> categories\n  used for ordering <code>#includes</code>.</p>\n<p>  These regular expressions are matched against the filename of an include\n  (including the &lt;&gt; or &quot;&quot;) in order. The value belonging to the first\n  matching regular expression is assigned and <code>#includes</code> are sorted first\n  according to increasing category number and then alphabetically within\n  each category.</p>\n<p>  If none of the regular expressions match, INT_MAX is assigned as\n  category. The main header for a source file automatically gets category 0.\n  so that it is generally kept at the beginning of the <code>#includes</code>\n  (http://llvm.org/docs/CodingStandards.html#include-style). However, you\n  can also assign negative priorities if you have certain headers that\n  always need to be first.</p>\n<p>  To configure this in the .clang-format file, use:</p>\n<pre><code class=\"lang-  \">    IncludeCategories:\n      - Regex:           &#39;^&quot;(llvm|llvm-c|clang|clang-c)/&#39;\n        Priority:        2\n      - Regex:           &#39;^(&lt;|&quot;(gtest|isl|json)/)&#39;\n        Priority:        3\n      - Regex:           &#39;.*&#39;\n        Priority:        1\n</code></pre>\n",
            "options": []
        },
        "IncludeIsMainRegex": {
            "type": "std::string",
            "doc": "<p>  Specify a regular expression of suffixes that are allowed in the\n  file-to-main-include mapping.</p>\n<p>  When guessing whether a #include is the &quot;main&quot; include (to assign\n  category 0, see above), use this regex of allowed suffixes to the header\n  stem. A partial match is done, so that:</p>\n<ul>\n<li>&quot;&quot; means &quot;arbitrary suffix&quot;</li>\n<li><p>&quot;$&quot; means &quot;no suffix&quot;</p>\n<p>For example, if configured to &quot;(_test)?$&quot;, then a header a.h would be seen\nas the &quot;main&quot; include in both a.cc and a_test.cc.</p>\n</li>\n</ul>\n"
        },
        "IndentCaseLabels": {
            "type": "bool",
            "doc": "<p>  Indent case labels one level from the switch statement.</p>\n<p>  When <code>false</code>, use the same indentation level as for the switch statement.\n  Switch statement body is always indented one level more than case labels.</p>\n<pre><code class=\"lang-  \">     false:                                 true:\n     switch (fool) {                vs.     switch (fool) {\n     case 1:                                  case 1:\n       bar();                                   bar();\n       break;                                   break;\n     default:                                 default:\n       plop();                                  plop();\n     }                                      }\n</code></pre>\n"
        },
        "IndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns to use for indentation.</p>\n<pre><code class=\"lang-  \">     IndentWidth: 3\n</code></pre>\n<pre><code> void f() {\n    someFunction();\n    if (true, false) {\n       f();\n    }\n }\n</code></pre>"
        },
        "IndentWrappedFunctionNames": {
            "type": "bool",
            "doc": "<p>  Indent if a function definition or declaration is wrapped after the\n  type.</p>\n<pre><code class=\"lang-  \">     true:\n     LoooooooooooooooooooooooooooooooooooooooongReturnType\n         LoooooooooooooooooooooooooooooooongFunctionDeclaration();\n</code></pre>\n<pre><code> false:\n LoooooooooooooooooooooooooooooooooooooooongReturnType\n LoooooooooooooooooooooooooooooooongFunctionDeclaration();\n</code></pre>"
        },
        "JavaScriptQuotes": {
            "type": "JavaScriptQuoteStyle",
            "doc": "<p>  The JavaScriptQuoteStyle to use for JavaScript strings.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>JSQS_Leave</code> (in configuration: <code>Leave</code>)\nLeave string quotes as they are.</p>\n<pre><code>   string1 = &quot;foo&quot;;\n   string2 = &#39;bar&#39;;\n</code></pre></li>\n<li><p><code>JSQS_Single</code> (in configuration: <code>Single</code>)\nAlways use single quotes.</p>\n<pre><code>   string1 = &#39;foo&#39;;\n   string2 = &#39;bar&#39;;\n</code></pre></li>\n<li><p><code>JSQS_Double</code> (in configuration: <code>Double</code>)\nAlways use double quotes.</p>\n<pre><code>   string1 = &quot;foo&quot;;\n   string2 = &quot;bar&quot;;\n</code></pre></li>\n</ul>\n",
            "options": [
                "Leave",
                "Single",
                "Double"
            ]
        },
        "JavaScriptWrapImports": {
            "type": "bool",
            "doc": "<p>  Whether to wrap JavaScript import/export statements.</p>\n<pre><code class=\"lang-  \">     true:\n     import {\n         VeryLongImportsAreAnnoying,\n         VeryLongImportsAreAnnoying,\n         VeryLongImportsAreAnnoying,\n     } from &#39;some/module.js&#39;\n</code></pre>\n<pre><code> false:\n import {VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying,} from &quot;some/module.js&quot;\n</code></pre>"
        },
        "KeepEmptyLinesAtTheStartOfBlocks": {
            "type": "bool",
            "doc": "<p>  If true, the empty line at the start of blocks is kept.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     if (foo) {                     vs.     if (foo) {\n                                              bar();\n       bar();                               }\n     }\n</code></pre>\n"
        },
        "Language": {
            "type": "LanguageKind",
            "doc": "<p>  Language, this format style is targeted at.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>LK_None</code> (in configuration: <code>None</code>)\nDo not use.</p>\n</li>\n<li><p><code>LK_Cpp</code> (in configuration: <code>Cpp</code>)\nShould be used for C, C++.</p>\n</li>\n<li><p><code>LK_Java</code> (in configuration: <code>Java</code>)\nShould be used for Java.</p>\n</li>\n<li><p><code>LK_JavaScript</code> (in configuration: <code>JavaScript</code>)\nShould be used for JavaScript.</p>\n</li>\n<li><p><code>LK_ObjC</code> (in configuration: <code>ObjC</code>)\nShould be used for Objective-C, Objective-C++.</p>\n</li>\n<li><p><code>LK_Proto</code> (in configuration: <code>Proto</code>)\nShould be used for Protocol Buffers\n(https://developers.google.com/protocol-buffers/).</p>\n</li>\n<li><p><code>LK_TableGen</code> (in configuration: <code>TableGen</code>)\nShould be used for TableGen code.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "Cpp",
                "Java",
                "JavaScript",
                "ObjC",
                "Proto",
                "TableGen"
            ]
        },
        "MacroBlockBegin": {
            "type": "std::string",
            "doc": "<p>  A regular expression matching macros that start a block.</p>\n<pre><code class=\"lang-  \">     # With:\n     MacroBlockBegin: &quot;^NS_MAP_BEGIN|\\\n     NS_TABLE_HEAD$&quot;\n     MacroBlockEnd: &quot;^\\\n     NS_MAP_END|\\\n     NS_TABLE_.*_END$&quot;\n</code></pre>\n<pre><code> NS_MAP_BEGIN\n   foo();\n NS_MAP_END\n\n NS_TABLE_HEAD\n   bar();\n NS_TABLE_FOO_END\n\n # Without:\n NS_MAP_BEGIN\n foo();\n NS_MAP_END\n\n NS_TABLE_HEAD\n bar();\n NS_TABLE_FOO_END\n</code></pre>"
        },
        "MacroBlockEnd": {
            "type": "std::string",
            "doc": "<p>  A regular expression matching macros that end a block.</p>\n"
        },
        "MaxEmptyLinesToKeep": {
            "type": "unsigned",
            "doc": "<p>  The maximum number of consecutive empty lines to keep.</p>\n<pre><code class=\"lang-  \">     MaxEmptyLinesToKeep: 1         vs.     MaxEmptyLinesToKeep: 0\n     int f() {                              int f() {\n       int = 1;                                 int i = 1;\n                                                i = foo();\n       i = foo();                               return i;\n                                            }\n       return i;\n     }\n</code></pre>\n"
        },
        "NamespaceIndentation": {
            "type": "NamespaceIndentationKind",
            "doc": "<p>  The indentation used for namespaces.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>NI_None</code> (in configuration: <code>None</code>)\nDon&#39;t indent in namespaces.</p>\n<pre><code>   namespace out {\n   int i;\n   namespace in {\n   int i;\n   }\n   }\n</code></pre></li>\n<li><p><code>NI_Inner</code> (in configuration: <code>Inner</code>)\nIndent only in inner namespaces (nested in other namespaces).</p>\n<pre><code>   namespace out {\n   int i;\n   namespace in {\n     int i;\n   }\n   }\n</code></pre></li>\n<li><p><code>NI_All</code> (in configuration: <code>All</code>)\nIndent in all namespaces.</p>\n<pre><code>   namespace out {\n     int i;\n     namespace in {\n       int i;\n     }\n   }\n</code></pre></li>\n</ul>\n",
            "options": [
                "None",
                "Inner",
                "All"
            ]
        },
        "ObjCBlockIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of ObjC blocks.</p>\n<pre><code class=\"lang-  \">     ObjCBlockIndentWidth: 4\n</code></pre>\n<pre><code> [operation setCompletionBlock:^{\n     [self onOperationDone];\n }];\n</code></pre>"
        },
        "ObjCSpaceAfterProperty": {
            "type": "bool",
            "doc": "<p>  Add a space after <code>@property</code> in Objective-C, i.e. use\n  <code>@property (readonly)</code> instead of <code>@property(readonly)</code>.</p>\n"
        },
        "ObjCSpaceBeforeProtocolList": {
            "type": "bool",
            "doc": "<p>  Add a space in front of an Objective-C protocol list, i.e. use\n  <code>Foo &lt;Protocol&gt;</code> instead of <code>Foo&lt;Protocol&gt;</code>.</p>\n"
        },
        "PenaltyBreakAssignment": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking around an assignment operator.</p>\n"
        },
        "PenaltyBreakBeforeFirstCallParameter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking a function call after <code>call(</code>.</p>\n"
        },
        "PenaltyBreakComment": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a comment.</p>\n"
        },
        "PenaltyBreakFirstLessLess": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking before the first <code>&lt;&lt;</code>.</p>\n"
        },
        "PenaltyBreakString": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a string literal.</p>\n"
        },
        "PenaltyExcessCharacter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each character outside of the column limit.</p>\n"
        },
        "PenaltyReturnTypeOnItsOwnLine": {
            "type": "unsigned",
            "doc": "<p>  Penalty for putting the return type of a function onto its own\n  line.</p>\n"
        },
        "PointerAlignment": {
            "type": "PointerAlignmentStyle",
            "doc": "<p>  Pointer and reference alignment style.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>PAS_Left</code> (in configuration: <code>Left</code>)\nAlign pointer to the left.</p>\n<pre><code>  int* a;\n</code></pre></li>\n<li><p><code>PAS_Right</code> (in configuration: <code>Right</code>)\nAlign pointer to the right.</p>\n<pre><code>  int *a;\n</code></pre></li>\n<li><p><code>PAS_Middle</code> (in configuration: <code>Middle</code>)\nAlign pointer in the middle.</p>\n<pre><code>  int * a;\n</code></pre></li>\n</ul>\n",
            "options": [
                "Left",
                "Right",
                "Middle"
            ]
        },
        "ReflowComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format will attempt to re-flow comments.</p>\n<pre><code class=\"lang-  \">     false:\n     // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information\n     /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */\n</code></pre>\n<pre><code> true:\n // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of\n // information\n /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of\n  * information */\n</code></pre>"
        },
        "SortIncludes": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format will sort <code>#includes</code>.</p>\n<pre><code class=\"lang-  \">     false:                                 true:\n     #include &quot;b.h&quot;                 vs.     #include &quot;a.h&quot;\n     #include &quot;a.h&quot;                         #include &quot;b.h&quot;\n</code></pre>\n"
        },
        "SortUsingDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format will sort using declarations.</p>\n<pre><code class=\"lang-  \">     false:                                 true:\n     using std::cout;               vs.     using std::cin;\n     using std::cin;                        using std::cout;\n</code></pre>\n"
        },
        "SpaceAfterCStyleCast": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, a space is inserted after C style casts.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     (int)i;                        vs.     (int) i;\n</code></pre>\n"
        },
        "SpaceAfterTemplateKeyword": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, a space will be inserted after the &#39;template&#39; keyword.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     template &lt;int&gt; void foo();     vs.     template&lt;int&gt; void foo();\n</code></pre>\n"
        },
        "SpaceBeforeAssignmentOperators": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, spaces will be removed before assignment operators.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     int a = 5;                     vs.     int a=5;\n     a += 42                                a+=42;\n</code></pre>\n"
        },
        "SpaceBeforeParens": {
            "type": "SpaceBeforeParensOptions",
            "doc": "<p>  Defines in which cases to put a space before opening parentheses.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>SBPO_Never</code> (in configuration: <code>Never</code>)\nNever put a space before opening parentheses.</p>\n<pre><code>   void f() {\n     if(true) {\n       f();\n     }\n   }\n</code></pre></li>\n<li><p><code>SBPO_ControlStatements</code> (in configuration: <code>ControlStatements</code>)\nPut a space before opening parentheses only after control statement\nkeywords (<code>for/if/while...</code>).</p>\n<pre><code>   void f() {\n     if (true) {\n       f();\n     }\n   }\n</code></pre></li>\n<li><p><code>SBPO_Always</code> (in configuration: <code>Always</code>)\nAlways put a space before opening parentheses, except when it&#39;s\nprohibited by the syntax rules (in function-like macro definitions) or\nwhen determined by other style rules (after unary operators, opening\nparentheses, etc.)</p>\n<pre><code>   void f () {\n     if (true) {\n       f ();\n     }\n   }\n</code></pre></li>\n</ul>\n",
            "options": [
                "Never",
                "ControlStatements",
                "Always"
            ]
        },
        "SpaceInEmptyParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into <code>()</code>.</p>\n<pre><code class=\"lang-  \">     true:                                false:\n     void f( ) {                    vs.   void f() {\n       int x[] = {foo( ), bar( )};          int x[] = {foo(), bar()};\n       if (true) {                          if (true) {\n         f( );                                f();\n       }                                    }\n     }                                    }\n</code></pre>\n"
        },
        "SpacesBeforeTrailingComments": {
            "type": "unsigned",
            "doc": "<p>  The number of spaces before trailing line comments\n  (<code>//</code> - comments).</p>\n<p>  This does not affect trailing block comments (<code>/*</code> - comments) as\n  those commonly have different usage patterns and a number of special\n  cases.</p>\n<pre><code class=\"lang-  \">     SpacesBeforeTrailingComments: 3\n     void f() {\n       if (true) {   // foo1\n         f();        // bar\n       }             // foo\n     }\n</code></pre>\n"
        },
        "SpacesInAngles": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>&lt;</code> and before <code>&gt;</code>\n  in template argument lists.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     static_cast&lt; int &gt;(arg);       vs.     static_cast&lt;int&gt;(arg);\n     std::function&lt; void(int) &gt; fct;        std::function&lt;void(int)&gt; fct;\n</code></pre>\n"
        },
        "SpacesInCStyleCastParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into C style casts.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     x = ( int32 )y                 vs.     x = (int32)y\n</code></pre>\n"
        },
        "SpacesInContainerLiterals": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces are inserted inside container literals (e.g.\n  ObjC and Javascript array and dict literals).</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     var arr = [ 1, 2, 3 ];         vs.     var arr = [1, 2, 3];\n     f({a : 1, b : 2, c : 3});              f({a: 1, b: 2, c: 3});\n</code></pre>\n"
        },
        "SpacesInParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>(</code> and before <code>)</code>.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     t f( Deleted &amp; ) &amp; = delete;   vs.     t f(Deleted &amp;) &amp; = delete;\n</code></pre>\n"
        },
        "SpacesInSquareBrackets": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>[</code> and before <code>]</code>.\n  Lambdas or unspecified size array declarations will not be affected.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     int a[ 5 ];                    vs.     int a[5];\n     std::unique_ptr&lt;int[]&gt; foo() {} // Won&#39;t be affected\n</code></pre>\n"
        },
        "Standard": {
            "type": "LanguageStandard",
            "doc": "<p>  Format compatible with this standard, e.g. use <code>A&lt;A&lt;int&gt; &gt;</code>\n  instead of <code>A&lt;A&lt;int&gt;&gt;</code> for <code>LS_Cpp03</code>.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>LS_Cpp03</code> (in configuration: <code>Cpp03</code>)\nUse C++03-compatible syntax.</p>\n</li>\n<li><p><code>LS_Cpp11</code> (in configuration: <code>Cpp11</code>)\nUse features of C++11, C++14 and C++1z (e.g. <code>A&lt;A&lt;int&gt;&gt;</code> instead of\n<code>A&lt;A&lt;int&gt; &gt;</code>).</p>\n</li>\n<li><p><code>LS_Auto</code> (in configuration: <code>Auto</code>)\nAutomatic detection based on the input.</p>\n</li>\n</ul>\n",
            "options": [
                "Cpp03",
                "Cpp11",
                "Auto"
            ]
        },
        "TabWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns used for tab stops.</p>\n"
        },
        "UseTab": {
            "type": "UseTabStyle",
            "doc": "<p>  The way to use tab characters in the resulting file.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>UT_Never</code> (in configuration: <code>Never</code>)\nNever use tab.</p>\n</li>\n<li><p><code>UT_ForIndentation</code> (in configuration: <code>ForIndentation</code>)\nUse tabs only for indentation.</p>\n</li>\n<li><p><code>UT_ForContinuationAndIndentation</code> (in configuration: <code>ForContinuationAndIndentation</code>)\nUse tabs only for line continuation and indentation.</p>\n</li>\n<li><p><code>UT_Always</code> (in configuration: <code>Always</code>)\nUse tabs whenever we need to fill whitespace that spans at least from\none tab stop to the next one.</p>\n</li>\n</ul>\n",
            "options": [
                "Never",
                "ForIndentation",
                "ForContinuationAndIndentation",
                "Always"
            ]
        }
    },
    "5.0.1": {
        "BasedOnStyle": {
            "type": "string",
            "doc": "<p>  The style used for all options not specifically set in the configuration.</p>\n<p>  This option is supported only in the <strong>clang-format</strong> configuration\n  (both within <code>-style=&#39;{...}&#39;</code> and the <code>.clang-format</code> file).</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LLVM</code>\nA style complying with the <a href=\"http://llvm.org/docs/CodingStandards.html\">LLVM coding standards</a></li>\n<li><code>Google</code>\nA style complying with <a href=\"http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml\">Google&#39;s C++ style guide</a></li>\n<li><code>Chromium</code>\nA style complying with <a href=\"http://www.chromium.org/developers/coding-style\">Chromium&#39;s style guide</a></li>\n<li><code>Mozilla</code>\nA style complying with <a href=\"https://developer.mozilla.org/en-US/docs/Developer_Guide/Coding_Style\">Mozilla&#39;s style guide</a></li>\n<li><code>WebKit</code>\nA style complying with <a href=\"http://www.webkit.org/coding/coding-style.html\">WebKit&#39;s style guide</a></li>\n</ul>\n",
            "options": [
                "LLVM",
                "Google",
                "Chromium",
                "Mozilla",
                "WebKit"
            ]
        },
        "AccessModifierOffset": {
            "type": "int",
            "doc": "<p>  The extra indent or outdent of access modifiers, e.g. <code>public:</code>.</p>\n"
        },
        "AlignAfterOpenBracket": {
            "type": "BracketAlignmentStyle",
            "doc": "<p>  If <code>true</code>, horizontally aligns arguments after an open bracket.</p>\n<p>  This applies to round brackets (parentheses), angle brackets and square\n  brackets.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BAS_Align</code> (in configuration: <code>Align</code>)\nAlign parameters on the open bracket, e.g.:</p>\n<pre><code>  someLongFunction(argument1,\n                   argument2);\n</code></pre></li>\n<li><p><code>BAS_DontAlign</code> (in configuration: <code>DontAlign</code>)\nDon&#39;t align, instead use <code>ContinuationIndentWidth</code>, e.g.:</p>\n<pre><code>  someLongFunction(argument1,\n      argument2);\n</code></pre></li>\n<li><p><code>BAS_AlwaysBreak</code> (in configuration: <code>AlwaysBreak</code>)\nAlways break after an open bracket, if the parameters don&#39;t fit\non a single line, e.g.:</p>\n<pre><code>  someLongFunction(\n      argument1, argument2);\n</code></pre></li>\n</ul>\n",
            "options": [
                "Align",
                "DontAlign",
                "AlwaysBreak"
            ]
        },
        "AlignConsecutiveAssignments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns consecutive assignments.</p>\n<p>  This will align the assignment operators of consecutive lines. This\n  will result in formattings like</p>\n<pre><code class=\"lang-  \">    int aaaa = 12;\n    int b    = 23;\n    int ccc  = 23;\n</code></pre>\n"
        },
        "AlignConsecutiveDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns consecutive declarations.</p>\n<p>  This will align the declaration names of consecutive lines. This\n  will result in formattings like</p>\n<pre><code class=\"lang-  \">    int         aaaa = 12;\n    float       b = 23;\n    std::string ccc = 23;\n</code></pre>\n"
        },
        "AlignEscapedNewlines": {
            "type": "EscapedNewlineAlignmentStyle",
            "doc": "<p>  Options for aligning backslashes in escaped newlines.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>ENAS_DontAlign</code> (in configuration: <code>DontAlign</code>)\nDon&#39;t align escaped newlines.</p>\n<pre><code>  #define A \\\n    int aaaa; \\\n    int b; \\\n    int dddddddddd;\n</code></pre></li>\n<li><p><code>ENAS_Left</code> (in configuration: <code>Left</code>)\nAlign escaped newlines as far left as possible.</p>\n<pre><code>  true:\n  #define A   \\\n    int aaaa; \\\n    int b;    \\\n    int dddddddddd;\n</code></pre><p>  false:</p>\n</li>\n<li><p><code>ENAS_Right</code> (in configuration: <code>Right</code>)\nAlign escaped newlines in the right-most column.</p>\n<pre><code>  #define A                                                                      \\\n    int aaaa;                                                                    \\\n    int b;                                                                       \\\n    int dddddddddd;\n</code></pre></li>\n</ul>\n",
            "options": [
                "DontAlign",
                "Left",
                "Right"
            ]
        },
        "AlignOperands": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, horizontally align operands of binary and ternary\n  expressions.</p>\n<p>  Specifically, this aligns operands of a single expression that needs to be\n  split over multiple lines, e.g.:</p>\n<pre><code class=\"lang-  \">    int aaa = bbbbbbbbbbbbbbb +\n              ccccccccccccccc;\n</code></pre>\n"
        },
        "AlignTrailingComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns trailing comments.</p>\n<pre><code class=\"lang-  \">    true:                                   false:\n    int a;     // My comment a      vs.     int a; // My comment a\n    int b = 2; // comment  b                int b = 2; // comment about b\n</code></pre>\n"
        },
        "AllowAllParametersOfDeclarationOnNextLine": {
            "type": "bool",
            "doc": "<p>  Allow putting all parameters of a function declaration onto\n  the next line even if <code>BinPackParameters</code> is <code>false</code>.</p>\n<pre><code class=\"lang-  \">    true:                                   false:\n    myFunction(foo,                 vs.     myFunction(foo, bar, plop);\n               bar,\n               plop);\n</code></pre>\n"
        },
        "AllowShortBlocksOnASingleLine": {
            "type": "bool",
            "doc": "<p>  Allows contracting simple braced statements to a single line.</p>\n<p>  E.g., this allows <code>if (a) { return; }</code> to be put on a single line.</p>\n"
        },
        "AllowShortCaseLabelsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, short case labels will be contracted to a single line.</p>\n<pre><code class=\"lang-  \">    true:                                   false:\n    switch (a) {                    vs.     switch (a) {\n    case 1: x = 1; break;                   case 1:\n    case 2: return;                           x = 1;\n    }                                         break;\n                                            case 2:\n                                              return;\n                                            }\n</code></pre>\n"
        },
        "AllowShortFunctionsOnASingleLine": {
            "type": "ShortFunctionStyle",
            "doc": "<p>  Dependent on the value, <code>int f() { return 0; }</code> can be put on a\n  single line.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>SFS_None</code> (in configuration: <code>None</code>)\nNever merge functions into a single line.</p>\n</li>\n<li><p><code>SFS_InlineOnly</code> (in configuration: <code>InlineOnly</code>)\nOnly merge functions defined inside a class. Same as &quot;inline&quot;,\nexcept it does not implies &quot;empty&quot;: i.e. top level empty functions\nare not merged either.</p>\n<pre><code>  class Foo {\n    void f() { foo(); }\n  };\n  void f() {\n    foo();\n  }\n  void f() {\n  }\n</code></pre></li>\n<li><p><code>SFS_Empty</code> (in configuration: <code>Empty</code>)\nOnly merge empty functions.</p>\n<pre><code>  void f() {}\n  void f2() {\n    bar2();\n  }\n</code></pre></li>\n<li><p><code>SFS_Inline</code> (in configuration: <code>Inline</code>)\nOnly merge functions defined inside a class. Implies &quot;empty&quot;.</p>\n<pre><code>  class Foo {\n    void f() { foo(); }\n  };\n  void f() {\n    foo();\n  }\n  void f() {}\n</code></pre></li>\n<li><p><code>SFS_All</code> (in configuration: <code>All</code>)\nMerge all functions fitting on a single line.</p>\n<pre><code>  class Foo {\n    void f() { foo(); }\n  };\n  void f() { bar(); }\n</code></pre></li>\n</ul>\n",
            "options": [
                "None",
                "InlineOnly",
                "Empty",
                "Inline",
                "All"
            ]
        },
        "AllowShortIfStatementsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>if (a) return;</code> can be put on a single line.</p>\n"
        },
        "AllowShortLoopsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>while (true) continue;</code> can be put on a single\n  line.</p>\n"
        },
        "AlwaysBreakAfterDefinitionReturnType": {
            "type": "DefinitionReturnTypeBreakingStyle",
            "doc": "<p>  The function definition return type breaking style to use.  This\n  option is <strong>deprecated</strong> and is retained for backwards compatibility.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>DRTBS_None</code> (in configuration: <code>None</code>)\nBreak after return type automatically.\n<code>PenaltyReturnTypeOnItsOwnLine</code> is taken into account.</p>\n</li>\n<li><p><code>DRTBS_All</code> (in configuration: <code>All</code>)\nAlways break after the return type.</p>\n</li>\n<li><p><code>DRTBS_TopLevel</code> (in configuration: <code>TopLevel</code>)\nAlways break after the return types of top-level functions.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "All",
                "TopLevel"
            ]
        },
        "AlwaysBreakAfterReturnType": {
            "type": "ReturnTypeBreakingStyle",
            "doc": "<p>  The function declaration return type breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>RTBS_None</code> (in configuration: <code>None</code>)\nBreak after return type automatically.\n<code>PenaltyReturnTypeOnItsOwnLine</code> is taken into account.</p>\n<pre><code>  class A {\n    int f() { return 0; };\n  };\n  int f();\n  int f() { return 1; }\n</code></pre></li>\n<li><p><code>RTBS_All</code> (in configuration: <code>All</code>)\nAlways break after the return type.</p>\n<pre><code>  class A {\n    int\n    f() {\n      return 0;\n    };\n  };\n  int\n  f();\n  int\n  f() {\n    return 1;\n  }\n</code></pre></li>\n<li><p><code>RTBS_TopLevel</code> (in configuration: <code>TopLevel</code>)\nAlways break after the return types of top-level functions.</p>\n<pre><code>  class A {\n    int f() { return 0; };\n  };\n  int\n  f();\n  int\n  f() {\n    return 1;\n  }\n</code></pre></li>\n<li><p><code>RTBS_AllDefinitions</code> (in configuration: <code>AllDefinitions</code>)\nAlways break after the return type of function definitions.</p>\n<pre><code>  class A {\n    int\n    f() {\n      return 0;\n    };\n  };\n  int f();\n  int\n  f() {\n    return 1;\n  }\n</code></pre></li>\n<li><p><code>RTBS_TopLevelDefinitions</code> (in configuration: <code>TopLevelDefinitions</code>)\nAlways break after the return type of top-level definitions.</p>\n<pre><code>  class A {\n    int f() { return 0; };\n  };\n  int f();\n  int\n  f() {\n    return 1;\n  }\n</code></pre></li>\n</ul>\n",
            "options": [
                "None",
                "All",
                "TopLevel",
                "AllDefinitions",
                "TopLevelDefinitions"
            ]
        },
        "AlwaysBreakBeforeMultilineStrings": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break before multiline string literals.</p>\n<p>  This flag is mean to make cases where there are multiple multiline strings\n  in a file look more consistent. Thus, it will only take effect if wrapping\n  the string at that point leads to it being indented\n  <code>ContinuationIndentWidth</code> spaces from the start of the line.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     aaaa =                         vs.     aaaa = &quot;bbbb&quot;\n         &quot;bbbb&quot;                                    &quot;cccc&quot;;\n         &quot;cccc&quot;;\n</code></pre>\n"
        },
        "AlwaysBreakTemplateDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break after the <code>template&lt;...&gt;</code> of a template\n  declaration.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     template &lt;typename T&gt;          vs.     template &lt;typename T&gt; class C {};\n     class C {};\n</code></pre>\n"
        },
        "BinPackArguments": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function call&#39;s arguments will either be all on the\n  same line or will have one line each.</p>\n<pre><code class=\"lang-  \">    true:\n    void f() {\n      f(aaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaa,\n        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\n    }\n</code></pre>\n<pre><code>false:\nvoid f() {\n  f(aaaaaaaaaaaaaaaaaaaa,\n    aaaaaaaaaaaaaaaaaaaa,\n    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\n}\n</code></pre>"
        },
        "BinPackParameters": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function declaration&#39;s or function definition&#39;s\n  parameters will either all be on the same line or will have one line each.</p>\n<pre><code class=\"lang-  \">    true:\n    void f(int aaaaaaaaaaaaaaaaaaaa, int aaaaaaaaaaaaaaaaaaaa,\n           int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\n</code></pre>\n<pre><code>false:\nvoid f(int aaaaaaaaaaaaaaaaaaaa,\n       int aaaaaaaaaaaaaaaaaaaa,\n       int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\n</code></pre>"
        },
        "BraceWrapping": {
            "type": "BraceWrappingFlags",
            "doc": "<p>  Control of individual brace wrapping cases.</p>\n<p>  If <code>BreakBeforeBraces</code> is set to <code>BS_Custom</code>, use this to specify how\n  each individual brace case should be handled. Otherwise, this is ignored.</p>\n<p>  Nested configuration flags:</p>\n<ul>\n<li><p><code>bool AfterClass</code> Wrap class definitions.</p>\n<pre><code>  true:\n  class foo {};\n</code></pre><p>  false:\n  class foo\n  {};</p>\n</li>\n<li><p><code>bool AfterControlStatement</code> Wrap control statements (<code>if</code>/<code>for</code>/<code>while</code>/<code>switch</code>/..).</p>\n<pre><code>  true:\n  if (foo())\n  {\n  } else\n  {}\n  for (int i = 0; i &lt; 10; ++i)\n  {}\n</code></pre><p>  false:\n  if (foo()) {\n  } else {\n  }\n  for (int i = 0; i &lt; 10; ++i) {\n  }</p>\n</li>\n<li><p><code>bool AfterEnum</code> Wrap enum definitions.</p>\n<pre><code>  true:\n  enum X : int\n  {\n    B\n  };\n</code></pre><p>  false:\n  enum X : int { B };</p>\n</li>\n<li><p><code>bool AfterFunction</code> Wrap function definitions.</p>\n<pre><code>  true:\n  void foo()\n  {\n    bar();\n    bar2();\n  }\n</code></pre><p>  false:\n  void foo() {</p>\n<pre><code>bar();\nbar2();\n</code></pre><p>  }</p>\n</li>\n<li><p><code>bool AfterNamespace</code> Wrap namespace definitions.</p>\n<pre><code>  true:\n  namespace\n  {\n  int foo();\n  int bar();\n  }\n</code></pre><p>  false:\n  namespace {\n  int foo();\n  int bar();\n  }</p>\n</li>\n<li><p><code>bool AfterObjCDeclaration</code> Wrap ObjC definitions (<code>@autoreleasepool</code>, interfaces, ..).</p>\n</li>\n<li><p><code>bool AfterStruct</code> Wrap struct definitions.</p>\n<pre><code>  true:\n  struct foo\n  {\n    int x;\n  };\n</code></pre><p>  false:\n  struct foo {</p>\n<pre><code>int x;\n</code></pre><p>  };</p>\n</li>\n<li><p><code>bool AfterUnion</code> Wrap union definitions.</p>\n<pre><code>  true:\n  union foo\n  {\n    int x;\n  }\n</code></pre><p>  false:\n  union foo {</p>\n<pre><code>int x;\n</code></pre><p>  }</p>\n</li>\n<li><p><code>bool BeforeCatch</code> Wrap before <code>catch</code>.</p>\n<pre><code>  true:\n  try {\n    foo();\n  }\n  catch () {\n  }\n</code></pre><p>  false:\n  try {</p>\n<pre><code>foo();\n</code></pre><p>  } catch () {\n  }</p>\n</li>\n<li><p><code>bool BeforeElse</code> Wrap before <code>else</code>.</p>\n<pre><code>  true:\n  if (foo()) {\n  }\n  else {\n  }\n</code></pre><p>  false:\n  if (foo()) {\n  } else {\n  }</p>\n</li>\n<li><p><code>bool IndentBraces</code> Indent the wrapped braces themselves.</p>\n</li>\n<li><p><code>bool SplitEmptyFunctionBody</code> If <code>false</code>, empty function body can be put on a single line.\nThis option is used only if the opening brace of the function has\nalready been wrapped, i.e. the `AfterFunction` brace wrapping mode is\nset, and the function could/should not be put on a single line (as per\n`AllowShortFunctionsOnASingleLine` and constructor formatting options).</p>\n<pre><code>  int f()   vs.   inf f()\n  {}              {\n                  }\n</code></pre></li>\n</ul>\n",
            "options": [
                "AfterClass",
                "AfterControlStatement",
                "AfterEnum",
                "AfterFunction",
                "AfterNamespace",
                "AfterObjCDeclaration",
                "AfterStruct",
                "AfterUnion",
                "BeforeCatch",
                "BeforeElse",
                "IndentBraces",
                "SplitEmptyFunctionBody"
            ]
        },
        "BreakAfterJavaFieldAnnotations": {
            "type": "bool",
            "doc": "<p>  Break after each annotation on a field in Java files.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     @Partial                       vs.     @Partial @Mock DataLoad loader;\n     @Mock\n     DataLoad loader;\n</code></pre>\n"
        },
        "BreakBeforeBinaryOperators": {
            "type": "BinaryOperatorStyle",
            "doc": "<p>  The way to wrap binary operators.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BOS_None</code> (in configuration: <code>None</code>)\nBreak after operators.</p>\n<pre><code>   LooooooooooongType loooooooooooooooooooooongVariable =\n       someLooooooooooooooooongFunction();\n</code></pre><p>   bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +</p>\n<pre><code>                    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==\n                aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &amp;&amp;\n            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &gt;\n                ccccccccccccccccccccccccccccccccccccccccc;\n</code></pre></li>\n<li><p><code>BOS_NonAssignment</code> (in configuration: <code>NonAssignment</code>)\nBreak before operators that aren&#39;t assignments.</p>\n<pre><code>   LooooooooooongType loooooooooooooooooooooongVariable =\n       someLooooooooooooooooongFunction();\n</code></pre><p>   bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</p>\n<pre><code>                    + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n                == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n            &amp;&amp; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n                   &gt; ccccccccccccccccccccccccccccccccccccccccc;\n</code></pre></li>\n<li><p><code>BOS_All</code> (in configuration: <code>All</code>)\nBreak before operators.</p>\n<pre><code>   LooooooooooongType loooooooooooooooooooooongVariable\n       = someLooooooooooooooooongFunction();\n</code></pre><p>   bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</p>\n<pre><code>                    + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n                == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n            &amp;&amp; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n                   &gt; ccccccccccccccccccccccccccccccccccccccccc;\n</code></pre></li>\n</ul>\n",
            "options": [
                "None",
                "NonAssignment",
                "All"
            ]
        },
        "BreakBeforeBraces": {
            "type": "BraceBreakingStyle",
            "doc": "<p>  The brace breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BS_Attach</code> (in configuration: <code>Attach</code>)\nAlways attach braces to surrounding context.</p>\n<pre><code>  try {\n    foo();\n  } catch () {\n  }\n  void foo() { bar(); }\n  class foo {};\n  if (foo()) {\n  } else {\n  }\n  enum X : int { A, B };\n</code></pre></li>\n<li><p><code>BS_Linux</code> (in configuration: <code>Linux</code>)\nLike <code>Attach</code>, but break before braces on function, namespace and\nclass definitions.</p>\n<pre><code>  try {\n    foo();\n  } catch () {\n  }\n  void foo() { bar(); }\n  class foo\n  {\n  };\n  if (foo()) {\n  } else {\n  }\n  enum X : int { A, B };\n</code></pre></li>\n<li><p><code>BS_Mozilla</code> (in configuration: <code>Mozilla</code>)\nLike <code>Attach</code>, but break before braces on enum, function, and record\ndefinitions.</p>\n<pre><code>  try {\n    foo();\n  } catch () {\n  }\n  void foo() { bar(); }\n  class foo\n  {\n  };\n  if (foo()) {\n  } else {\n  }\n  enum X : int { A, B };\n</code></pre></li>\n<li><p><code>BS_Stroustrup</code> (in configuration: <code>Stroustrup</code>)\nLike <code>Attach</code>, but break before function definitions, <code>catch</code>, and\n<code>else</code>.</p>\n<pre><code>  try {\n    foo();\n  } catch () {\n  }\n  void foo() { bar(); }\n  class foo\n  {\n  };\n  if (foo()) {\n  } else {\n  }\n  enum X : int\n  {\n    A,\n    B\n  };\n</code></pre></li>\n<li><p><code>BS_Allman</code> (in configuration: <code>Allman</code>)\nAlways break before braces.</p>\n<pre><code>  try {\n    foo();\n  }\n  catch () {\n  }\n  void foo() { bar(); }\n  class foo {\n  };\n  if (foo()) {\n  }\n  else {\n  }\n  enum X : int { A, B };\n</code></pre></li>\n<li><p><code>BS_GNU</code> (in configuration: <code>GNU</code>)\nAlways break before braces and add an extra level of indentation to\nbraces of control statements, not to those of class, function\nor other definitions.</p>\n<pre><code>  try\n    {\n      foo();\n    }\n  catch ()\n    {\n    }\n  void foo() { bar(); }\n  class foo\n  {\n  };\n  if (foo())\n    {\n    }\n  else\n    {\n    }\n  enum X : int\n  {\n    A,\n    B\n  };\n</code></pre></li>\n<li><p><code>BS_WebKit</code> (in configuration: <code>WebKit</code>)\nLike <code>Attach</code>, but break before functions.</p>\n<pre><code>  try {\n    foo();\n  } catch () {\n  }\n  void foo() { bar(); }\n  class foo {\n  };\n  if (foo()) {\n  } else {\n  }\n  enum X : int { A, B };\n</code></pre></li>\n<li><p><code>BS_Custom</code> (in configuration: <code>Custom</code>)\nConfigure each individual brace in `BraceWrapping`.</p>\n</li>\n</ul>\n",
            "options": [
                "Attach",
                "Linux",
                "Mozilla",
                "Stroustrup",
                "Allman",
                "GNU",
                "WebKit",
                "Custom"
            ]
        },
        "BreakBeforeInheritanceComma": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, in the class inheritance expression clang-format will\n  break before <code>:</code> and <code>,</code> if there is multiple inheritance.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     class MyClass                  vs.     class MyClass : public X, public Y {\n         : public X                         };\n         , public Y {\n     };\n</code></pre>\n"
        },
        "BreakBeforeTernaryOperators": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, ternary operators will be placed after line breaks.</p>\n<pre><code class=\"lang-  \">     true:\n     veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription\n         ? firstValue\n         : SecondValueVeryVeryVeryVeryLong;\n</code></pre>\n<pre><code> false:\n veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ?\n     firstValue :\n     SecondValueVeryVeryVeryVeryLong;\n</code></pre>"
        },
        "BreakConstructorInitializers": {
            "type": "BreakConstructorInitializersStyle",
            "doc": "<p>  The constructor initializers style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BCIS_BeforeColon</code> (in configuration: <code>BeforeColon</code>)\nBreak constructor initializers before the colon and after the commas.</p>\n<pre><code>Constructor()\n    : initializer1(),\n      initializer2()\n</code></pre></li>\n<li><p><code>BCIS_BeforeComma</code> (in configuration: <code>BeforeComma</code>)\nBreak constructor initializers before the colon and commas, and align\nthe commas with the colon.</p>\n<pre><code>Constructor()\n    : initializer1()\n    , initializer2()\n</code></pre></li>\n<li><p><code>BCIS_AfterColon</code> (in configuration: <code>AfterColon</code>)\nBreak constructor initializers after the colon and commas.</p>\n<pre><code>Constructor() :\n    initializer1(),\n    initializer2()\n</code></pre></li>\n</ul>\n",
            "options": [
                "BeforeColon",
                "BeforeComma",
                "AfterColon"
            ]
        },
        "BreakStringLiterals": {
            "type": "bool",
            "doc": "<p>  Allow breaking string literals when formatting.</p>\n"
        },
        "ColumnLimit": {
            "type": "unsigned",
            "doc": "<p>  The column limit.</p>\n<p>  A column limit of <code>0</code> means that there is no column limit. In this case,\n  clang-format will respect the input&#39;s line breaking decisions within\n  statements unless they contradict other rules.</p>\n"
        },
        "CommentPragmas": {
            "type": "std::string",
            "doc": "<p>  A regular expression that describes comments with special meaning,\n  which should not be split into lines or otherwise changed.</p>\n<pre><code class=\"lang-  \">     // CommentPragmas: &#39;^ FOOBAR pragma:&#39;\n     // Will leave the following line unaffected\n     #include &lt;vector&gt; // FOOBAR pragma: keep\n</code></pre>\n"
        },
        "CompactNamespaces": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, consecutive namespace declarations will be on the same\n  line. If <code>false</code>, each namespace is declared on a new line.</p>\n<pre><code class=\"lang-  \">    true:\n    namespace Foo { namespace Bar {\n    }}\n</code></pre>\n<pre><code>false:\nnamespace Foo {\nnamespace Bar {\n}\n}\n</code></pre><p>  If it does not fit on a single line, the overflowing namespaces get\n  wrapped:</p>\n<pre><code class=\"lang-  \">    namespace Foo { namespace Bar {\n    namespace Extra {\n    }}}\n</code></pre>\n"
        },
        "ConstructorInitializerAllOnOneLineOrOnePerLine": {
            "type": "bool",
            "doc": "<p>  If the constructor initializers don&#39;t fit on a line, put each\n  initializer on its own line.</p>\n<pre><code class=\"lang-  \">    true:\n    SomeClass::Constructor()\n        : aaaaaaaa(aaaaaaaa), aaaaaaaa(aaaaaaaa), aaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaa) {\n      return 0;\n    }\n</code></pre>\n<pre><code>false:\nSomeClass::Constructor()\n    : aaaaaaaa(aaaaaaaa), aaaaaaaa(aaaaaaaa),\n      aaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaa) {\n  return 0;\n}\n</code></pre>"
        },
        "ConstructorInitializerIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of constructor\n  initializer lists.</p>\n"
        },
        "ContinuationIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  Indent width for line continuations.</p>\n<pre><code class=\"lang-  \">     ContinuationIndentWidth: 2\n</code></pre>\n<pre><code> int i =         //  VeryVeryVeryVeryVeryLongComment\n   longFunction( // Again a long comment\n     arg);\n</code></pre>"
        },
        "Cpp11BracedListStyle": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, format braced lists as best suited for C++11 braced\n  lists.</p>\n<p>  Important differences:</p>\n<ul>\n<li>No spaces inside the braced list.</li>\n<li>No line break before the closing brace.</li>\n<li><p>Indentation with the continuation indent, not with the block indent.</p>\n<p>Fundamentally, C++11 braced lists are formatted exactly like function\ncalls would be formatted in their place. If the braced list follows a name\n(e.g. a type or variable name), clang-format formats as if the <code>{}</code> were\nthe parentheses of a function call with that name. If there is no name,\na zero-length name is assumed.</p>\n<pre><code> true:                                  false:\n vector&lt;int&gt; x{1, 2, 3, 4};     vs.     vector&lt;int&gt; x{ 1, 2, 3, 4 };\n vector&lt;T&gt; x{{}, {}, {}, {}};           vector&lt;T&gt; x{ {}, {}, {}, {} };\n f(MyMap[{composite, key}]);            f(MyMap[{ composite, key }]);\n new int[3]{1, 2, 3};                   new int[3]{ 1, 2, 3 };\n</code></pre></li>\n</ul>\n"
        },
        "DerivePointerAlignment": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, analyze the formatted file for the most common\n  alignment of <code>&amp;</code> and <code>*</code>.\n  Pointer and reference alignment styles are going to be updated according\n  to the preferences found in the file.\n  <code>PointerAlignment</code> is then used only as fallback.</p>\n"
        },
        "DisableFormat": {
            "type": "bool",
            "doc": "<p>  Disables formatting completely.</p>\n"
        },
        "ExperimentalAutoDetectBinPacking": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format detects whether function calls and\n  definitions are formatted with one parameter per line.</p>\n<p>  Each call can be bin-packed, one-per-line or inconclusive. If it is\n  inconclusive, e.g. completely on one line, but a decision needs to be\n  made, clang-format analyzes whether there are other bin-packed cases in\n  the input file and act accordingly.</p>\n<p>  NOTE: This is an experimental flag, that might go away or be renamed. Do\n  not use this in config files, etc. Use at your own risk.</p>\n"
        },
        "FixNamespaceComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format adds missing namespace end comments and\n  fixes invalid existing ones.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     namespace a {                  vs.     namespace a {\n     foo();                                 foo();\n     } // namespace a;                      }\n</code></pre>\n"
        },
        "ForEachMacros": {
            "type": "std::vector<std::string>",
            "doc": "<p>  A vector of macros that should be interpreted as foreach loops\n  instead of as function calls.</p>\n<p>  These are expected to be macros of the form:</p>\n<pre><code class=\"lang-  \">    FOREACH(&lt;variable-declaration&gt;, ...)\n      &lt;loop-body&gt;\n</code></pre>\n<p>  In the .clang-format configuration file, this can be configured like:</p>\n<pre><code class=\"lang-  \">    ForEachMacros: [&#39;RANGES_FOR&#39;, &#39;FOREACH&#39;]\n</code></pre>\n<p>  For example: BOOST_FOREACH.</p>\n"
        },
        "IncludeCategories": {
            "type": "std::vector<IncludeCategory>",
            "doc": "<p>  Regular expressions denoting the different <code>#include</code> categories\n  used for ordering <code>#includes</code>.</p>\n<p>  These regular expressions are matched against the filename of an include\n  (including the &lt;&gt; or &quot;&quot;) in order. The value belonging to the first\n  matching regular expression is assigned and <code>#includes</code> are sorted first\n  according to increasing category number and then alphabetically within\n  each category.</p>\n<p>  If none of the regular expressions match, INT_MAX is assigned as\n  category. The main header for a source file automatically gets category 0.\n  so that it is generally kept at the beginning of the <code>#includes</code>\n  (http://llvm.org/docs/CodingStandards.html#include-style). However, you\n  can also assign negative priorities if you have certain headers that\n  always need to be first.</p>\n<p>  To configure this in the .clang-format file, use:</p>\n<pre><code class=\"lang-  \">    IncludeCategories:\n      - Regex:           &#39;^&quot;(llvm|llvm-c|clang|clang-c)/&#39;\n        Priority:        2\n      - Regex:           &#39;^(&lt;|&quot;(gtest|isl|json)/)&#39;\n        Priority:        3\n      - Regex:           &#39;.*&#39;\n        Priority:        1\n</code></pre>\n",
            "options": []
        },
        "IncludeIsMainRegex": {
            "type": "std::string",
            "doc": "<p>  Specify a regular expression of suffixes that are allowed in the\n  file-to-main-include mapping.</p>\n<p>  When guessing whether a #include is the &quot;main&quot; include (to assign\n  category 0, see above), use this regex of allowed suffixes to the header\n  stem. A partial match is done, so that:</p>\n<ul>\n<li>&quot;&quot; means &quot;arbitrary suffix&quot;</li>\n<li><p>&quot;$&quot; means &quot;no suffix&quot;</p>\n<p>For example, if configured to &quot;(_test)?$&quot;, then a header a.h would be seen\nas the &quot;main&quot; include in both a.cc and a_test.cc.</p>\n</li>\n</ul>\n"
        },
        "IndentCaseLabels": {
            "type": "bool",
            "doc": "<p>  Indent case labels one level from the switch statement.</p>\n<p>  When <code>false</code>, use the same indentation level as for the switch statement.\n  Switch statement body is always indented one level more than case labels.</p>\n<pre><code class=\"lang-  \">     false:                                 true:\n     switch (fool) {                vs.     switch (fool) {\n     case 1:                                  case 1:\n       bar();                                   bar();\n       break;                                   break;\n     default:                                 default:\n       plop();                                  plop();\n     }                                      }\n</code></pre>\n"
        },
        "IndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns to use for indentation.</p>\n<pre><code class=\"lang-  \">     IndentWidth: 3\n</code></pre>\n<pre><code> void f() {\n    someFunction();\n    if (true, false) {\n       f();\n    }\n }\n</code></pre>"
        },
        "IndentWrappedFunctionNames": {
            "type": "bool",
            "doc": "<p>  Indent if a function definition or declaration is wrapped after the\n  type.</p>\n<pre><code class=\"lang-  \">     true:\n     LoooooooooooooooooooooooooooooooooooooooongReturnType\n         LoooooooooooooooooooooooooooooooongFunctionDeclaration();\n</code></pre>\n<pre><code> false:\n LoooooooooooooooooooooooooooooooooooooooongReturnType\n LoooooooooooooooooooooooooooooooongFunctionDeclaration();\n</code></pre>"
        },
        "JavaScriptQuotes": {
            "type": "JavaScriptQuoteStyle",
            "doc": "<p>  The JavaScriptQuoteStyle to use for JavaScript strings.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>JSQS_Leave</code> (in configuration: <code>Leave</code>)\nLeave string quotes as they are.</p>\n<pre><code>   string1 = &quot;foo&quot;;\n   string2 = &#39;bar&#39;;\n</code></pre></li>\n<li><p><code>JSQS_Single</code> (in configuration: <code>Single</code>)\nAlways use single quotes.</p>\n<pre><code>   string1 = &#39;foo&#39;;\n   string2 = &#39;bar&#39;;\n</code></pre></li>\n<li><p><code>JSQS_Double</code> (in configuration: <code>Double</code>)\nAlways use double quotes.</p>\n<pre><code>   string1 = &quot;foo&quot;;\n   string2 = &quot;bar&quot;;\n</code></pre></li>\n</ul>\n",
            "options": [
                "Leave",
                "Single",
                "Double"
            ]
        },
        "JavaScriptWrapImports": {
            "type": "bool",
            "doc": "<p>  Whether to wrap JavaScript import/export statements.</p>\n<pre><code class=\"lang-  \">     true:\n     import {\n         VeryLongImportsAreAnnoying,\n         VeryLongImportsAreAnnoying,\n         VeryLongImportsAreAnnoying,\n     } from &#39;some/module.js&#39;\n</code></pre>\n<pre><code> false:\n import {VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying,} from &quot;some/module.js&quot;\n</code></pre>"
        },
        "KeepEmptyLinesAtTheStartOfBlocks": {
            "type": "bool",
            "doc": "<p>  If true, the empty line at the start of blocks is kept.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     if (foo) {                     vs.     if (foo) {\n                                              bar();\n       bar();                               }\n     }\n</code></pre>\n"
        },
        "Language": {
            "type": "LanguageKind",
            "doc": "<p>  Language, this format style is targeted at.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>LK_None</code> (in configuration: <code>None</code>)\nDo not use.</p>\n</li>\n<li><p><code>LK_Cpp</code> (in configuration: <code>Cpp</code>)\nShould be used for C, C++.</p>\n</li>\n<li><p><code>LK_Java</code> (in configuration: <code>Java</code>)\nShould be used for Java.</p>\n</li>\n<li><p><code>LK_JavaScript</code> (in configuration: <code>JavaScript</code>)\nShould be used for JavaScript.</p>\n</li>\n<li><p><code>LK_ObjC</code> (in configuration: <code>ObjC</code>)\nShould be used for Objective-C, Objective-C++.</p>\n</li>\n<li><p><code>LK_Proto</code> (in configuration: <code>Proto</code>)\nShould be used for Protocol Buffers\n(https://developers.google.com/protocol-buffers/).</p>\n</li>\n<li><p><code>LK_TableGen</code> (in configuration: <code>TableGen</code>)\nShould be used for TableGen code.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "Cpp",
                "Java",
                "JavaScript",
                "ObjC",
                "Proto",
                "TableGen"
            ]
        },
        "MacroBlockBegin": {
            "type": "std::string",
            "doc": "<p>  A regular expression matching macros that start a block.</p>\n<pre><code class=\"lang-  \">     # With:\n     MacroBlockBegin: &quot;^NS_MAP_BEGIN|\\\n     NS_TABLE_HEAD$&quot;\n     MacroBlockEnd: &quot;^\\\n     NS_MAP_END|\\\n     NS_TABLE_.*_END$&quot;\n</code></pre>\n<pre><code> NS_MAP_BEGIN\n   foo();\n NS_MAP_END\n\n NS_TABLE_HEAD\n   bar();\n NS_TABLE_FOO_END\n\n # Without:\n NS_MAP_BEGIN\n foo();\n NS_MAP_END\n\n NS_TABLE_HEAD\n bar();\n NS_TABLE_FOO_END\n</code></pre>"
        },
        "MacroBlockEnd": {
            "type": "std::string",
            "doc": "<p>  A regular expression matching macros that end a block.</p>\n"
        },
        "MaxEmptyLinesToKeep": {
            "type": "unsigned",
            "doc": "<p>  The maximum number of consecutive empty lines to keep.</p>\n<pre><code class=\"lang-  \">     MaxEmptyLinesToKeep: 1         vs.     MaxEmptyLinesToKeep: 0\n     int f() {                              int f() {\n       int = 1;                                 int i = 1;\n                                                i = foo();\n       i = foo();                               return i;\n                                            }\n       return i;\n     }\n</code></pre>\n"
        },
        "NamespaceIndentation": {
            "type": "NamespaceIndentationKind",
            "doc": "<p>  The indentation used for namespaces.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>NI_None</code> (in configuration: <code>None</code>)\nDon&#39;t indent in namespaces.</p>\n<pre><code>   namespace out {\n   int i;\n   namespace in {\n   int i;\n   }\n   }\n</code></pre></li>\n<li><p><code>NI_Inner</code> (in configuration: <code>Inner</code>)\nIndent only in inner namespaces (nested in other namespaces).</p>\n<pre><code>   namespace out {\n   int i;\n   namespace in {\n     int i;\n   }\n   }\n</code></pre></li>\n<li><p><code>NI_All</code> (in configuration: <code>All</code>)\nIndent in all namespaces.</p>\n<pre><code>   namespace out {\n     int i;\n     namespace in {\n       int i;\n     }\n   }\n</code></pre></li>\n</ul>\n",
            "options": [
                "None",
                "Inner",
                "All"
            ]
        },
        "ObjCBlockIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of ObjC blocks.</p>\n<pre><code class=\"lang-  \">     ObjCBlockIndentWidth: 4\n</code></pre>\n<pre><code> [operation setCompletionBlock:^{\n     [self onOperationDone];\n }];\n</code></pre>"
        },
        "ObjCSpaceAfterProperty": {
            "type": "bool",
            "doc": "<p>  Add a space after <code>@property</code> in Objective-C, i.e. use\n  <code>@property (readonly)</code> instead of <code>@property(readonly)</code>.</p>\n"
        },
        "ObjCSpaceBeforeProtocolList": {
            "type": "bool",
            "doc": "<p>  Add a space in front of an Objective-C protocol list, i.e. use\n  <code>Foo &lt;Protocol&gt;</code> instead of <code>Foo&lt;Protocol&gt;</code>.</p>\n"
        },
        "PenaltyBreakAssignment": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking around an assignment operator.</p>\n"
        },
        "PenaltyBreakBeforeFirstCallParameter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking a function call after <code>call(</code>.</p>\n"
        },
        "PenaltyBreakComment": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a comment.</p>\n"
        },
        "PenaltyBreakFirstLessLess": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking before the first <code>&lt;&lt;</code>.</p>\n"
        },
        "PenaltyBreakString": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a string literal.</p>\n"
        },
        "PenaltyExcessCharacter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each character outside of the column limit.</p>\n"
        },
        "PenaltyReturnTypeOnItsOwnLine": {
            "type": "unsigned",
            "doc": "<p>  Penalty for putting the return type of a function onto its own\n  line.</p>\n"
        },
        "PointerAlignment": {
            "type": "PointerAlignmentStyle",
            "doc": "<p>  Pointer and reference alignment style.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>PAS_Left</code> (in configuration: <code>Left</code>)\nAlign pointer to the left.</p>\n<pre><code>  int* a;\n</code></pre></li>\n<li><p><code>PAS_Right</code> (in configuration: <code>Right</code>)\nAlign pointer to the right.</p>\n<pre><code>  int *a;\n</code></pre></li>\n<li><p><code>PAS_Middle</code> (in configuration: <code>Middle</code>)\nAlign pointer in the middle.</p>\n<pre><code>  int * a;\n</code></pre></li>\n</ul>\n",
            "options": [
                "Left",
                "Right",
                "Middle"
            ]
        },
        "ReflowComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format will attempt to re-flow comments.</p>\n<pre><code class=\"lang-  \">     false:\n     // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information\n     /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */\n</code></pre>\n<pre><code> true:\n // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of\n // information\n /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of\n  * information */\n</code></pre>"
        },
        "SortIncludes": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format will sort <code>#includes</code>.</p>\n<pre><code class=\"lang-  \">     false:                                 true:\n     #include &quot;b.h&quot;                 vs.     #include &quot;a.h&quot;\n     #include &quot;a.h&quot;                         #include &quot;b.h&quot;\n</code></pre>\n"
        },
        "SortUsingDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format will sort using declarations.</p>\n<pre><code class=\"lang-  \">     false:                                 true:\n     using std::cout;               vs.     using std::cin;\n     using std::cin;                        using std::cout;\n</code></pre>\n"
        },
        "SpaceAfterCStyleCast": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, a space is inserted after C style casts.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     (int)i;                        vs.     (int) i;\n</code></pre>\n"
        },
        "SpaceAfterTemplateKeyword": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, a space will be inserted after the &#39;template&#39; keyword.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     template &lt;int&gt; void foo();     vs.     template&lt;int&gt; void foo();\n</code></pre>\n"
        },
        "SpaceBeforeAssignmentOperators": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, spaces will be removed before assignment operators.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     int a = 5;                     vs.     int a=5;\n     a += 42                                a+=42;\n</code></pre>\n"
        },
        "SpaceBeforeParens": {
            "type": "SpaceBeforeParensOptions",
            "doc": "<p>  Defines in which cases to put a space before opening parentheses.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>SBPO_Never</code> (in configuration: <code>Never</code>)\nNever put a space before opening parentheses.</p>\n<pre><code>   void f() {\n     if(true) {\n       f();\n     }\n   }\n</code></pre></li>\n<li><p><code>SBPO_ControlStatements</code> (in configuration: <code>ControlStatements</code>)\nPut a space before opening parentheses only after control statement\nkeywords (<code>for/if/while...</code>).</p>\n<pre><code>   void f() {\n     if (true) {\n       f();\n     }\n   }\n</code></pre></li>\n<li><p><code>SBPO_Always</code> (in configuration: <code>Always</code>)\nAlways put a space before opening parentheses, except when it&#39;s\nprohibited by the syntax rules (in function-like macro definitions) or\nwhen determined by other style rules (after unary operators, opening\nparentheses, etc.)</p>\n<pre><code>   void f () {\n     if (true) {\n       f ();\n     }\n   }\n</code></pre></li>\n</ul>\n",
            "options": [
                "Never",
                "ControlStatements",
                "Always"
            ]
        },
        "SpaceInEmptyParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into <code>()</code>.</p>\n<pre><code class=\"lang-  \">     true:                                false:\n     void f( ) {                    vs.   void f() {\n       int x[] = {foo( ), bar( )};          int x[] = {foo(), bar()};\n       if (true) {                          if (true) {\n         f( );                                f();\n       }                                    }\n     }                                    }\n</code></pre>\n"
        },
        "SpacesBeforeTrailingComments": {
            "type": "unsigned",
            "doc": "<p>  The number of spaces before trailing line comments\n  (<code>//</code> - comments).</p>\n<p>  This does not affect trailing block comments (<code>/*</code> - comments) as\n  those commonly have different usage patterns and a number of special\n  cases.</p>\n<pre><code class=\"lang-  \">     SpacesBeforeTrailingComments: 3\n     void f() {\n       if (true) {   // foo1\n         f();        // bar\n       }             // foo\n     }\n</code></pre>\n"
        },
        "SpacesInAngles": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>&lt;</code> and before <code>&gt;</code>\n  in template argument lists.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     static_cast&lt; int &gt;(arg);       vs.     static_cast&lt;int&gt;(arg);\n     std::function&lt; void(int) &gt; fct;        std::function&lt;void(int)&gt; fct;\n</code></pre>\n"
        },
        "SpacesInCStyleCastParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into C style casts.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     x = ( int32 )y                 vs.     x = (int32)y\n</code></pre>\n"
        },
        "SpacesInContainerLiterals": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces are inserted inside container literals (e.g.\n  ObjC and Javascript array and dict literals).</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     var arr = [ 1, 2, 3 ];         vs.     var arr = [1, 2, 3];\n     f({a : 1, b : 2, c : 3});              f({a: 1, b: 2, c: 3});\n</code></pre>\n"
        },
        "SpacesInParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>(</code> and before <code>)</code>.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     t f( Deleted &amp; ) &amp; = delete;   vs.     t f(Deleted &amp;) &amp; = delete;\n</code></pre>\n"
        },
        "SpacesInSquareBrackets": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>[</code> and before <code>]</code>.\n  Lambdas or unspecified size array declarations will not be affected.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     int a[ 5 ];                    vs.     int a[5];\n     std::unique_ptr&lt;int[]&gt; foo() {} // Won&#39;t be affected\n</code></pre>\n"
        },
        "Standard": {
            "type": "LanguageStandard",
            "doc": "<p>  Format compatible with this standard, e.g. use <code>A&lt;A&lt;int&gt; &gt;</code>\n  instead of <code>A&lt;A&lt;int&gt;&gt;</code> for <code>LS_Cpp03</code>.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>LS_Cpp03</code> (in configuration: <code>Cpp03</code>)\nUse C++03-compatible syntax.</p>\n</li>\n<li><p><code>LS_Cpp11</code> (in configuration: <code>Cpp11</code>)\nUse features of C++11, C++14 and C++1z (e.g. <code>A&lt;A&lt;int&gt;&gt;</code> instead of\n<code>A&lt;A&lt;int&gt; &gt;</code>).</p>\n</li>\n<li><p><code>LS_Auto</code> (in configuration: <code>Auto</code>)\nAutomatic detection based on the input.</p>\n</li>\n</ul>\n",
            "options": [
                "Cpp03",
                "Cpp11",
                "Auto"
            ]
        },
        "TabWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns used for tab stops.</p>\n"
        },
        "UseTab": {
            "type": "UseTabStyle",
            "doc": "<p>  The way to use tab characters in the resulting file.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>UT_Never</code> (in configuration: <code>Never</code>)\nNever use tab.</p>\n</li>\n<li><p><code>UT_ForIndentation</code> (in configuration: <code>ForIndentation</code>)\nUse tabs only for indentation.</p>\n</li>\n<li><p><code>UT_ForContinuationAndIndentation</code> (in configuration: <code>ForContinuationAndIndentation</code>)\nUse tabs only for line continuation and indentation.</p>\n</li>\n<li><p><code>UT_Always</code> (in configuration: <code>Always</code>)\nUse tabs whenever we need to fill whitespace that spans at least from\none tab stop to the next one.</p>\n</li>\n</ul>\n",
            "options": [
                "Never",
                "ForIndentation",
                "ForContinuationAndIndentation",
                "Always"
            ]
        }
    },
    "5.0.2": {
        "BasedOnStyle": {
            "type": "string",
            "doc": "<p>  The style used for all options not specifically set in the configuration.</p>\n<p>  This option is supported only in the <strong>clang-format</strong> configuration\n  (both within <code>-style=&#39;{...}&#39;</code> and the <code>.clang-format</code> file).</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LLVM</code>\nA style complying with the <a href=\"http://llvm.org/docs/CodingStandards.html\">LLVM coding standards</a></li>\n<li><code>Google</code>\nA style complying with <a href=\"http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml\">Google&#39;s C++ style guide</a></li>\n<li><code>Chromium</code>\nA style complying with <a href=\"http://www.chromium.org/developers/coding-style\">Chromium&#39;s style guide</a></li>\n<li><code>Mozilla</code>\nA style complying with <a href=\"https://developer.mozilla.org/en-US/docs/Developer_Guide/Coding_Style\">Mozilla&#39;s style guide</a></li>\n<li><code>WebKit</code>\nA style complying with <a href=\"http://www.webkit.org/coding/coding-style.html\">WebKit&#39;s style guide</a></li>\n</ul>\n",
            "options": [
                "LLVM",
                "Google",
                "Chromium",
                "Mozilla",
                "WebKit"
            ]
        },
        "AccessModifierOffset": {
            "type": "int",
            "doc": "<p>  The extra indent or outdent of access modifiers, e.g. <code>public:</code>.</p>\n"
        },
        "AlignAfterOpenBracket": {
            "type": "BracketAlignmentStyle",
            "doc": "<p>  If <code>true</code>, horizontally aligns arguments after an open bracket.</p>\n<p>  This applies to round brackets (parentheses), angle brackets and square\n  brackets.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BAS_Align</code> (in configuration: <code>Align</code>)\nAlign parameters on the open bracket, e.g.:</p>\n<pre><code>  someLongFunction(argument1,\n                   argument2);\n</code></pre></li>\n<li><p><code>BAS_DontAlign</code> (in configuration: <code>DontAlign</code>)\nDon&#39;t align, instead use <code>ContinuationIndentWidth</code>, e.g.:</p>\n<pre><code>  someLongFunction(argument1,\n      argument2);\n</code></pre></li>\n<li><p><code>BAS_AlwaysBreak</code> (in configuration: <code>AlwaysBreak</code>)\nAlways break after an open bracket, if the parameters don&#39;t fit\non a single line, e.g.:</p>\n<pre><code>  someLongFunction(\n      argument1, argument2);\n</code></pre></li>\n</ul>\n",
            "options": [
                "Align",
                "DontAlign",
                "AlwaysBreak"
            ]
        },
        "AlignConsecutiveAssignments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns consecutive assignments.</p>\n<p>  This will align the assignment operators of consecutive lines. This\n  will result in formattings like</p>\n<pre><code class=\"lang-  \">    int aaaa = 12;\n    int b    = 23;\n    int ccc  = 23;\n</code></pre>\n"
        },
        "AlignConsecutiveDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns consecutive declarations.</p>\n<p>  This will align the declaration names of consecutive lines. This\n  will result in formattings like</p>\n<pre><code class=\"lang-  \">    int         aaaa = 12;\n    float       b = 23;\n    std::string ccc = 23;\n</code></pre>\n"
        },
        "AlignEscapedNewlines": {
            "type": "EscapedNewlineAlignmentStyle",
            "doc": "<p>  Options for aligning backslashes in escaped newlines.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>ENAS_DontAlign</code> (in configuration: <code>DontAlign</code>)\nDon&#39;t align escaped newlines.</p>\n<pre><code>  #define A \\\n    int aaaa; \\\n    int b; \\\n    int dddddddddd;\n</code></pre></li>\n<li><p><code>ENAS_Left</code> (in configuration: <code>Left</code>)\nAlign escaped newlines as far left as possible.</p>\n<pre><code>  true:\n  #define A   \\\n    int aaaa; \\\n    int b;    \\\n    int dddddddddd;\n</code></pre><p>  false:</p>\n</li>\n<li><p><code>ENAS_Right</code> (in configuration: <code>Right</code>)\nAlign escaped newlines in the right-most column.</p>\n<pre><code>  #define A                                                                      \\\n    int aaaa;                                                                    \\\n    int b;                                                                       \\\n    int dddddddddd;\n</code></pre></li>\n</ul>\n",
            "options": [
                "DontAlign",
                "Left",
                "Right"
            ]
        },
        "AlignOperands": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, horizontally align operands of binary and ternary\n  expressions.</p>\n<p>  Specifically, this aligns operands of a single expression that needs to be\n  split over multiple lines, e.g.:</p>\n<pre><code class=\"lang-  \">    int aaa = bbbbbbbbbbbbbbb +\n              ccccccccccccccc;\n</code></pre>\n"
        },
        "AlignTrailingComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns trailing comments.</p>\n<pre><code class=\"lang-  \">    true:                                   false:\n    int a;     // My comment a      vs.     int a; // My comment a\n    int b = 2; // comment  b                int b = 2; // comment about b\n</code></pre>\n"
        },
        "AllowAllParametersOfDeclarationOnNextLine": {
            "type": "bool",
            "doc": "<p>  Allow putting all parameters of a function declaration onto\n  the next line even if <code>BinPackParameters</code> is <code>false</code>.</p>\n<pre><code class=\"lang-  \">    true:                                   false:\n    myFunction(foo,                 vs.     myFunction(foo, bar, plop);\n               bar,\n               plop);\n</code></pre>\n"
        },
        "AllowShortBlocksOnASingleLine": {
            "type": "bool",
            "doc": "<p>  Allows contracting simple braced statements to a single line.</p>\n<p>  E.g., this allows <code>if (a) { return; }</code> to be put on a single line.</p>\n"
        },
        "AllowShortCaseLabelsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, short case labels will be contracted to a single line.</p>\n<pre><code class=\"lang-  \">    true:                                   false:\n    switch (a) {                    vs.     switch (a) {\n    case 1: x = 1; break;                   case 1:\n    case 2: return;                           x = 1;\n    }                                         break;\n                                            case 2:\n                                              return;\n                                            }\n</code></pre>\n"
        },
        "AllowShortFunctionsOnASingleLine": {
            "type": "ShortFunctionStyle",
            "doc": "<p>  Dependent on the value, <code>int f() { return 0; }</code> can be put on a\n  single line.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>SFS_None</code> (in configuration: <code>None</code>)\nNever merge functions into a single line.</p>\n</li>\n<li><p><code>SFS_InlineOnly</code> (in configuration: <code>InlineOnly</code>)\nOnly merge functions defined inside a class. Same as &quot;inline&quot;,\nexcept it does not implies &quot;empty&quot;: i.e. top level empty functions\nare not merged either.</p>\n<pre><code>  class Foo {\n    void f() { foo(); }\n  };\n  void f() {\n    foo();\n  }\n  void f() {\n  }\n</code></pre></li>\n<li><p><code>SFS_Empty</code> (in configuration: <code>Empty</code>)\nOnly merge empty functions.</p>\n<pre><code>  void f() {}\n  void f2() {\n    bar2();\n  }\n</code></pre></li>\n<li><p><code>SFS_Inline</code> (in configuration: <code>Inline</code>)\nOnly merge functions defined inside a class. Implies &quot;empty&quot;.</p>\n<pre><code>  class Foo {\n    void f() { foo(); }\n  };\n  void f() {\n    foo();\n  }\n  void f() {}\n</code></pre></li>\n<li><p><code>SFS_All</code> (in configuration: <code>All</code>)\nMerge all functions fitting on a single line.</p>\n<pre><code>  class Foo {\n    void f() { foo(); }\n  };\n  void f() { bar(); }\n</code></pre></li>\n</ul>\n",
            "options": [
                "None",
                "InlineOnly",
                "Empty",
                "Inline",
                "All"
            ]
        },
        "AllowShortIfStatementsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>if (a) return;</code> can be put on a single line.</p>\n"
        },
        "AllowShortLoopsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>while (true) continue;</code> can be put on a single\n  line.</p>\n"
        },
        "AlwaysBreakAfterDefinitionReturnType": {
            "type": "DefinitionReturnTypeBreakingStyle",
            "doc": "<p>  The function definition return type breaking style to use.  This\n  option is <strong>deprecated</strong> and is retained for backwards compatibility.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>DRTBS_None</code> (in configuration: <code>None</code>)\nBreak after return type automatically.\n<code>PenaltyReturnTypeOnItsOwnLine</code> is taken into account.</p>\n</li>\n<li><p><code>DRTBS_All</code> (in configuration: <code>All</code>)\nAlways break after the return type.</p>\n</li>\n<li><p><code>DRTBS_TopLevel</code> (in configuration: <code>TopLevel</code>)\nAlways break after the return types of top-level functions.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "All",
                "TopLevel"
            ]
        },
        "AlwaysBreakAfterReturnType": {
            "type": "ReturnTypeBreakingStyle",
            "doc": "<p>  The function declaration return type breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>RTBS_None</code> (in configuration: <code>None</code>)\nBreak after return type automatically.\n<code>PenaltyReturnTypeOnItsOwnLine</code> is taken into account.</p>\n<pre><code>  class A {\n    int f() { return 0; };\n  };\n  int f();\n  int f() { return 1; }\n</code></pre></li>\n<li><p><code>RTBS_All</code> (in configuration: <code>All</code>)\nAlways break after the return type.</p>\n<pre><code>  class A {\n    int\n    f() {\n      return 0;\n    };\n  };\n  int\n  f();\n  int\n  f() {\n    return 1;\n  }\n</code></pre></li>\n<li><p><code>RTBS_TopLevel</code> (in configuration: <code>TopLevel</code>)\nAlways break after the return types of top-level functions.</p>\n<pre><code>  class A {\n    int f() { return 0; };\n  };\n  int\n  f();\n  int\n  f() {\n    return 1;\n  }\n</code></pre></li>\n<li><p><code>RTBS_AllDefinitions</code> (in configuration: <code>AllDefinitions</code>)\nAlways break after the return type of function definitions.</p>\n<pre><code>  class A {\n    int\n    f() {\n      return 0;\n    };\n  };\n  int f();\n  int\n  f() {\n    return 1;\n  }\n</code></pre></li>\n<li><p><code>RTBS_TopLevelDefinitions</code> (in configuration: <code>TopLevelDefinitions</code>)\nAlways break after the return type of top-level definitions.</p>\n<pre><code>  class A {\n    int f() { return 0; };\n  };\n  int f();\n  int\n  f() {\n    return 1;\n  }\n</code></pre></li>\n</ul>\n",
            "options": [
                "None",
                "All",
                "TopLevel",
                "AllDefinitions",
                "TopLevelDefinitions"
            ]
        },
        "AlwaysBreakBeforeMultilineStrings": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break before multiline string literals.</p>\n<p>  This flag is mean to make cases where there are multiple multiline strings\n  in a file look more consistent. Thus, it will only take effect if wrapping\n  the string at that point leads to it being indented\n  <code>ContinuationIndentWidth</code> spaces from the start of the line.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     aaaa =                         vs.     aaaa = &quot;bbbb&quot;\n         &quot;bbbb&quot;                                    &quot;cccc&quot;;\n         &quot;cccc&quot;;\n</code></pre>\n"
        },
        "AlwaysBreakTemplateDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break after the <code>template&lt;...&gt;</code> of a template\n  declaration.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     template &lt;typename T&gt;          vs.     template &lt;typename T&gt; class C {};\n     class C {};\n</code></pre>\n"
        },
        "BinPackArguments": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function call&#39;s arguments will either be all on the\n  same line or will have one line each.</p>\n<pre><code class=\"lang-  \">    true:\n    void f() {\n      f(aaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaa,\n        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\n    }\n</code></pre>\n<pre><code>false:\nvoid f() {\n  f(aaaaaaaaaaaaaaaaaaaa,\n    aaaaaaaaaaaaaaaaaaaa,\n    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\n}\n</code></pre>"
        },
        "BinPackParameters": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function declaration&#39;s or function definition&#39;s\n  parameters will either all be on the same line or will have one line each.</p>\n<pre><code class=\"lang-  \">    true:\n    void f(int aaaaaaaaaaaaaaaaaaaa, int aaaaaaaaaaaaaaaaaaaa,\n           int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\n</code></pre>\n<pre><code>false:\nvoid f(int aaaaaaaaaaaaaaaaaaaa,\n       int aaaaaaaaaaaaaaaaaaaa,\n       int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\n</code></pre>"
        },
        "BraceWrapping": {
            "type": "BraceWrappingFlags",
            "doc": "<p>  Control of individual brace wrapping cases.</p>\n<p>  If <code>BreakBeforeBraces</code> is set to <code>BS_Custom</code>, use this to specify how\n  each individual brace case should be handled. Otherwise, this is ignored.</p>\n<p>  Nested configuration flags:</p>\n<ul>\n<li><p><code>bool AfterClass</code> Wrap class definitions.</p>\n<pre><code>  true:\n  class foo {};\n</code></pre><p>  false:\n  class foo\n  {};</p>\n</li>\n<li><p><code>bool AfterControlStatement</code> Wrap control statements (<code>if</code>/<code>for</code>/<code>while</code>/<code>switch</code>/..).</p>\n<pre><code>  true:\n  if (foo())\n  {\n  } else\n  {}\n  for (int i = 0; i &lt; 10; ++i)\n  {}\n</code></pre><p>  false:\n  if (foo()) {\n  } else {\n  }\n  for (int i = 0; i &lt; 10; ++i) {\n  }</p>\n</li>\n<li><p><code>bool AfterEnum</code> Wrap enum definitions.</p>\n<pre><code>  true:\n  enum X : int\n  {\n    B\n  };\n</code></pre><p>  false:\n  enum X : int { B };</p>\n</li>\n<li><p><code>bool AfterFunction</code> Wrap function definitions.</p>\n<pre><code>  true:\n  void foo()\n  {\n    bar();\n    bar2();\n  }\n</code></pre><p>  false:\n  void foo() {</p>\n<pre><code>bar();\nbar2();\n</code></pre><p>  }</p>\n</li>\n<li><p><code>bool AfterNamespace</code> Wrap namespace definitions.</p>\n<pre><code>  true:\n  namespace\n  {\n  int foo();\n  int bar();\n  }\n</code></pre><p>  false:\n  namespace {\n  int foo();\n  int bar();\n  }</p>\n</li>\n<li><p><code>bool AfterObjCDeclaration</code> Wrap ObjC definitions (<code>@autoreleasepool</code>, interfaces, ..).</p>\n</li>\n<li><p><code>bool AfterStruct</code> Wrap struct definitions.</p>\n<pre><code>  true:\n  struct foo\n  {\n    int x;\n  };\n</code></pre><p>  false:\n  struct foo {</p>\n<pre><code>int x;\n</code></pre><p>  };</p>\n</li>\n<li><p><code>bool AfterUnion</code> Wrap union definitions.</p>\n<pre><code>  true:\n  union foo\n  {\n    int x;\n  }\n</code></pre><p>  false:\n  union foo {</p>\n<pre><code>int x;\n</code></pre><p>  }</p>\n</li>\n<li><p><code>bool BeforeCatch</code> Wrap before <code>catch</code>.</p>\n<pre><code>  true:\n  try {\n    foo();\n  }\n  catch () {\n  }\n</code></pre><p>  false:\n  try {</p>\n<pre><code>foo();\n</code></pre><p>  } catch () {\n  }</p>\n</li>\n<li><p><code>bool BeforeElse</code> Wrap before <code>else</code>.</p>\n<pre><code>  true:\n  if (foo()) {\n  }\n  else {\n  }\n</code></pre><p>  false:\n  if (foo()) {\n  } else {\n  }</p>\n</li>\n<li><p><code>bool IndentBraces</code> Indent the wrapped braces themselves.</p>\n</li>\n<li><p><code>bool SplitEmptyFunctionBody</code> If <code>false</code>, empty function body can be put on a single line.\nThis option is used only if the opening brace of the function has\nalready been wrapped, i.e. the `AfterFunction` brace wrapping mode is\nset, and the function could/should not be put on a single line (as per\n`AllowShortFunctionsOnASingleLine` and constructor formatting options).</p>\n<pre><code>  int f()   vs.   inf f()\n  {}              {\n                  }\n</code></pre></li>\n</ul>\n",
            "options": [
                "AfterClass",
                "AfterControlStatement",
                "AfterEnum",
                "AfterFunction",
                "AfterNamespace",
                "AfterObjCDeclaration",
                "AfterStruct",
                "AfterUnion",
                "BeforeCatch",
                "BeforeElse",
                "IndentBraces",
                "SplitEmptyFunctionBody"
            ]
        },
        "BreakAfterJavaFieldAnnotations": {
            "type": "bool",
            "doc": "<p>  Break after each annotation on a field in Java files.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     @Partial                       vs.     @Partial @Mock DataLoad loader;\n     @Mock\n     DataLoad loader;\n</code></pre>\n"
        },
        "BreakBeforeBinaryOperators": {
            "type": "BinaryOperatorStyle",
            "doc": "<p>  The way to wrap binary operators.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BOS_None</code> (in configuration: <code>None</code>)\nBreak after operators.</p>\n<pre><code>   LooooooooooongType loooooooooooooooooooooongVariable =\n       someLooooooooooooooooongFunction();\n</code></pre><p>   bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +</p>\n<pre><code>                    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==\n                aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &amp;&amp;\n            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &gt;\n                ccccccccccccccccccccccccccccccccccccccccc;\n</code></pre></li>\n<li><p><code>BOS_NonAssignment</code> (in configuration: <code>NonAssignment</code>)\nBreak before operators that aren&#39;t assignments.</p>\n<pre><code>   LooooooooooongType loooooooooooooooooooooongVariable =\n       someLooooooooooooooooongFunction();\n</code></pre><p>   bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</p>\n<pre><code>                    + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n                == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n            &amp;&amp; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n                   &gt; ccccccccccccccccccccccccccccccccccccccccc;\n</code></pre></li>\n<li><p><code>BOS_All</code> (in configuration: <code>All</code>)\nBreak before operators.</p>\n<pre><code>   LooooooooooongType loooooooooooooooooooooongVariable\n       = someLooooooooooooooooongFunction();\n</code></pre><p>   bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</p>\n<pre><code>                    + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n                == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n            &amp;&amp; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n                   &gt; ccccccccccccccccccccccccccccccccccccccccc;\n</code></pre></li>\n</ul>\n",
            "options": [
                "None",
                "NonAssignment",
                "All"
            ]
        },
        "BreakBeforeBraces": {
            "type": "BraceBreakingStyle",
            "doc": "<p>  The brace breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BS_Attach</code> (in configuration: <code>Attach</code>)\nAlways attach braces to surrounding context.</p>\n<pre><code>  try {\n    foo();\n  } catch () {\n  }\n  void foo() { bar(); }\n  class foo {};\n  if (foo()) {\n  } else {\n  }\n  enum X : int { A, B };\n</code></pre></li>\n<li><p><code>BS_Linux</code> (in configuration: <code>Linux</code>)\nLike <code>Attach</code>, but break before braces on function, namespace and\nclass definitions.</p>\n<pre><code>  try {\n    foo();\n  } catch () {\n  }\n  void foo() { bar(); }\n  class foo\n  {\n  };\n  if (foo()) {\n  } else {\n  }\n  enum X : int { A, B };\n</code></pre></li>\n<li><p><code>BS_Mozilla</code> (in configuration: <code>Mozilla</code>)\nLike <code>Attach</code>, but break before braces on enum, function, and record\ndefinitions.</p>\n<pre><code>  try {\n    foo();\n  } catch () {\n  }\n  void foo() { bar(); }\n  class foo\n  {\n  };\n  if (foo()) {\n  } else {\n  }\n  enum X : int { A, B };\n</code></pre></li>\n<li><p><code>BS_Stroustrup</code> (in configuration: <code>Stroustrup</code>)\nLike <code>Attach</code>, but break before function definitions, <code>catch</code>, and\n<code>else</code>.</p>\n<pre><code>  try {\n    foo();\n  } catch () {\n  }\n  void foo() { bar(); }\n  class foo\n  {\n  };\n  if (foo()) {\n  } else {\n  }\n  enum X : int\n  {\n    A,\n    B\n  };\n</code></pre></li>\n<li><p><code>BS_Allman</code> (in configuration: <code>Allman</code>)\nAlways break before braces.</p>\n<pre><code>  try {\n    foo();\n  }\n  catch () {\n  }\n  void foo() { bar(); }\n  class foo {\n  };\n  if (foo()) {\n  }\n  else {\n  }\n  enum X : int { A, B };\n</code></pre></li>\n<li><p><code>BS_GNU</code> (in configuration: <code>GNU</code>)\nAlways break before braces and add an extra level of indentation to\nbraces of control statements, not to those of class, function\nor other definitions.</p>\n<pre><code>  try\n    {\n      foo();\n    }\n  catch ()\n    {\n    }\n  void foo() { bar(); }\n  class foo\n  {\n  };\n  if (foo())\n    {\n    }\n  else\n    {\n    }\n  enum X : int\n  {\n    A,\n    B\n  };\n</code></pre></li>\n<li><p><code>BS_WebKit</code> (in configuration: <code>WebKit</code>)\nLike <code>Attach</code>, but break before functions.</p>\n<pre><code>  try {\n    foo();\n  } catch () {\n  }\n  void foo() { bar(); }\n  class foo {\n  };\n  if (foo()) {\n  } else {\n  }\n  enum X : int { A, B };\n</code></pre></li>\n<li><p><code>BS_Custom</code> (in configuration: <code>Custom</code>)\nConfigure each individual brace in `BraceWrapping`.</p>\n</li>\n</ul>\n",
            "options": [
                "Attach",
                "Linux",
                "Mozilla",
                "Stroustrup",
                "Allman",
                "GNU",
                "WebKit",
                "Custom"
            ]
        },
        "BreakBeforeInheritanceComma": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, in the class inheritance expression clang-format will\n  break before <code>:</code> and <code>,</code> if there is multiple inheritance.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     class MyClass                  vs.     class MyClass : public X, public Y {\n         : public X                         };\n         , public Y {\n     };\n</code></pre>\n"
        },
        "BreakBeforeTernaryOperators": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, ternary operators will be placed after line breaks.</p>\n<pre><code class=\"lang-  \">     true:\n     veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription\n         ? firstValue\n         : SecondValueVeryVeryVeryVeryLong;\n</code></pre>\n<pre><code> false:\n veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ?\n     firstValue :\n     SecondValueVeryVeryVeryVeryLong;\n</code></pre>"
        },
        "BreakConstructorInitializers": {
            "type": "BreakConstructorInitializersStyle",
            "doc": "<p>  The constructor initializers style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BCIS_BeforeColon</code> (in configuration: <code>BeforeColon</code>)\nBreak constructor initializers before the colon and after the commas.</p>\n<pre><code>Constructor()\n    : initializer1(),\n      initializer2()\n</code></pre></li>\n<li><p><code>BCIS_BeforeComma</code> (in configuration: <code>BeforeComma</code>)\nBreak constructor initializers before the colon and commas, and align\nthe commas with the colon.</p>\n<pre><code>Constructor()\n    : initializer1()\n    , initializer2()\n</code></pre></li>\n<li><p><code>BCIS_AfterColon</code> (in configuration: <code>AfterColon</code>)\nBreak constructor initializers after the colon and commas.</p>\n<pre><code>Constructor() :\n    initializer1(),\n    initializer2()\n</code></pre></li>\n</ul>\n",
            "options": [
                "BeforeColon",
                "BeforeComma",
                "AfterColon"
            ]
        },
        "BreakStringLiterals": {
            "type": "bool",
            "doc": "<p>  Allow breaking string literals when formatting.</p>\n"
        },
        "ColumnLimit": {
            "type": "unsigned",
            "doc": "<p>  The column limit.</p>\n<p>  A column limit of <code>0</code> means that there is no column limit. In this case,\n  clang-format will respect the input&#39;s line breaking decisions within\n  statements unless they contradict other rules.</p>\n"
        },
        "CommentPragmas": {
            "type": "std::string",
            "doc": "<p>  A regular expression that describes comments with special meaning,\n  which should not be split into lines or otherwise changed.</p>\n<pre><code class=\"lang-  \">     // CommentPragmas: &#39;^ FOOBAR pragma:&#39;\n     // Will leave the following line unaffected\n     #include &lt;vector&gt; // FOOBAR pragma: keep\n</code></pre>\n"
        },
        "CompactNamespaces": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, consecutive namespace declarations will be on the same\n  line. If <code>false</code>, each namespace is declared on a new line.</p>\n<pre><code class=\"lang-  \">    true:\n    namespace Foo { namespace Bar {\n    }}\n</code></pre>\n<pre><code>false:\nnamespace Foo {\nnamespace Bar {\n}\n}\n</code></pre><p>  If it does not fit on a single line, the overflowing namespaces get\n  wrapped:</p>\n<pre><code class=\"lang-  \">    namespace Foo { namespace Bar {\n    namespace Extra {\n    }}}\n</code></pre>\n"
        },
        "ConstructorInitializerAllOnOneLineOrOnePerLine": {
            "type": "bool",
            "doc": "<p>  If the constructor initializers don&#39;t fit on a line, put each\n  initializer on its own line.</p>\n<pre><code class=\"lang-  \">    true:\n    SomeClass::Constructor()\n        : aaaaaaaa(aaaaaaaa), aaaaaaaa(aaaaaaaa), aaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaa) {\n      return 0;\n    }\n</code></pre>\n<pre><code>false:\nSomeClass::Constructor()\n    : aaaaaaaa(aaaaaaaa), aaaaaaaa(aaaaaaaa),\n      aaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaa) {\n  return 0;\n}\n</code></pre>"
        },
        "ConstructorInitializerIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of constructor\n  initializer lists.</p>\n"
        },
        "ContinuationIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  Indent width for line continuations.</p>\n<pre><code class=\"lang-  \">     ContinuationIndentWidth: 2\n</code></pre>\n<pre><code> int i =         //  VeryVeryVeryVeryVeryLongComment\n   longFunction( // Again a long comment\n     arg);\n</code></pre>"
        },
        "Cpp11BracedListStyle": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, format braced lists as best suited for C++11 braced\n  lists.</p>\n<p>  Important differences:</p>\n<ul>\n<li>No spaces inside the braced list.</li>\n<li>No line break before the closing brace.</li>\n<li><p>Indentation with the continuation indent, not with the block indent.</p>\n<p>Fundamentally, C++11 braced lists are formatted exactly like function\ncalls would be formatted in their place. If the braced list follows a name\n(e.g. a type or variable name), clang-format formats as if the <code>{}</code> were\nthe parentheses of a function call with that name. If there is no name,\na zero-length name is assumed.</p>\n<pre><code> true:                                  false:\n vector&lt;int&gt; x{1, 2, 3, 4};     vs.     vector&lt;int&gt; x{ 1, 2, 3, 4 };\n vector&lt;T&gt; x{{}, {}, {}, {}};           vector&lt;T&gt; x{ {}, {}, {}, {} };\n f(MyMap[{composite, key}]);            f(MyMap[{ composite, key }]);\n new int[3]{1, 2, 3};                   new int[3]{ 1, 2, 3 };\n</code></pre></li>\n</ul>\n"
        },
        "DerivePointerAlignment": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, analyze the formatted file for the most common\n  alignment of <code>&amp;</code> and <code>*</code>.\n  Pointer and reference alignment styles are going to be updated according\n  to the preferences found in the file.\n  <code>PointerAlignment</code> is then used only as fallback.</p>\n"
        },
        "DisableFormat": {
            "type": "bool",
            "doc": "<p>  Disables formatting completely.</p>\n"
        },
        "ExperimentalAutoDetectBinPacking": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format detects whether function calls and\n  definitions are formatted with one parameter per line.</p>\n<p>  Each call can be bin-packed, one-per-line or inconclusive. If it is\n  inconclusive, e.g. completely on one line, but a decision needs to be\n  made, clang-format analyzes whether there are other bin-packed cases in\n  the input file and act accordingly.</p>\n<p>  NOTE: This is an experimental flag, that might go away or be renamed. Do\n  not use this in config files, etc. Use at your own risk.</p>\n"
        },
        "FixNamespaceComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format adds missing namespace end comments and\n  fixes invalid existing ones.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     namespace a {                  vs.     namespace a {\n     foo();                                 foo();\n     } // namespace a;                      }\n</code></pre>\n"
        },
        "ForEachMacros": {
            "type": "std::vector<std::string>",
            "doc": "<p>  A vector of macros that should be interpreted as foreach loops\n  instead of as function calls.</p>\n<p>  These are expected to be macros of the form:</p>\n<pre><code class=\"lang-  \">    FOREACH(&lt;variable-declaration&gt;, ...)\n      &lt;loop-body&gt;\n</code></pre>\n<p>  In the .clang-format configuration file, this can be configured like:</p>\n<pre><code class=\"lang-  \">    ForEachMacros: [&#39;RANGES_FOR&#39;, &#39;FOREACH&#39;]\n</code></pre>\n<p>  For example: BOOST_FOREACH.</p>\n"
        },
        "IncludeCategories": {
            "type": "std::vector<IncludeCategory>",
            "doc": "<p>  Regular expressions denoting the different <code>#include</code> categories\n  used for ordering <code>#includes</code>.</p>\n<p>  These regular expressions are matched against the filename of an include\n  (including the &lt;&gt; or &quot;&quot;) in order. The value belonging to the first\n  matching regular expression is assigned and <code>#includes</code> are sorted first\n  according to increasing category number and then alphabetically within\n  each category.</p>\n<p>  If none of the regular expressions match, INT_MAX is assigned as\n  category. The main header for a source file automatically gets category 0.\n  so that it is generally kept at the beginning of the <code>#includes</code>\n  (http://llvm.org/docs/CodingStandards.html#include-style). However, you\n  can also assign negative priorities if you have certain headers that\n  always need to be first.</p>\n<p>  To configure this in the .clang-format file, use:</p>\n<pre><code class=\"lang-  \">    IncludeCategories:\n      - Regex:           &#39;^&quot;(llvm|llvm-c|clang|clang-c)/&#39;\n        Priority:        2\n      - Regex:           &#39;^(&lt;|&quot;(gtest|isl|json)/)&#39;\n        Priority:        3\n      - Regex:           &#39;.*&#39;\n        Priority:        1\n</code></pre>\n",
            "options": []
        },
        "IncludeIsMainRegex": {
            "type": "std::string",
            "doc": "<p>  Specify a regular expression of suffixes that are allowed in the\n  file-to-main-include mapping.</p>\n<p>  When guessing whether a #include is the &quot;main&quot; include (to assign\n  category 0, see above), use this regex of allowed suffixes to the header\n  stem. A partial match is done, so that:</p>\n<ul>\n<li>&quot;&quot; means &quot;arbitrary suffix&quot;</li>\n<li><p>&quot;$&quot; means &quot;no suffix&quot;</p>\n<p>For example, if configured to &quot;(_test)?$&quot;, then a header a.h would be seen\nas the &quot;main&quot; include in both a.cc and a_test.cc.</p>\n</li>\n</ul>\n"
        },
        "IndentCaseLabels": {
            "type": "bool",
            "doc": "<p>  Indent case labels one level from the switch statement.</p>\n<p>  When <code>false</code>, use the same indentation level as for the switch statement.\n  Switch statement body is always indented one level more than case labels.</p>\n<pre><code class=\"lang-  \">     false:                                 true:\n     switch (fool) {                vs.     switch (fool) {\n     case 1:                                  case 1:\n       bar();                                   bar();\n       break;                                   break;\n     default:                                 default:\n       plop();                                  plop();\n     }                                      }\n</code></pre>\n"
        },
        "IndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns to use for indentation.</p>\n<pre><code class=\"lang-  \">     IndentWidth: 3\n</code></pre>\n<pre><code> void f() {\n    someFunction();\n    if (true, false) {\n       f();\n    }\n }\n</code></pre>"
        },
        "IndentWrappedFunctionNames": {
            "type": "bool",
            "doc": "<p>  Indent if a function definition or declaration is wrapped after the\n  type.</p>\n<pre><code class=\"lang-  \">     true:\n     LoooooooooooooooooooooooooooooooooooooooongReturnType\n         LoooooooooooooooooooooooooooooooongFunctionDeclaration();\n</code></pre>\n<pre><code> false:\n LoooooooooooooooooooooooooooooooooooooooongReturnType\n LoooooooooooooooooooooooooooooooongFunctionDeclaration();\n</code></pre>"
        },
        "JavaScriptQuotes": {
            "type": "JavaScriptQuoteStyle",
            "doc": "<p>  The JavaScriptQuoteStyle to use for JavaScript strings.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>JSQS_Leave</code> (in configuration: <code>Leave</code>)\nLeave string quotes as they are.</p>\n<pre><code>   string1 = &quot;foo&quot;;\n   string2 = &#39;bar&#39;;\n</code></pre></li>\n<li><p><code>JSQS_Single</code> (in configuration: <code>Single</code>)\nAlways use single quotes.</p>\n<pre><code>   string1 = &#39;foo&#39;;\n   string2 = &#39;bar&#39;;\n</code></pre></li>\n<li><p><code>JSQS_Double</code> (in configuration: <code>Double</code>)\nAlways use double quotes.</p>\n<pre><code>   string1 = &quot;foo&quot;;\n   string2 = &quot;bar&quot;;\n</code></pre></li>\n</ul>\n",
            "options": [
                "Leave",
                "Single",
                "Double"
            ]
        },
        "JavaScriptWrapImports": {
            "type": "bool",
            "doc": "<p>  Whether to wrap JavaScript import/export statements.</p>\n<pre><code class=\"lang-  \">     true:\n     import {\n         VeryLongImportsAreAnnoying,\n         VeryLongImportsAreAnnoying,\n         VeryLongImportsAreAnnoying,\n     } from &#39;some/module.js&#39;\n</code></pre>\n<pre><code> false:\n import {VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying,} from &quot;some/module.js&quot;\n</code></pre>"
        },
        "KeepEmptyLinesAtTheStartOfBlocks": {
            "type": "bool",
            "doc": "<p>  If true, the empty line at the start of blocks is kept.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     if (foo) {                     vs.     if (foo) {\n                                              bar();\n       bar();                               }\n     }\n</code></pre>\n"
        },
        "Language": {
            "type": "LanguageKind",
            "doc": "<p>  Language, this format style is targeted at.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>LK_None</code> (in configuration: <code>None</code>)\nDo not use.</p>\n</li>\n<li><p><code>LK_Cpp</code> (in configuration: <code>Cpp</code>)\nShould be used for C, C++.</p>\n</li>\n<li><p><code>LK_Java</code> (in configuration: <code>Java</code>)\nShould be used for Java.</p>\n</li>\n<li><p><code>LK_JavaScript</code> (in configuration: <code>JavaScript</code>)\nShould be used for JavaScript.</p>\n</li>\n<li><p><code>LK_ObjC</code> (in configuration: <code>ObjC</code>)\nShould be used for Objective-C, Objective-C++.</p>\n</li>\n<li><p><code>LK_Proto</code> (in configuration: <code>Proto</code>)\nShould be used for Protocol Buffers\n(https://developers.google.com/protocol-buffers/).</p>\n</li>\n<li><p><code>LK_TableGen</code> (in configuration: <code>TableGen</code>)\nShould be used for TableGen code.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "Cpp",
                "Java",
                "JavaScript",
                "ObjC",
                "Proto",
                "TableGen"
            ]
        },
        "MacroBlockBegin": {
            "type": "std::string",
            "doc": "<p>  A regular expression matching macros that start a block.</p>\n<pre><code class=\"lang-  \">     # With:\n     MacroBlockBegin: &quot;^NS_MAP_BEGIN|\\\n     NS_TABLE_HEAD$&quot;\n     MacroBlockEnd: &quot;^\\\n     NS_MAP_END|\\\n     NS_TABLE_.*_END$&quot;\n</code></pre>\n<pre><code> NS_MAP_BEGIN\n   foo();\n NS_MAP_END\n\n NS_TABLE_HEAD\n   bar();\n NS_TABLE_FOO_END\n\n # Without:\n NS_MAP_BEGIN\n foo();\n NS_MAP_END\n\n NS_TABLE_HEAD\n bar();\n NS_TABLE_FOO_END\n</code></pre>"
        },
        "MacroBlockEnd": {
            "type": "std::string",
            "doc": "<p>  A regular expression matching macros that end a block.</p>\n"
        },
        "MaxEmptyLinesToKeep": {
            "type": "unsigned",
            "doc": "<p>  The maximum number of consecutive empty lines to keep.</p>\n<pre><code class=\"lang-  \">     MaxEmptyLinesToKeep: 1         vs.     MaxEmptyLinesToKeep: 0\n     int f() {                              int f() {\n       int = 1;                                 int i = 1;\n                                                i = foo();\n       i = foo();                               return i;\n                                            }\n       return i;\n     }\n</code></pre>\n"
        },
        "NamespaceIndentation": {
            "type": "NamespaceIndentationKind",
            "doc": "<p>  The indentation used for namespaces.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>NI_None</code> (in configuration: <code>None</code>)\nDon&#39;t indent in namespaces.</p>\n<pre><code>   namespace out {\n   int i;\n   namespace in {\n   int i;\n   }\n   }\n</code></pre></li>\n<li><p><code>NI_Inner</code> (in configuration: <code>Inner</code>)\nIndent only in inner namespaces (nested in other namespaces).</p>\n<pre><code>   namespace out {\n   int i;\n   namespace in {\n     int i;\n   }\n   }\n</code></pre></li>\n<li><p><code>NI_All</code> (in configuration: <code>All</code>)\nIndent in all namespaces.</p>\n<pre><code>   namespace out {\n     int i;\n     namespace in {\n       int i;\n     }\n   }\n</code></pre></li>\n</ul>\n",
            "options": [
                "None",
                "Inner",
                "All"
            ]
        },
        "ObjCBlockIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of ObjC blocks.</p>\n<pre><code class=\"lang-  \">     ObjCBlockIndentWidth: 4\n</code></pre>\n<pre><code> [operation setCompletionBlock:^{\n     [self onOperationDone];\n }];\n</code></pre>"
        },
        "ObjCSpaceAfterProperty": {
            "type": "bool",
            "doc": "<p>  Add a space after <code>@property</code> in Objective-C, i.e. use\n  <code>@property (readonly)</code> instead of <code>@property(readonly)</code>.</p>\n"
        },
        "ObjCSpaceBeforeProtocolList": {
            "type": "bool",
            "doc": "<p>  Add a space in front of an Objective-C protocol list, i.e. use\n  <code>Foo &lt;Protocol&gt;</code> instead of <code>Foo&lt;Protocol&gt;</code>.</p>\n"
        },
        "PenaltyBreakAssignment": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking around an assignment operator.</p>\n"
        },
        "PenaltyBreakBeforeFirstCallParameter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking a function call after <code>call(</code>.</p>\n"
        },
        "PenaltyBreakComment": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a comment.</p>\n"
        },
        "PenaltyBreakFirstLessLess": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking before the first <code>&lt;&lt;</code>.</p>\n"
        },
        "PenaltyBreakString": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a string literal.</p>\n"
        },
        "PenaltyExcessCharacter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each character outside of the column limit.</p>\n"
        },
        "PenaltyReturnTypeOnItsOwnLine": {
            "type": "unsigned",
            "doc": "<p>  Penalty for putting the return type of a function onto its own\n  line.</p>\n"
        },
        "PointerAlignment": {
            "type": "PointerAlignmentStyle",
            "doc": "<p>  Pointer and reference alignment style.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>PAS_Left</code> (in configuration: <code>Left</code>)\nAlign pointer to the left.</p>\n<pre><code>  int* a;\n</code></pre></li>\n<li><p><code>PAS_Right</code> (in configuration: <code>Right</code>)\nAlign pointer to the right.</p>\n<pre><code>  int *a;\n</code></pre></li>\n<li><p><code>PAS_Middle</code> (in configuration: <code>Middle</code>)\nAlign pointer in the middle.</p>\n<pre><code>  int * a;\n</code></pre></li>\n</ul>\n",
            "options": [
                "Left",
                "Right",
                "Middle"
            ]
        },
        "ReflowComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format will attempt to re-flow comments.</p>\n<pre><code class=\"lang-  \">     false:\n     // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information\n     /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */\n</code></pre>\n<pre><code> true:\n // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of\n // information\n /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of\n  * information */\n</code></pre>"
        },
        "SortIncludes": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format will sort <code>#includes</code>.</p>\n<pre><code class=\"lang-  \">     false:                                 true:\n     #include &quot;b.h&quot;                 vs.     #include &quot;a.h&quot;\n     #include &quot;a.h&quot;                         #include &quot;b.h&quot;\n</code></pre>\n"
        },
        "SortUsingDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format will sort using declarations.</p>\n<pre><code class=\"lang-  \">     false:                                 true:\n     using std::cout;               vs.     using std::cin;\n     using std::cin;                        using std::cout;\n</code></pre>\n"
        },
        "SpaceAfterCStyleCast": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, a space is inserted after C style casts.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     (int)i;                        vs.     (int) i;\n</code></pre>\n"
        },
        "SpaceAfterTemplateKeyword": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, a space will be inserted after the &#39;template&#39; keyword.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     template &lt;int&gt; void foo();     vs.     template&lt;int&gt; void foo();\n</code></pre>\n"
        },
        "SpaceBeforeAssignmentOperators": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, spaces will be removed before assignment operators.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     int a = 5;                     vs.     int a=5;\n     a += 42                                a+=42;\n</code></pre>\n"
        },
        "SpaceBeforeParens": {
            "type": "SpaceBeforeParensOptions",
            "doc": "<p>  Defines in which cases to put a space before opening parentheses.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>SBPO_Never</code> (in configuration: <code>Never</code>)\nNever put a space before opening parentheses.</p>\n<pre><code>   void f() {\n     if(true) {\n       f();\n     }\n   }\n</code></pre></li>\n<li><p><code>SBPO_ControlStatements</code> (in configuration: <code>ControlStatements</code>)\nPut a space before opening parentheses only after control statement\nkeywords (<code>for/if/while...</code>).</p>\n<pre><code>   void f() {\n     if (true) {\n       f();\n     }\n   }\n</code></pre></li>\n<li><p><code>SBPO_Always</code> (in configuration: <code>Always</code>)\nAlways put a space before opening parentheses, except when it&#39;s\nprohibited by the syntax rules (in function-like macro definitions) or\nwhen determined by other style rules (after unary operators, opening\nparentheses, etc.)</p>\n<pre><code>   void f () {\n     if (true) {\n       f ();\n     }\n   }\n</code></pre></li>\n</ul>\n",
            "options": [
                "Never",
                "ControlStatements",
                "Always"
            ]
        },
        "SpaceInEmptyParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into <code>()</code>.</p>\n<pre><code class=\"lang-  \">     true:                                false:\n     void f( ) {                    vs.   void f() {\n       int x[] = {foo( ), bar( )};          int x[] = {foo(), bar()};\n       if (true) {                          if (true) {\n         f( );                                f();\n       }                                    }\n     }                                    }\n</code></pre>\n"
        },
        "SpacesBeforeTrailingComments": {
            "type": "unsigned",
            "doc": "<p>  The number of spaces before trailing line comments\n  (<code>//</code> - comments).</p>\n<p>  This does not affect trailing block comments (<code>/*</code> - comments) as\n  those commonly have different usage patterns and a number of special\n  cases.</p>\n<pre><code class=\"lang-  \">     SpacesBeforeTrailingComments: 3\n     void f() {\n       if (true) {   // foo1\n         f();        // bar\n       }             // foo\n     }\n</code></pre>\n"
        },
        "SpacesInAngles": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>&lt;</code> and before <code>&gt;</code>\n  in template argument lists.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     static_cast&lt; int &gt;(arg);       vs.     static_cast&lt;int&gt;(arg);\n     std::function&lt; void(int) &gt; fct;        std::function&lt;void(int)&gt; fct;\n</code></pre>\n"
        },
        "SpacesInCStyleCastParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into C style casts.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     x = ( int32 )y                 vs.     x = (int32)y\n</code></pre>\n"
        },
        "SpacesInContainerLiterals": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces are inserted inside container literals (e.g.\n  ObjC and Javascript array and dict literals).</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     var arr = [ 1, 2, 3 ];         vs.     var arr = [1, 2, 3];\n     f({a : 1, b : 2, c : 3});              f({a: 1, b: 2, c: 3});\n</code></pre>\n"
        },
        "SpacesInParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>(</code> and before <code>)</code>.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     t f( Deleted &amp; ) &amp; = delete;   vs.     t f(Deleted &amp;) &amp; = delete;\n</code></pre>\n"
        },
        "SpacesInSquareBrackets": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>[</code> and before <code>]</code>.\n  Lambdas or unspecified size array declarations will not be affected.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     int a[ 5 ];                    vs.     int a[5];\n     std::unique_ptr&lt;int[]&gt; foo() {} // Won&#39;t be affected\n</code></pre>\n"
        },
        "Standard": {
            "type": "LanguageStandard",
            "doc": "<p>  Format compatible with this standard, e.g. use <code>A&lt;A&lt;int&gt; &gt;</code>\n  instead of <code>A&lt;A&lt;int&gt;&gt;</code> for <code>LS_Cpp03</code>.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>LS_Cpp03</code> (in configuration: <code>Cpp03</code>)\nUse C++03-compatible syntax.</p>\n</li>\n<li><p><code>LS_Cpp11</code> (in configuration: <code>Cpp11</code>)\nUse features of C++11, C++14 and C++1z (e.g. <code>A&lt;A&lt;int&gt;&gt;</code> instead of\n<code>A&lt;A&lt;int&gt; &gt;</code>).</p>\n</li>\n<li><p><code>LS_Auto</code> (in configuration: <code>Auto</code>)\nAutomatic detection based on the input.</p>\n</li>\n</ul>\n",
            "options": [
                "Cpp03",
                "Cpp11",
                "Auto"
            ]
        },
        "TabWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns used for tab stops.</p>\n"
        },
        "UseTab": {
            "type": "UseTabStyle",
            "doc": "<p>  The way to use tab characters in the resulting file.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>UT_Never</code> (in configuration: <code>Never</code>)\nNever use tab.</p>\n</li>\n<li><p><code>UT_ForIndentation</code> (in configuration: <code>ForIndentation</code>)\nUse tabs only for indentation.</p>\n</li>\n<li><p><code>UT_ForContinuationAndIndentation</code> (in configuration: <code>ForContinuationAndIndentation</code>)\nUse tabs only for line continuation and indentation.</p>\n</li>\n<li><p><code>UT_Always</code> (in configuration: <code>Always</code>)\nUse tabs whenever we need to fill whitespace that spans at least from\none tab stop to the next one.</p>\n</li>\n</ul>\n",
            "options": [
                "Never",
                "ForIndentation",
                "ForContinuationAndIndentation",
                "Always"
            ]
        }
    },
    "6.0.0": {
        "BasedOnStyle": {
            "type": "string",
            "doc": "<p>  The style used for all options not specifically set in the configuration.</p>\n<p>  This option is supported only in the <strong>clang-format</strong> configuration\n  (both within <code>-style=&#39;{...}&#39;</code> and the <code>.clang-format</code> file).</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LLVM</code>\nA style complying with the <a href=\"http://llvm.org/docs/CodingStandards.html\">LLVM coding standards</a></li>\n<li><code>Google</code>\nA style complying with <a href=\"http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml\">Google&#39;s C++ style guide</a></li>\n<li><code>Chromium</code>\nA style complying with <a href=\"http://www.chromium.org/developers/coding-style\">Chromium&#39;s style guide</a></li>\n<li><code>Mozilla</code>\nA style complying with <a href=\"https://developer.mozilla.org/en-US/docs/Developer_Guide/Coding_Style\">Mozilla&#39;s style guide</a></li>\n<li><code>WebKit</code>\nA style complying with <a href=\"http://www.webkit.org/coding/coding-style.html\">WebKit&#39;s style guide</a></li>\n</ul>\n",
            "options": [
                "LLVM",
                "Google",
                "Chromium",
                "Mozilla",
                "WebKit"
            ]
        },
        "AccessModifierOffset": {
            "type": "int",
            "doc": "<p>  The extra indent or outdent of access modifiers, e.g. <code>public:</code>.</p>\n"
        },
        "AlignAfterOpenBracket": {
            "type": "BracketAlignmentStyle",
            "doc": "<p>  If <code>true</code>, horizontally aligns arguments after an open bracket.</p>\n<p>  This applies to round brackets (parentheses), angle brackets and square\n  brackets.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BAS_Align</code> (in configuration: <code>Align</code>)\nAlign parameters on the open bracket, e.g.:</p>\n<pre><code>  someLongFunction(argument1,\n                   argument2);\n</code></pre></li>\n<li><p><code>BAS_DontAlign</code> (in configuration: <code>DontAlign</code>)\nDon&#39;t align, instead use <code>ContinuationIndentWidth</code>, e.g.:</p>\n<pre><code>  someLongFunction(argument1,\n      argument2);\n</code></pre></li>\n<li><p><code>BAS_AlwaysBreak</code> (in configuration: <code>AlwaysBreak</code>)\nAlways break after an open bracket, if the parameters don&#39;t fit\non a single line, e.g.:</p>\n<pre><code>  someLongFunction(\n      argument1, argument2);\n</code></pre></li>\n</ul>\n",
            "options": [
                "Align",
                "DontAlign",
                "AlwaysBreak"
            ]
        },
        "AlignConsecutiveAssignments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns consecutive assignments.</p>\n<p>  This will align the assignment operators of consecutive lines. This\n  will result in formattings like</p>\n<pre><code class=\"lang-  \">    int aaaa = 12;\n    int b    = 23;\n    int ccc  = 23;\n</code></pre>\n"
        },
        "AlignConsecutiveDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns consecutive declarations.</p>\n<p>  This will align the declaration names of consecutive lines. This\n  will result in formattings like</p>\n<pre><code class=\"lang-  \">    int         aaaa = 12;\n    float       b = 23;\n    std::string ccc = 23;\n</code></pre>\n"
        },
        "AlignEscapedNewlines": {
            "type": "EscapedNewlineAlignmentStyle",
            "doc": "<p>  Options for aligning backslashes in escaped newlines.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>ENAS_DontAlign</code> (in configuration: <code>DontAlign</code>)\nDon&#39;t align escaped newlines.</p>\n<pre><code>  #define A \\\n    int aaaa; \\\n    int b; \\\n    int dddddddddd;\n</code></pre></li>\n<li><p><code>ENAS_Left</code> (in configuration: <code>Left</code>)\nAlign escaped newlines as far left as possible.</p>\n<pre><code>  true:\n  #define A   \\\n    int aaaa; \\\n    int b;    \\\n    int dddddddddd;\n</code></pre><p>  false:</p>\n</li>\n<li><p><code>ENAS_Right</code> (in configuration: <code>Right</code>)\nAlign escaped newlines in the right-most column.</p>\n<pre><code>  #define A                                                                      \\\n    int aaaa;                                                                    \\\n    int b;                                                                       \\\n    int dddddddddd;\n</code></pre></li>\n</ul>\n",
            "options": [
                "DontAlign",
                "Left",
                "Right"
            ]
        },
        "AlignOperands": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, horizontally align operands of binary and ternary\n  expressions.</p>\n<p>  Specifically, this aligns operands of a single expression that needs to be\n  split over multiple lines, e.g.:</p>\n<pre><code class=\"lang-  \">    int aaa = bbbbbbbbbbbbbbb +\n              ccccccccccccccc;\n</code></pre>\n"
        },
        "AlignTrailingComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns trailing comments.</p>\n<pre><code class=\"lang-  \">    true:                                   false:\n    int a;     // My comment a      vs.     int a; // My comment a\n    int b = 2; // comment  b                int b = 2; // comment about b\n</code></pre>\n"
        },
        "AllowAllParametersOfDeclarationOnNextLine": {
            "type": "bool",
            "doc": "<p>  If the function declaration doesn&#39;t fit on a line,\n  allow putting all parameters of a function declaration onto\n  the next line even if <code>BinPackParameters</code> is <code>false</code>.</p>\n<pre><code class=\"lang-  \">    true:\n    void myFunction(\n        int a, int b, int c, int d, int e);\n</code></pre>\n<pre><code>false:\nvoid myFunction(int a,\n                int b,\n                int c,\n                int d,\n                int e);\n</code></pre>"
        },
        "AllowShortBlocksOnASingleLine": {
            "type": "bool",
            "doc": "<p>  Allows contracting simple braced statements to a single line.</p>\n<p>  E.g., this allows <code>if (a) { return; }</code> to be put on a single line.</p>\n"
        },
        "AllowShortCaseLabelsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, short case labels will be contracted to a single line.</p>\n<pre><code class=\"lang-  \">    true:                                   false:\n    switch (a) {                    vs.     switch (a) {\n    case 1: x = 1; break;                   case 1:\n    case 2: return;                           x = 1;\n    }                                         break;\n                                            case 2:\n                                              return;\n                                            }\n</code></pre>\n"
        },
        "AllowShortFunctionsOnASingleLine": {
            "type": "ShortFunctionStyle",
            "doc": "<p>  Dependent on the value, <code>int f() { return 0; }</code> can be put on a\n  single line.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>SFS_None</code> (in configuration: <code>None</code>)\nNever merge functions into a single line.</p>\n</li>\n<li><p><code>SFS_InlineOnly</code> (in configuration: <code>InlineOnly</code>)\nOnly merge functions defined inside a class. Same as &quot;inline&quot;,\nexcept it does not implies &quot;empty&quot;: i.e. top level empty functions\nare not merged either.</p>\n<pre><code>  class Foo {\n    void f() { foo(); }\n  };\n  void f() {\n    foo();\n  }\n  void f() {\n  }\n</code></pre></li>\n<li><p><code>SFS_Empty</code> (in configuration: <code>Empty</code>)\nOnly merge empty functions.</p>\n<pre><code>  void f() {}\n  void f2() {\n    bar2();\n  }\n</code></pre></li>\n<li><p><code>SFS_Inline</code> (in configuration: <code>Inline</code>)\nOnly merge functions defined inside a class. Implies &quot;empty&quot;.</p>\n<pre><code>  class Foo {\n    void f() { foo(); }\n  };\n  void f() {\n    foo();\n  }\n  void f() {}\n</code></pre></li>\n<li><p><code>SFS_All</code> (in configuration: <code>All</code>)\nMerge all functions fitting on a single line.</p>\n<pre><code>  class Foo {\n    void f() { foo(); }\n  };\n  void f() { bar(); }\n</code></pre></li>\n</ul>\n",
            "options": [
                "None",
                "InlineOnly",
                "Empty",
                "Inline",
                "All"
            ]
        },
        "AllowShortIfStatementsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>if (a) return;</code> can be put on a single line.</p>\n"
        },
        "AllowShortLoopsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>while (true) continue;</code> can be put on a single\n  line.</p>\n"
        },
        "AlwaysBreakAfterDefinitionReturnType": {
            "type": "DefinitionReturnTypeBreakingStyle",
            "doc": "<p>  The function definition return type breaking style to use.  This\n  option is <strong>deprecated</strong> and is retained for backwards compatibility.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>DRTBS_None</code> (in configuration: <code>None</code>)\nBreak after return type automatically.\n<code>PenaltyReturnTypeOnItsOwnLine</code> is taken into account.</p>\n</li>\n<li><p><code>DRTBS_All</code> (in configuration: <code>All</code>)\nAlways break after the return type.</p>\n</li>\n<li><p><code>DRTBS_TopLevel</code> (in configuration: <code>TopLevel</code>)\nAlways break after the return types of top-level functions.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "All",
                "TopLevel"
            ]
        },
        "AlwaysBreakAfterReturnType": {
            "type": "ReturnTypeBreakingStyle",
            "doc": "<p>  The function declaration return type breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>RTBS_None</code> (in configuration: <code>None</code>)\nBreak after return type automatically.\n<code>PenaltyReturnTypeOnItsOwnLine</code> is taken into account.</p>\n<pre><code>  class A {\n    int f() { return 0; };\n  };\n  int f();\n  int f() { return 1; }\n</code></pre></li>\n<li><p><code>RTBS_All</code> (in configuration: <code>All</code>)\nAlways break after the return type.</p>\n<pre><code>  class A {\n    int\n    f() {\n      return 0;\n    };\n  };\n  int\n  f();\n  int\n  f() {\n    return 1;\n  }\n</code></pre></li>\n<li><p><code>RTBS_TopLevel</code> (in configuration: <code>TopLevel</code>)\nAlways break after the return types of top-level functions.</p>\n<pre><code>  class A {\n    int f() { return 0; };\n  };\n  int\n  f();\n  int\n  f() {\n    return 1;\n  }\n</code></pre></li>\n<li><p><code>RTBS_AllDefinitions</code> (in configuration: <code>AllDefinitions</code>)\nAlways break after the return type of function definitions.</p>\n<pre><code>  class A {\n    int\n    f() {\n      return 0;\n    };\n  };\n  int f();\n  int\n  f() {\n    return 1;\n  }\n</code></pre></li>\n<li><p><code>RTBS_TopLevelDefinitions</code> (in configuration: <code>TopLevelDefinitions</code>)\nAlways break after the return type of top-level definitions.</p>\n<pre><code>  class A {\n    int f() { return 0; };\n  };\n  int f();\n  int\n  f() {\n    return 1;\n  }\n</code></pre></li>\n</ul>\n",
            "options": [
                "None",
                "All",
                "TopLevel",
                "AllDefinitions",
                "TopLevelDefinitions"
            ]
        },
        "AlwaysBreakBeforeMultilineStrings": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break before multiline string literals.</p>\n<p>  This flag is mean to make cases where there are multiple multiline strings\n  in a file look more consistent. Thus, it will only take effect if wrapping\n  the string at that point leads to it being indented\n  <code>ContinuationIndentWidth</code> spaces from the start of the line.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     aaaa =                         vs.     aaaa = &quot;bbbb&quot;\n         &quot;bbbb&quot;                                    &quot;cccc&quot;;\n         &quot;cccc&quot;;\n</code></pre>\n"
        },
        "AlwaysBreakTemplateDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break after the <code>template&lt;...&gt;</code> of a template\n  declaration.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     template &lt;typename T&gt;          vs.     template &lt;typename T&gt; class C {};\n     class C {};\n</code></pre>\n"
        },
        "BinPackArguments": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function call&#39;s arguments will either be all on the\n  same line or will have one line each.</p>\n<pre><code class=\"lang-  \">    true:\n    void f() {\n      f(aaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaa,\n        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\n    }\n</code></pre>\n<pre><code>false:\nvoid f() {\n  f(aaaaaaaaaaaaaaaaaaaa,\n    aaaaaaaaaaaaaaaaaaaa,\n    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\n}\n</code></pre>"
        },
        "BinPackParameters": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function declaration&#39;s or function definition&#39;s\n  parameters will either all be on the same line or will have one line each.</p>\n<pre><code class=\"lang-  \">    true:\n    void f(int aaaaaaaaaaaaaaaaaaaa, int aaaaaaaaaaaaaaaaaaaa,\n           int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\n</code></pre>\n<pre><code>false:\nvoid f(int aaaaaaaaaaaaaaaaaaaa,\n       int aaaaaaaaaaaaaaaaaaaa,\n       int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\n</code></pre>"
        },
        "BraceWrapping": {
            "type": "BraceWrappingFlags",
            "doc": "<p>  Control of individual brace wrapping cases.</p>\n<p>  If <code>BreakBeforeBraces</code> is set to <code>BS_Custom</code>, use this to specify how\n  each individual brace case should be handled. Otherwise, this is ignored.</p>\n<pre><code class=\"lang-  \">    # Example of usage:\n    BreakBeforeBraces: Custom\n    BraceWrapping:\n      AfterEnum: true\n      AfterStruct: false\n      SplitEmptyFunction: false\n</code></pre>\n<p>  Nested configuration flags:</p>\n<ul>\n<li><p><code>bool AfterClass</code> Wrap class definitions.</p>\n<pre><code>  true:\n  class foo {};\n</code></pre><p>  false:\n  class foo\n  {};</p>\n</li>\n<li><p><code>bool AfterControlStatement</code> Wrap control statements (<code>if</code>/<code>for</code>/<code>while</code>/<code>switch</code>/..).</p>\n<pre><code>  true:\n  if (foo())\n  {\n  } else\n  {}\n  for (int i = 0; i &lt; 10; ++i)\n  {}\n</code></pre><p>  false:\n  if (foo()) {\n  } else {\n  }\n  for (int i = 0; i &lt; 10; ++i) {\n  }</p>\n</li>\n<li><p><code>bool AfterEnum</code> Wrap enum definitions.</p>\n<pre><code>  true:\n  enum X : int\n  {\n    B\n  };\n</code></pre><p>  false:\n  enum X : int { B };</p>\n</li>\n<li><p><code>bool AfterFunction</code> Wrap function definitions.</p>\n<pre><code>  true:\n  void foo()\n  {\n    bar();\n    bar2();\n  }\n</code></pre><p>  false:\n  void foo() {</p>\n<pre><code>bar();\nbar2();\n</code></pre><p>  }</p>\n</li>\n<li><p><code>bool AfterNamespace</code> Wrap namespace definitions.</p>\n<pre><code>  true:\n  namespace\n  {\n  int foo();\n  int bar();\n  }\n</code></pre><p>  false:\n  namespace {\n  int foo();\n  int bar();\n  }</p>\n</li>\n<li><p><code>bool AfterObjCDeclaration</code> Wrap ObjC definitions (<code>@autoreleasepool</code>, interfaces, ..).</p>\n</li>\n<li><p><code>bool AfterStruct</code> Wrap struct definitions.</p>\n<pre><code>  true:\n  struct foo\n  {\n    int x;\n  };\n</code></pre><p>  false:\n  struct foo {</p>\n<pre><code>int x;\n</code></pre><p>  };</p>\n</li>\n<li><p><code>bool AfterUnion</code> Wrap union definitions.</p>\n<pre><code>  true:\n  union foo\n  {\n    int x;\n  }\n</code></pre><p>  false:\n  union foo {</p>\n<pre><code>int x;\n</code></pre><p>  }</p>\n</li>\n<li><p><code>bool AfterExternBlock</code> Wrap extern blocks.</p>\n<pre><code>  true:\n  extern &quot;C&quot;\n  {\n    int foo();\n  }\n</code></pre><p>  false:\n  extern &quot;C&quot; {\n  int foo();\n  }</p>\n</li>\n<li><p><code>bool BeforeCatch</code> Wrap before <code>catch</code>.</p>\n<pre><code>  true:\n  try {\n    foo();\n  }\n  catch () {\n  }\n</code></pre><p>  false:\n  try {</p>\n<pre><code>foo();\n</code></pre><p>  } catch () {\n  }</p>\n</li>\n<li><p><code>bool BeforeElse</code> Wrap before <code>else</code>.</p>\n<pre><code>  true:\n  if (foo()) {\n  }\n  else {\n  }\n</code></pre><p>  false:\n  if (foo()) {\n  } else {\n  }</p>\n</li>\n<li><p><code>bool IndentBraces</code> Indent the wrapped braces themselves.</p>\n</li>\n<li><p><code>bool SplitEmptyFunction</code> If <code>false</code>, empty function body can be put on a single line.\nThis option is used only if the opening brace of the function has\nalready been wrapped, i.e. the `AfterFunction` brace wrapping mode is\nset, and the function could/should not be put on a single line (as per\n`AllowShortFunctionsOnASingleLine` and constructor formatting options).</p>\n<pre><code>  int f()   vs.   inf f()\n  {}              {\n                  }\n</code></pre></li>\n<li><p><code>bool SplitEmptyRecord</code> If <code>false</code>, empty record (e.g. class, struct or union) body\ncan be put on a single line. This option is used only if the opening\nbrace of the record has already been wrapped, i.e. the `AfterClass`\n(for classes) brace wrapping mode is set.</p>\n<pre><code>  class Foo   vs.  class Foo\n  {}               {\n                   }\n</code></pre></li>\n<li><p><code>bool SplitEmptyNamespace</code> If <code>false</code>, empty namespace body can be put on a single line.\nThis option is used only if the opening brace of the namespace has\nalready been wrapped, i.e. the `AfterNamespace` brace wrapping mode is\nset.</p>\n<pre><code>  namespace Foo   vs.  namespace Foo\n  {}                   {\n                       }\n</code></pre></li>\n</ul>\n",
            "options": [
                "AfterClass",
                "AfterControlStatement",
                "AfterEnum",
                "AfterFunction",
                "AfterNamespace",
                "AfterObjCDeclaration",
                "AfterStruct",
                "AfterUnion",
                "AfterExternBlock",
                "BeforeCatch",
                "BeforeElse",
                "IndentBraces",
                "SplitEmptyFunction",
                "SplitEmptyRecord",
                "SplitEmptyNamespace"
            ]
        },
        "BreakAfterJavaFieldAnnotations": {
            "type": "bool",
            "doc": "<p>  Break after each annotation on a field in Java files.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     @Partial                       vs.     @Partial @Mock DataLoad loader;\n     @Mock\n     DataLoad loader;\n</code></pre>\n"
        },
        "BreakBeforeBinaryOperators": {
            "type": "BinaryOperatorStyle",
            "doc": "<p>  The way to wrap binary operators.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BOS_None</code> (in configuration: <code>None</code>)\nBreak after operators.</p>\n<pre><code>   LooooooooooongType loooooooooooooooooooooongVariable =\n       someLooooooooooooooooongFunction();\n</code></pre><p>   bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +</p>\n<pre><code>                    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==\n                aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &amp;&amp;\n            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &gt;\n                ccccccccccccccccccccccccccccccccccccccccc;\n</code></pre></li>\n<li><p><code>BOS_NonAssignment</code> (in configuration: <code>NonAssignment</code>)\nBreak before operators that aren&#39;t assignments.</p>\n<pre><code>   LooooooooooongType loooooooooooooooooooooongVariable =\n       someLooooooooooooooooongFunction();\n</code></pre><p>   bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</p>\n<pre><code>                    + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n                == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n            &amp;&amp; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n                   &gt; ccccccccccccccccccccccccccccccccccccccccc;\n</code></pre></li>\n<li><p><code>BOS_All</code> (in configuration: <code>All</code>)\nBreak before operators.</p>\n<pre><code>   LooooooooooongType loooooooooooooooooooooongVariable\n       = someLooooooooooooooooongFunction();\n</code></pre><p>   bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</p>\n<pre><code>                    + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n                == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n            &amp;&amp; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n                   &gt; ccccccccccccccccccccccccccccccccccccccccc;\n</code></pre></li>\n</ul>\n",
            "options": [
                "None",
                "NonAssignment",
                "All"
            ]
        },
        "BreakBeforeBraces": {
            "type": "BraceBreakingStyle",
            "doc": "<p>  The brace breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BS_Attach</code> (in configuration: <code>Attach</code>)\nAlways attach braces to surrounding context.</p>\n<pre><code>  try {\n    foo();\n  } catch () {\n  }\n  void foo() { bar(); }\n  class foo {};\n  if (foo()) {\n  } else {\n  }\n  enum X : int { A, B };\n</code></pre></li>\n<li><p><code>BS_Linux</code> (in configuration: <code>Linux</code>)\nLike <code>Attach</code>, but break before braces on function, namespace and\nclass definitions.</p>\n<pre><code>  try {\n    foo();\n  } catch () {\n  }\n  void foo() { bar(); }\n  class foo\n  {\n  };\n  if (foo()) {\n  } else {\n  }\n  enum X : int { A, B };\n</code></pre></li>\n<li><p><code>BS_Mozilla</code> (in configuration: <code>Mozilla</code>)\nLike <code>Attach</code>, but break before braces on enum, function, and record\ndefinitions.</p>\n<pre><code>  try {\n    foo();\n  } catch () {\n  }\n  void foo() { bar(); }\n  class foo\n  {\n  };\n  if (foo()) {\n  } else {\n  }\n  enum X : int { A, B };\n</code></pre></li>\n<li><p><code>BS_Stroustrup</code> (in configuration: <code>Stroustrup</code>)\nLike <code>Attach</code>, but break before function definitions, <code>catch</code>, and\n<code>else</code>.</p>\n<pre><code>  try {\n    foo();\n  } catch () {\n  }\n  void foo() { bar(); }\n  class foo\n  {\n  };\n  if (foo()) {\n  } else {\n  }\n  enum X : int\n  {\n    A,\n    B\n  };\n</code></pre></li>\n<li><p><code>BS_Allman</code> (in configuration: <code>Allman</code>)\nAlways break before braces.</p>\n<pre><code>  try {\n    foo();\n  }\n  catch () {\n  }\n  void foo() { bar(); }\n  class foo {\n  };\n  if (foo()) {\n  }\n  else {\n  }\n  enum X : int { A, B };\n</code></pre></li>\n<li><p><code>BS_GNU</code> (in configuration: <code>GNU</code>)\nAlways break before braces and add an extra level of indentation to\nbraces of control statements, not to those of class, function\nor other definitions.</p>\n<pre><code>  try\n    {\n      foo();\n    }\n  catch ()\n    {\n    }\n  void foo() { bar(); }\n  class foo\n  {\n  };\n  if (foo())\n    {\n    }\n  else\n    {\n    }\n  enum X : int\n  {\n    A,\n    B\n  };\n</code></pre></li>\n<li><p><code>BS_WebKit</code> (in configuration: <code>WebKit</code>)\nLike <code>Attach</code>, but break before functions.</p>\n<pre><code>  try {\n    foo();\n  } catch () {\n  }\n  void foo() { bar(); }\n  class foo {\n  };\n  if (foo()) {\n  } else {\n  }\n  enum X : int { A, B };\n</code></pre></li>\n<li><p><code>BS_Custom</code> (in configuration: <code>Custom</code>)\nConfigure each individual brace in `BraceWrapping`.</p>\n</li>\n</ul>\n",
            "options": [
                "Attach",
                "Linux",
                "Mozilla",
                "Stroustrup",
                "Allman",
                "GNU",
                "WebKit",
                "Custom"
            ]
        },
        "BreakBeforeInheritanceComma": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, in the class inheritance expression clang-format will\n  break before <code>:</code> and <code>,</code> if there is multiple inheritance.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     class MyClass                  vs.     class MyClass : public X, public Y {\n         : public X                         };\n         , public Y {\n     };\n</code></pre>\n"
        },
        "BreakBeforeTernaryOperators": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, ternary operators will be placed after line breaks.</p>\n<pre><code class=\"lang-  \">     true:\n     veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription\n         ? firstValue\n         : SecondValueVeryVeryVeryVeryLong;\n</code></pre>\n<pre><code> false:\n veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ?\n     firstValue :\n     SecondValueVeryVeryVeryVeryLong;\n</code></pre>"
        },
        "BreakConstructorInitializers": {
            "type": "BreakConstructorInitializersStyle",
            "doc": "<p>  The constructor initializers style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BCIS_BeforeColon</code> (in configuration: <code>BeforeColon</code>)\nBreak constructor initializers before the colon and after the commas.</p>\n<pre><code>  Constructor()\n      : initializer1(),\n        initializer2()\n</code></pre></li>\n<li><p><code>BCIS_BeforeComma</code> (in configuration: <code>BeforeComma</code>)\nBreak constructor initializers before the colon and commas, and align\nthe commas with the colon.</p>\n<pre><code>  Constructor()\n      : initializer1()\n      , initializer2()\n</code></pre></li>\n<li><p><code>BCIS_AfterColon</code> (in configuration: <code>AfterColon</code>)\nBreak constructor initializers after the colon and commas.</p>\n<pre><code>  Constructor() :\n      initializer1(),\n      initializer2()\n</code></pre></li>\n</ul>\n",
            "options": [
                "BeforeColon",
                "BeforeComma",
                "AfterColon"
            ]
        },
        "BreakStringLiterals": {
            "type": "bool",
            "doc": "<p>  Allow breaking string literals when formatting.</p>\n"
        },
        "ColumnLimit": {
            "type": "unsigned",
            "doc": "<p>  The column limit.</p>\n<p>  A column limit of <code>0</code> means that there is no column limit. In this case,\n  clang-format will respect the input&#39;s line breaking decisions within\n  statements unless they contradict other rules.</p>\n"
        },
        "CommentPragmas": {
            "type": "std::string",
            "doc": "<p>  A regular expression that describes comments with special meaning,\n  which should not be split into lines or otherwise changed.</p>\n<pre><code class=\"lang-  \">     // CommentPragmas: &#39;^ FOOBAR pragma:&#39;\n     // Will leave the following line unaffected\n     #include &lt;vector&gt; // FOOBAR pragma: keep\n</code></pre>\n"
        },
        "CompactNamespaces": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, consecutive namespace declarations will be on the same\n  line. If <code>false</code>, each namespace is declared on a new line.</p>\n<pre><code class=\"lang-  \">    true:\n    namespace Foo { namespace Bar {\n    }}\n</code></pre>\n<pre><code>false:\nnamespace Foo {\nnamespace Bar {\n}\n}\n</code></pre><p>  If it does not fit on a single line, the overflowing namespaces get\n  wrapped:</p>\n<pre><code class=\"lang-  \">    namespace Foo { namespace Bar {\n    namespace Extra {\n    }}}\n</code></pre>\n"
        },
        "ConstructorInitializerAllOnOneLineOrOnePerLine": {
            "type": "bool",
            "doc": "<p>  If the constructor initializers don&#39;t fit on a line, put each\n  initializer on its own line.</p>\n<pre><code class=\"lang-  \">    true:\n    SomeClass::Constructor()\n        : aaaaaaaa(aaaaaaaa), aaaaaaaa(aaaaaaaa), aaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaa) {\n      return 0;\n    }\n</code></pre>\n<pre><code>false:\nSomeClass::Constructor()\n    : aaaaaaaa(aaaaaaaa), aaaaaaaa(aaaaaaaa),\n      aaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaa) {\n  return 0;\n}\n</code></pre>"
        },
        "ConstructorInitializerIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of constructor\n  initializer lists.</p>\n"
        },
        "ContinuationIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  Indent width for line continuations.</p>\n<pre><code class=\"lang-  \">     ContinuationIndentWidth: 2\n</code></pre>\n<pre><code> int i =         //  VeryVeryVeryVeryVeryLongComment\n   longFunction( // Again a long comment\n     arg);\n</code></pre>"
        },
        "Cpp11BracedListStyle": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, format braced lists as best suited for C++11 braced\n  lists.</p>\n<p>  Important differences:</p>\n<ul>\n<li>No spaces inside the braced list.</li>\n<li>No line break before the closing brace.</li>\n<li><p>Indentation with the continuation indent, not with the block indent.</p>\n<p>Fundamentally, C++11 braced lists are formatted exactly like function\ncalls would be formatted in their place. If the braced list follows a name\n(e.g. a type or variable name), clang-format formats as if the <code>{}</code> were\nthe parentheses of a function call with that name. If there is no name,\na zero-length name is assumed.</p>\n<pre><code> true:                                  false:\n vector&lt;int&gt; x{1, 2, 3, 4};     vs.     vector&lt;int&gt; x{ 1, 2, 3, 4 };\n vector&lt;T&gt; x{{}, {}, {}, {}};           vector&lt;T&gt; x{ {}, {}, {}, {} };\n f(MyMap[{composite, key}]);            f(MyMap[{ composite, key }]);\n new int[3]{1, 2, 3};                   new int[3]{ 1, 2, 3 };\n</code></pre></li>\n</ul>\n"
        },
        "DerivePointerAlignment": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, analyze the formatted file for the most common\n  alignment of <code>&amp;</code> and <code>*</code>.\n  Pointer and reference alignment styles are going to be updated according\n  to the preferences found in the file.\n  <code>PointerAlignment</code> is then used only as fallback.</p>\n"
        },
        "DisableFormat": {
            "type": "bool",
            "doc": "<p>  Disables formatting completely.</p>\n"
        },
        "ExperimentalAutoDetectBinPacking": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format detects whether function calls and\n  definitions are formatted with one parameter per line.</p>\n<p>  Each call can be bin-packed, one-per-line or inconclusive. If it is\n  inconclusive, e.g. completely on one line, but a decision needs to be\n  made, clang-format analyzes whether there are other bin-packed cases in\n  the input file and act accordingly.</p>\n<p>  NOTE: This is an experimental flag, that might go away or be renamed. Do\n  not use this in config files, etc. Use at your own risk.</p>\n"
        },
        "FixNamespaceComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format adds missing namespace end comments and\n  fixes invalid existing ones.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     namespace a {                  vs.     namespace a {\n     foo();                                 foo();\n     } // namespace a;                      }\n</code></pre>\n"
        },
        "ForEachMacros": {
            "type": "std::vector<std::string>",
            "doc": "<p>  A vector of macros that should be interpreted as foreach loops\n  instead of as function calls.</p>\n<p>  These are expected to be macros of the form:</p>\n<pre><code class=\"lang-  \">    FOREACH(&lt;variable-declaration&gt;, ...)\n      &lt;loop-body&gt;\n</code></pre>\n<p>  In the .clang-format configuration file, this can be configured like:</p>\n<pre><code class=\"lang-  \">    ForEachMacros: [&#39;RANGES_FOR&#39;, &#39;FOREACH&#39;]\n</code></pre>\n<p>  For example: BOOST_FOREACH.</p>\n"
        },
        "IncludeBlocks": {
            "type": "IncludeBlocksStyle",
            "doc": "<p>  Dependent on the value, multiple <code>#include</code> blocks can be sorted\n  as one and divided based on category.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>IBS_Preserve</code> (in configuration: <code>Preserve</code>)\nSort each <code>#include</code> block separately.</p>\n<pre><code>   #include &quot;b.h&quot;               into      #include &quot;b.h&quot;\n</code></pre><p>   #include &lt;lib/main.h&gt;                  #include &quot;a.h&quot;\n   #include &quot;a.h&quot;                         #include &lt;lib/main.h&gt;</p>\n</li>\n<li><p><code>IBS_Merge</code> (in configuration: <code>Merge</code>)\nMerge multiple <code>#include</code> blocks together and sort as one.</p>\n<pre><code>   #include &quot;b.h&quot;               into      #include &quot;a.h&quot;\n                                          #include &quot;b.h&quot;\n   #include &lt;lib/main.h&gt;                  #include &lt;lib/main.h&gt;\n   #include &quot;a.h&quot;\n</code></pre></li>\n<li><p><code>IBS_Regroup</code> (in configuration: <code>Regroup</code>)\nMerge multiple <code>#include</code> blocks together and sort as one.\nThen split into groups based on category priority. See <code>IncludeCategories</code>.</p>\n<pre><code>   #include &quot;b.h&quot;               into      #include &quot;a.h&quot;\n                                          #include &quot;b.h&quot;\n   #include &lt;lib/main.h&gt;\n   #include &quot;a.h&quot;                         #include &lt;lib/main.h&gt;\n</code></pre></li>\n</ul>\n",
            "options": [
                "Preserve",
                "Merge",
                "Regroup"
            ]
        },
        "IncludeCategories": {
            "type": "std::vector<IncludeCategory>",
            "doc": "<p>  Regular expressions denoting the different <code>#include</code> categories\n  used for ordering <code>#includes</code>.</p>\n<p>  These regular expressions are matched against the filename of an include\n  (including the &lt;&gt; or &quot;&quot;) in order. The value belonging to the first\n  matching regular expression is assigned and <code>#includes</code> are sorted first\n  according to increasing category number and then alphabetically within\n  each category.</p>\n<p>  If none of the regular expressions match, INT_MAX is assigned as\n  category. The main header for a source file automatically gets category 0.\n  so that it is generally kept at the beginning of the <code>#includes</code>\n  (http://llvm.org/docs/CodingStandards.html#include-style). However, you\n  can also assign negative priorities if you have certain headers that\n  always need to be first.</p>\n<p>  To configure this in the .clang-format file, use:</p>\n<pre><code class=\"lang-  \">    IncludeCategories:\n      - Regex:           &#39;^&quot;(llvm|llvm-c|clang|clang-c)/&#39;\n        Priority:        2\n      - Regex:           &#39;^(&lt;|&quot;(gtest|gmock|isl|json)/)&#39;\n        Priority:        3\n      - Regex:           &#39;.*&#39;\n        Priority:        1\n</code></pre>\n",
            "options": []
        },
        "IncludeIsMainRegex": {
            "type": "std::string",
            "doc": "<p>  Specify a regular expression of suffixes that are allowed in the\n  file-to-main-include mapping.</p>\n<p>  When guessing whether a #include is the &quot;main&quot; include (to assign\n  category 0, see above), use this regex of allowed suffixes to the header\n  stem. A partial match is done, so that:</p>\n<ul>\n<li>&quot;&quot; means &quot;arbitrary suffix&quot;</li>\n<li><p>&quot;$&quot; means &quot;no suffix&quot;</p>\n<p>For example, if configured to &quot;(_test)?$&quot;, then a header a.h would be seen\nas the &quot;main&quot; include in both a.cc and a_test.cc.</p>\n</li>\n</ul>\n"
        },
        "IndentCaseLabels": {
            "type": "bool",
            "doc": "<p>  Indent case labels one level from the switch statement.</p>\n<p>  When <code>false</code>, use the same indentation level as for the switch statement.\n  Switch statement body is always indented one level more than case labels.</p>\n<pre><code class=\"lang-  \">     false:                                 true:\n     switch (fool) {                vs.     switch (fool) {\n     case 1:                                  case 1:\n       bar();                                   bar();\n       break;                                   break;\n     default:                                 default:\n       plop();                                  plop();\n     }                                      }\n</code></pre>\n"
        },
        "IndentPPDirectives": {
            "type": "PPDirectiveIndentStyle",
            "doc": "<p>  The preprocessor directive indenting style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>PPDIS_None</code> (in configuration: <code>None</code>)\nDoes not indent any directives.</p>\n<pre><code>   #if FOO\n   #if BAR\n   #include &lt;foo&gt;\n   #endif\n   #endif\n</code></pre></li>\n<li><p><code>PPDIS_AfterHash</code> (in configuration: <code>AfterHash</code>)\nIndents directives after the hash.</p>\n<pre><code>   #if FOO\n   #  if BAR\n   #    include &lt;foo&gt;\n   #  endif\n   #endif\n</code></pre></li>\n</ul>\n",
            "options": [
                "None",
                "AfterHash"
            ]
        },
        "IndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns to use for indentation.</p>\n<pre><code class=\"lang-  \">     IndentWidth: 3\n</code></pre>\n<pre><code> void f() {\n    someFunction();\n    if (true, false) {\n       f();\n    }\n }\n</code></pre>"
        },
        "IndentWrappedFunctionNames": {
            "type": "bool",
            "doc": "<p>  Indent if a function definition or declaration is wrapped after the\n  type.</p>\n<pre><code class=\"lang-  \">     true:\n     LoooooooooooooooooooooooooooooooooooooooongReturnType\n         LoooooooooooooooooooooooooooooooongFunctionDeclaration();\n</code></pre>\n<pre><code> false:\n LoooooooooooooooooooooooooooooooooooooooongReturnType\n LoooooooooooooooooooooooooooooooongFunctionDeclaration();\n</code></pre>"
        },
        "JavaScriptQuotes": {
            "type": "JavaScriptQuoteStyle",
            "doc": "<p>  The JavaScriptQuoteStyle to use for JavaScript strings.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>JSQS_Leave</code> (in configuration: <code>Leave</code>)\nLeave string quotes as they are.</p>\n<pre><code>   string1 = &quot;foo&quot;;\n   string2 = &#39;bar&#39;;\n</code></pre></li>\n<li><p><code>JSQS_Single</code> (in configuration: <code>Single</code>)\nAlways use single quotes.</p>\n<pre><code>   string1 = &#39;foo&#39;;\n   string2 = &#39;bar&#39;;\n</code></pre></li>\n<li><p><code>JSQS_Double</code> (in configuration: <code>Double</code>)\nAlways use double quotes.</p>\n<pre><code>   string1 = &quot;foo&quot;;\n   string2 = &quot;bar&quot;;\n</code></pre></li>\n</ul>\n",
            "options": [
                "Leave",
                "Single",
                "Double"
            ]
        },
        "JavaScriptWrapImports": {
            "type": "bool",
            "doc": "<p>  Whether to wrap JavaScript import/export statements.</p>\n<pre><code class=\"lang-  \">     true:\n     import {\n         VeryLongImportsAreAnnoying,\n         VeryLongImportsAreAnnoying,\n         VeryLongImportsAreAnnoying,\n     } from &#39;some/module.js&#39;\n</code></pre>\n<pre><code> false:\n import {VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying,} from &quot;some/module.js&quot;\n</code></pre>"
        },
        "KeepEmptyLinesAtTheStartOfBlocks": {
            "type": "bool",
            "doc": "<p>  If true, the empty line at the start of blocks is kept.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     if (foo) {                     vs.     if (foo) {\n                                              bar();\n       bar();                               }\n     }\n</code></pre>\n"
        },
        "Language": {
            "type": "LanguageKind",
            "doc": "<p>  Language, this format style is targeted at.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>LK_None</code> (in configuration: <code>None</code>)\nDo not use.</p>\n</li>\n<li><p><code>LK_Cpp</code> (in configuration: <code>Cpp</code>)\nShould be used for C, C++.</p>\n</li>\n<li><p><code>LK_Java</code> (in configuration: <code>Java</code>)\nShould be used for Java.</p>\n</li>\n<li><p><code>LK_JavaScript</code> (in configuration: <code>JavaScript</code>)\nShould be used for JavaScript.</p>\n</li>\n<li><p><code>LK_ObjC</code> (in configuration: <code>ObjC</code>)\nShould be used for Objective-C, Objective-C++.</p>\n</li>\n<li><p><code>LK_Proto</code> (in configuration: <code>Proto</code>)\nShould be used for Protocol Buffers\n(https://developers.google.com/protocol-buffers/).</p>\n</li>\n<li><p><code>LK_TableGen</code> (in configuration: <code>TableGen</code>)\nShould be used for TableGen code.</p>\n</li>\n<li><p><code>LK_TextProto</code> (in configuration: <code>TextProto</code>)\nShould be used for Protocol Buffer messages in text format\n(https://developers.google.com/protocol-buffers/).</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "Cpp",
                "Java",
                "JavaScript",
                "ObjC",
                "Proto",
                "TableGen",
                "TextProto"
            ]
        },
        "MacroBlockBegin": {
            "type": "std::string",
            "doc": "<p>  A regular expression matching macros that start a block.</p>\n<pre><code class=\"lang-  \">     # With:\n     MacroBlockBegin: &quot;^NS_MAP_BEGIN|\\\n     NS_TABLE_HEAD$&quot;\n     MacroBlockEnd: &quot;^\\\n     NS_MAP_END|\\\n     NS_TABLE_.*_END$&quot;\n</code></pre>\n<pre><code> NS_MAP_BEGIN\n   foo();\n NS_MAP_END\n\n NS_TABLE_HEAD\n   bar();\n NS_TABLE_FOO_END\n\n # Without:\n NS_MAP_BEGIN\n foo();\n NS_MAP_END\n\n NS_TABLE_HEAD\n bar();\n NS_TABLE_FOO_END\n</code></pre>"
        },
        "MacroBlockEnd": {
            "type": "std::string",
            "doc": "<p>  A regular expression matching macros that end a block.</p>\n"
        },
        "MaxEmptyLinesToKeep": {
            "type": "unsigned",
            "doc": "<p>  The maximum number of consecutive empty lines to keep.</p>\n<pre><code class=\"lang-  \">     MaxEmptyLinesToKeep: 1         vs.     MaxEmptyLinesToKeep: 0\n     int f() {                              int f() {\n       int = 1;                                 int i = 1;\n                                                i = foo();\n       i = foo();                               return i;\n                                            }\n       return i;\n     }\n</code></pre>\n"
        },
        "NamespaceIndentation": {
            "type": "NamespaceIndentationKind",
            "doc": "<p>  The indentation used for namespaces.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>NI_None</code> (in configuration: <code>None</code>)\nDon&#39;t indent in namespaces.</p>\n<pre><code>   namespace out {\n   int i;\n   namespace in {\n   int i;\n   }\n   }\n</code></pre></li>\n<li><p><code>NI_Inner</code> (in configuration: <code>Inner</code>)\nIndent only in inner namespaces (nested in other namespaces).</p>\n<pre><code>   namespace out {\n   int i;\n   namespace in {\n     int i;\n   }\n   }\n</code></pre></li>\n<li><p><code>NI_All</code> (in configuration: <code>All</code>)\nIndent in all namespaces.</p>\n<pre><code>   namespace out {\n     int i;\n     namespace in {\n       int i;\n     }\n   }\n</code></pre></li>\n</ul>\n",
            "options": [
                "None",
                "Inner",
                "All"
            ]
        },
        "ObjCBlockIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of ObjC blocks.</p>\n<pre><code class=\"lang-  \">     ObjCBlockIndentWidth: 4\n</code></pre>\n<pre><code> [operation setCompletionBlock:^{\n     [self onOperationDone];\n }];\n</code></pre>"
        },
        "ObjCSpaceAfterProperty": {
            "type": "bool",
            "doc": "<p>  Add a space after <code>@property</code> in Objective-C, i.e. use\n  <code>@property (readonly)</code> instead of <code>@property(readonly)</code>.</p>\n"
        },
        "ObjCSpaceBeforeProtocolList": {
            "type": "bool",
            "doc": "<p>  Add a space in front of an Objective-C protocol list, i.e. use\n  <code>Foo &lt;Protocol&gt;</code> instead of <code>Foo&lt;Protocol&gt;</code>.</p>\n"
        },
        "PenaltyBreakAssignment": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking around an assignment operator.</p>\n"
        },
        "PenaltyBreakBeforeFirstCallParameter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking a function call after <code>call(</code>.</p>\n"
        },
        "PenaltyBreakComment": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a comment.</p>\n"
        },
        "PenaltyBreakFirstLessLess": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking before the first <code>&lt;&lt;</code>.</p>\n"
        },
        "PenaltyBreakString": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a string literal.</p>\n"
        },
        "PenaltyExcessCharacter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each character outside of the column limit.</p>\n"
        },
        "PenaltyReturnTypeOnItsOwnLine": {
            "type": "unsigned",
            "doc": "<p>  Penalty for putting the return type of a function onto its own\n  line.</p>\n"
        },
        "PointerAlignment": {
            "type": "PointerAlignmentStyle",
            "doc": "<p>  Pointer and reference alignment style.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>PAS_Left</code> (in configuration: <code>Left</code>)\nAlign pointer to the left.</p>\n<pre><code>  int* a;\n</code></pre></li>\n<li><p><code>PAS_Right</code> (in configuration: <code>Right</code>)\nAlign pointer to the right.</p>\n<pre><code>  int *a;\n</code></pre></li>\n<li><p><code>PAS_Middle</code> (in configuration: <code>Middle</code>)\nAlign pointer in the middle.</p>\n<pre><code>  int * a;\n</code></pre></li>\n</ul>\n",
            "options": [
                "Left",
                "Right",
                "Middle"
            ]
        },
        "RawStringFormats": {
            "type": "std::vector<RawStringFormat>",
            "doc": "<p>  Raw string delimiters denoting that the raw string contents are\n  code in a particular language and can be reformatted.</p>\n<p>  A raw string with a matching delimiter will be reformatted assuming the\n  specified language based on a predefined style given by &#39;BasedOnStyle&#39;.\n  If &#39;BasedOnStyle&#39; is not found, the formatting is based on llvm style.</p>\n<p>  To configure this in the .clang-format file, use:</p>\n<pre><code class=\"lang-  \">    RawStringFormats:\n      - Delimiter: &#39;pb&#39;\n        Language:  TextProto\n        BasedOnStyle: llvm\n      - Delimiter: &#39;proto&#39;\n        Language:  TextProto\n        BasedOnStyle: google\n</code></pre>\n",
            "options": []
        },
        "ReflowComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format will attempt to re-flow comments.</p>\n<pre><code class=\"lang-  \">     false:\n     // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information\n     /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */\n</code></pre>\n<pre><code> true:\n // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of\n // information\n /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of\n  * information */\n</code></pre>"
        },
        "SortIncludes": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format will sort <code>#includes</code>.</p>\n<pre><code class=\"lang-  \">     false:                                 true:\n     #include &quot;b.h&quot;                 vs.     #include &quot;a.h&quot;\n     #include &quot;a.h&quot;                         #include &quot;b.h&quot;\n</code></pre>\n"
        },
        "SortUsingDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format will sort using declarations.</p>\n<p>  The order of using declarations is defined as follows:\n  Split the strings by &quot;::&quot; and discard any initial empty strings. The last\n  element of each list is a non-namespace name; all others are namespace\n  names. Sort the lists of names lexicographically, where the sort order of\n  individual names is that all non-namespace names come before all namespace\n  names, and within those groups, names are in case-insensitive\n  lexicographic order.</p>\n<pre><code class=\"lang-  \">     false:                                 true:\n     using std::cout;               vs.     using std::cin;\n     using std::cin;                        using std::cout;\n</code></pre>\n"
        },
        "SpaceAfterCStyleCast": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, a space is inserted after C style casts.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     (int)i;                        vs.     (int) i;\n</code></pre>\n"
        },
        "SpaceAfterTemplateKeyword": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, a space will be inserted after the &#39;template&#39; keyword.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     template &lt;int&gt; void foo();     vs.     template&lt;int&gt; void foo();\n</code></pre>\n"
        },
        "SpaceBeforeAssignmentOperators": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, spaces will be removed before assignment operators.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     int a = 5;                     vs.     int a=5;\n     a += 42                                a+=42;\n</code></pre>\n"
        },
        "SpaceBeforeParens": {
            "type": "SpaceBeforeParensOptions",
            "doc": "<p>  Defines in which cases to put a space before opening parentheses.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>SBPO_Never</code> (in configuration: <code>Never</code>)\nNever put a space before opening parentheses.</p>\n<pre><code>   void f() {\n     if(true) {\n       f();\n     }\n   }\n</code></pre></li>\n<li><p><code>SBPO_ControlStatements</code> (in configuration: <code>ControlStatements</code>)\nPut a space before opening parentheses only after control statement\nkeywords (<code>for/if/while...</code>).</p>\n<pre><code>   void f() {\n     if (true) {\n       f();\n     }\n   }\n</code></pre></li>\n<li><p><code>SBPO_Always</code> (in configuration: <code>Always</code>)\nAlways put a space before opening parentheses, except when it&#39;s\nprohibited by the syntax rules (in function-like macro definitions) or\nwhen determined by other style rules (after unary operators, opening\nparentheses, etc.)</p>\n<pre><code>   void f () {\n     if (true) {\n       f ();\n     }\n   }\n</code></pre></li>\n</ul>\n",
            "options": [
                "Never",
                "ControlStatements",
                "Always"
            ]
        },
        "SpaceInEmptyParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into <code>()</code>.</p>\n<pre><code class=\"lang-  \">     true:                                false:\n     void f( ) {                    vs.   void f() {\n       int x[] = {foo( ), bar( )};          int x[] = {foo(), bar()};\n       if (true) {                          if (true) {\n         f( );                                f();\n       }                                    }\n     }                                    }\n</code></pre>\n"
        },
        "SpacesBeforeTrailingComments": {
            "type": "unsigned",
            "doc": "<p>  The number of spaces before trailing line comments\n  (<code>//</code> - comments).</p>\n<p>  This does not affect trailing block comments (<code>/*</code> - comments) as\n  those commonly have different usage patterns and a number of special\n  cases.</p>\n<pre><code class=\"lang-  \">     SpacesBeforeTrailingComments: 3\n     void f() {\n       if (true) {   // foo1\n         f();        // bar\n       }             // foo\n     }\n</code></pre>\n"
        },
        "SpacesInAngles": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>&lt;</code> and before <code>&gt;</code>\n  in template argument lists.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     static_cast&lt; int &gt;(arg);       vs.     static_cast&lt;int&gt;(arg);\n     std::function&lt; void(int) &gt; fct;        std::function&lt;void(int)&gt; fct;\n</code></pre>\n"
        },
        "SpacesInCStyleCastParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into C style casts.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     x = ( int32 )y                 vs.     x = (int32)y\n</code></pre>\n"
        },
        "SpacesInContainerLiterals": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces are inserted inside container literals (e.g.\n  ObjC and Javascript array and dict literals).</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     var arr = [ 1, 2, 3 ];         vs.     var arr = [1, 2, 3];\n     f({a : 1, b : 2, c : 3});              f({a: 1, b: 2, c: 3});\n</code></pre>\n"
        },
        "SpacesInParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>(</code> and before <code>)</code>.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     t f( Deleted &amp; ) &amp; = delete;   vs.     t f(Deleted &amp;) &amp; = delete;\n</code></pre>\n"
        },
        "SpacesInSquareBrackets": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>[</code> and before <code>]</code>.\n  Lambdas or unspecified size array declarations will not be affected.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     int a[ 5 ];                    vs.     int a[5];\n     std::unique_ptr&lt;int[]&gt; foo() {} // Won&#39;t be affected\n</code></pre>\n"
        },
        "Standard": {
            "type": "LanguageStandard",
            "doc": "<p>  Format compatible with this standard, e.g. use <code>A&lt;A&lt;int&gt; &gt;</code>\n  instead of <code>A&lt;A&lt;int&gt;&gt;</code> for <code>LS_Cpp03</code>.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>LS_Cpp03</code> (in configuration: <code>Cpp03</code>)\nUse C++03-compatible syntax.</p>\n</li>\n<li><p><code>LS_Cpp11</code> (in configuration: <code>Cpp11</code>)\nUse features of C++11, C++14 and C++1z (e.g. <code>A&lt;A&lt;int&gt;&gt;</code> instead of\n<code>A&lt;A&lt;int&gt; &gt;</code>).</p>\n</li>\n<li><p><code>LS_Auto</code> (in configuration: <code>Auto</code>)\nAutomatic detection based on the input.</p>\n</li>\n</ul>\n",
            "options": [
                "Cpp03",
                "Cpp11",
                "Auto"
            ]
        },
        "TabWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns used for tab stops.</p>\n"
        },
        "UseTab": {
            "type": "UseTabStyle",
            "doc": "<p>  The way to use tab characters in the resulting file.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>UT_Never</code> (in configuration: <code>Never</code>)\nNever use tab.</p>\n</li>\n<li><p><code>UT_ForIndentation</code> (in configuration: <code>ForIndentation</code>)\nUse tabs only for indentation.</p>\n</li>\n<li><p><code>UT_ForContinuationAndIndentation</code> (in configuration: <code>ForContinuationAndIndentation</code>)\nUse tabs only for line continuation and indentation.</p>\n</li>\n<li><p><code>UT_Always</code> (in configuration: <code>Always</code>)\nUse tabs whenever we need to fill whitespace that spans at least from\none tab stop to the next one.</p>\n</li>\n</ul>\n",
            "options": [
                "Never",
                "ForIndentation",
                "ForContinuationAndIndentation",
                "Always"
            ]
        }
    },
    "6.0.1": {
        "BasedOnStyle": {
            "type": "string",
            "doc": "<p>  The style used for all options not specifically set in the configuration.</p>\n<p>  This option is supported only in the <strong>clang-format</strong> configuration\n  (both within <code>-style=&#39;{...}&#39;</code> and the <code>.clang-format</code> file).</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LLVM</code>\nA style complying with the <a href=\"http://llvm.org/docs/CodingStandards.html\">LLVM coding standards</a></li>\n<li><code>Google</code>\nA style complying with <a href=\"http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml\">Google&#39;s C++ style guide</a></li>\n<li><code>Chromium</code>\nA style complying with <a href=\"http://www.chromium.org/developers/coding-style\">Chromium&#39;s style guide</a></li>\n<li><code>Mozilla</code>\nA style complying with <a href=\"https://developer.mozilla.org/en-US/docs/Developer_Guide/Coding_Style\">Mozilla&#39;s style guide</a></li>\n<li><code>WebKit</code>\nA style complying with <a href=\"http://www.webkit.org/coding/coding-style.html\">WebKit&#39;s style guide</a></li>\n</ul>\n",
            "options": [
                "LLVM",
                "Google",
                "Chromium",
                "Mozilla",
                "WebKit"
            ]
        },
        "AccessModifierOffset": {
            "type": "int",
            "doc": "<p>  The extra indent or outdent of access modifiers, e.g. <code>public:</code>.</p>\n"
        },
        "AlignAfterOpenBracket": {
            "type": "BracketAlignmentStyle",
            "doc": "<p>  If <code>true</code>, horizontally aligns arguments after an open bracket.</p>\n<p>  This applies to round brackets (parentheses), angle brackets and square\n  brackets.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BAS_Align</code> (in configuration: <code>Align</code>)\nAlign parameters on the open bracket, e.g.:</p>\n<pre><code>  someLongFunction(argument1,\n                   argument2);\n</code></pre></li>\n<li><p><code>BAS_DontAlign</code> (in configuration: <code>DontAlign</code>)\nDon&#39;t align, instead use <code>ContinuationIndentWidth</code>, e.g.:</p>\n<pre><code>  someLongFunction(argument1,\n      argument2);\n</code></pre></li>\n<li><p><code>BAS_AlwaysBreak</code> (in configuration: <code>AlwaysBreak</code>)\nAlways break after an open bracket, if the parameters don&#39;t fit\non a single line, e.g.:</p>\n<pre><code>  someLongFunction(\n      argument1, argument2);\n</code></pre></li>\n</ul>\n",
            "options": [
                "Align",
                "DontAlign",
                "AlwaysBreak"
            ]
        },
        "AlignConsecutiveAssignments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns consecutive assignments.</p>\n<p>  This will align the assignment operators of consecutive lines. This\n  will result in formattings like</p>\n<pre><code class=\"lang-  \">    int aaaa = 12;\n    int b    = 23;\n    int ccc  = 23;\n</code></pre>\n"
        },
        "AlignConsecutiveDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns consecutive declarations.</p>\n<p>  This will align the declaration names of consecutive lines. This\n  will result in formattings like</p>\n<pre><code class=\"lang-  \">    int         aaaa = 12;\n    float       b = 23;\n    std::string ccc = 23;\n</code></pre>\n"
        },
        "AlignEscapedNewlines": {
            "type": "EscapedNewlineAlignmentStyle",
            "doc": "<p>  Options for aligning backslashes in escaped newlines.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>ENAS_DontAlign</code> (in configuration: <code>DontAlign</code>)\nDon&#39;t align escaped newlines.</p>\n<pre><code>  #define A \\\n    int aaaa; \\\n    int b; \\\n    int dddddddddd;\n</code></pre></li>\n<li><p><code>ENAS_Left</code> (in configuration: <code>Left</code>)\nAlign escaped newlines as far left as possible.</p>\n<pre><code>  true:\n  #define A   \\\n    int aaaa; \\\n    int b;    \\\n    int dddddddddd;\n</code></pre><p>  false:</p>\n</li>\n<li><p><code>ENAS_Right</code> (in configuration: <code>Right</code>)\nAlign escaped newlines in the right-most column.</p>\n<pre><code>  #define A                                                                      \\\n    int aaaa;                                                                    \\\n    int b;                                                                       \\\n    int dddddddddd;\n</code></pre></li>\n</ul>\n",
            "options": [
                "DontAlign",
                "Left",
                "Right"
            ]
        },
        "AlignOperands": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, horizontally align operands of binary and ternary\n  expressions.</p>\n<p>  Specifically, this aligns operands of a single expression that needs to be\n  split over multiple lines, e.g.:</p>\n<pre><code class=\"lang-  \">    int aaa = bbbbbbbbbbbbbbb +\n              ccccccccccccccc;\n</code></pre>\n"
        },
        "AlignTrailingComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns trailing comments.</p>\n<pre><code class=\"lang-  \">    true:                                   false:\n    int a;     // My comment a      vs.     int a; // My comment a\n    int b = 2; // comment  b                int b = 2; // comment about b\n</code></pre>\n"
        },
        "AllowAllParametersOfDeclarationOnNextLine": {
            "type": "bool",
            "doc": "<p>  If the function declaration doesn&#39;t fit on a line,\n  allow putting all parameters of a function declaration onto\n  the next line even if <code>BinPackParameters</code> is <code>false</code>.</p>\n<pre><code class=\"lang-  \">    true:\n    void myFunction(\n        int a, int b, int c, int d, int e);\n</code></pre>\n<pre><code>false:\nvoid myFunction(int a,\n                int b,\n                int c,\n                int d,\n                int e);\n</code></pre>"
        },
        "AllowShortBlocksOnASingleLine": {
            "type": "bool",
            "doc": "<p>  Allows contracting simple braced statements to a single line.</p>\n<p>  E.g., this allows <code>if (a) { return; }</code> to be put on a single line.</p>\n"
        },
        "AllowShortCaseLabelsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, short case labels will be contracted to a single line.</p>\n<pre><code class=\"lang-  \">    true:                                   false:\n    switch (a) {                    vs.     switch (a) {\n    case 1: x = 1; break;                   case 1:\n    case 2: return;                           x = 1;\n    }                                         break;\n                                            case 2:\n                                              return;\n                                            }\n</code></pre>\n"
        },
        "AllowShortFunctionsOnASingleLine": {
            "type": "ShortFunctionStyle",
            "doc": "<p>  Dependent on the value, <code>int f() { return 0; }</code> can be put on a\n  single line.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>SFS_None</code> (in configuration: <code>None</code>)\nNever merge functions into a single line.</p>\n</li>\n<li><p><code>SFS_InlineOnly</code> (in configuration: <code>InlineOnly</code>)\nOnly merge functions defined inside a class. Same as &quot;inline&quot;,\nexcept it does not implies &quot;empty&quot;: i.e. top level empty functions\nare not merged either.</p>\n<pre><code>  class Foo {\n    void f() { foo(); }\n  };\n  void f() {\n    foo();\n  }\n  void f() {\n  }\n</code></pre></li>\n<li><p><code>SFS_Empty</code> (in configuration: <code>Empty</code>)\nOnly merge empty functions.</p>\n<pre><code>  void f() {}\n  void f2() {\n    bar2();\n  }\n</code></pre></li>\n<li><p><code>SFS_Inline</code> (in configuration: <code>Inline</code>)\nOnly merge functions defined inside a class. Implies &quot;empty&quot;.</p>\n<pre><code>  class Foo {\n    void f() { foo(); }\n  };\n  void f() {\n    foo();\n  }\n  void f() {}\n</code></pre></li>\n<li><p><code>SFS_All</code> (in configuration: <code>All</code>)\nMerge all functions fitting on a single line.</p>\n<pre><code>  class Foo {\n    void f() { foo(); }\n  };\n  void f() { bar(); }\n</code></pre></li>\n</ul>\n",
            "options": [
                "None",
                "InlineOnly",
                "Empty",
                "Inline",
                "All"
            ]
        },
        "AllowShortIfStatementsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>if (a) return;</code> can be put on a single line.</p>\n"
        },
        "AllowShortLoopsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>while (true) continue;</code> can be put on a single\n  line.</p>\n"
        },
        "AlwaysBreakAfterDefinitionReturnType": {
            "type": "DefinitionReturnTypeBreakingStyle",
            "doc": "<p>  The function definition return type breaking style to use.  This\n  option is <strong>deprecated</strong> and is retained for backwards compatibility.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>DRTBS_None</code> (in configuration: <code>None</code>)\nBreak after return type automatically.\n<code>PenaltyReturnTypeOnItsOwnLine</code> is taken into account.</p>\n</li>\n<li><p><code>DRTBS_All</code> (in configuration: <code>All</code>)\nAlways break after the return type.</p>\n</li>\n<li><p><code>DRTBS_TopLevel</code> (in configuration: <code>TopLevel</code>)\nAlways break after the return types of top-level functions.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "All",
                "TopLevel"
            ]
        },
        "AlwaysBreakAfterReturnType": {
            "type": "ReturnTypeBreakingStyle",
            "doc": "<p>  The function declaration return type breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>RTBS_None</code> (in configuration: <code>None</code>)\nBreak after return type automatically.\n<code>PenaltyReturnTypeOnItsOwnLine</code> is taken into account.</p>\n<pre><code>  class A {\n    int f() { return 0; };\n  };\n  int f();\n  int f() { return 1; }\n</code></pre></li>\n<li><p><code>RTBS_All</code> (in configuration: <code>All</code>)\nAlways break after the return type.</p>\n<pre><code>  class A {\n    int\n    f() {\n      return 0;\n    };\n  };\n  int\n  f();\n  int\n  f() {\n    return 1;\n  }\n</code></pre></li>\n<li><p><code>RTBS_TopLevel</code> (in configuration: <code>TopLevel</code>)\nAlways break after the return types of top-level functions.</p>\n<pre><code>  class A {\n    int f() { return 0; };\n  };\n  int\n  f();\n  int\n  f() {\n    return 1;\n  }\n</code></pre></li>\n<li><p><code>RTBS_AllDefinitions</code> (in configuration: <code>AllDefinitions</code>)\nAlways break after the return type of function definitions.</p>\n<pre><code>  class A {\n    int\n    f() {\n      return 0;\n    };\n  };\n  int f();\n  int\n  f() {\n    return 1;\n  }\n</code></pre></li>\n<li><p><code>RTBS_TopLevelDefinitions</code> (in configuration: <code>TopLevelDefinitions</code>)\nAlways break after the return type of top-level definitions.</p>\n<pre><code>  class A {\n    int f() { return 0; };\n  };\n  int f();\n  int\n  f() {\n    return 1;\n  }\n</code></pre></li>\n</ul>\n",
            "options": [
                "None",
                "All",
                "TopLevel",
                "AllDefinitions",
                "TopLevelDefinitions"
            ]
        },
        "AlwaysBreakBeforeMultilineStrings": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break before multiline string literals.</p>\n<p>  This flag is mean to make cases where there are multiple multiline strings\n  in a file look more consistent. Thus, it will only take effect if wrapping\n  the string at that point leads to it being indented\n  <code>ContinuationIndentWidth</code> spaces from the start of the line.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     aaaa =                         vs.     aaaa = &quot;bbbb&quot;\n         &quot;bbbb&quot;                                    &quot;cccc&quot;;\n         &quot;cccc&quot;;\n</code></pre>\n"
        },
        "AlwaysBreakTemplateDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break after the <code>template&lt;...&gt;</code> of a template\n  declaration.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     template &lt;typename T&gt;          vs.     template &lt;typename T&gt; class C {};\n     class C {};\n</code></pre>\n"
        },
        "BinPackArguments": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function call&#39;s arguments will either be all on the\n  same line or will have one line each.</p>\n<pre><code class=\"lang-  \">    true:\n    void f() {\n      f(aaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaa,\n        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\n    }\n</code></pre>\n<pre><code>false:\nvoid f() {\n  f(aaaaaaaaaaaaaaaaaaaa,\n    aaaaaaaaaaaaaaaaaaaa,\n    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\n}\n</code></pre>"
        },
        "BinPackParameters": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function declaration&#39;s or function definition&#39;s\n  parameters will either all be on the same line or will have one line each.</p>\n<pre><code class=\"lang-  \">    true:\n    void f(int aaaaaaaaaaaaaaaaaaaa, int aaaaaaaaaaaaaaaaaaaa,\n           int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\n</code></pre>\n<pre><code>false:\nvoid f(int aaaaaaaaaaaaaaaaaaaa,\n       int aaaaaaaaaaaaaaaaaaaa,\n       int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\n</code></pre>"
        },
        "BraceWrapping": {
            "type": "BraceWrappingFlags",
            "doc": "<p>  Control of individual brace wrapping cases.</p>\n<p>  If <code>BreakBeforeBraces</code> is set to <code>BS_Custom</code>, use this to specify how\n  each individual brace case should be handled. Otherwise, this is ignored.</p>\n<pre><code class=\"lang-  \">    # Example of usage:\n    BreakBeforeBraces: Custom\n    BraceWrapping:\n      AfterEnum: true\n      AfterStruct: false\n      SplitEmptyFunction: false\n</code></pre>\n<p>  Nested configuration flags:</p>\n<ul>\n<li><p><code>bool AfterClass</code> Wrap class definitions.</p>\n<pre><code>  true:\n  class foo {};\n</code></pre><p>  false:\n  class foo\n  {};</p>\n</li>\n<li><p><code>bool AfterControlStatement</code> Wrap control statements (<code>if</code>/<code>for</code>/<code>while</code>/<code>switch</code>/..).</p>\n<pre><code>  true:\n  if (foo())\n  {\n  } else\n  {}\n  for (int i = 0; i &lt; 10; ++i)\n  {}\n</code></pre><p>  false:\n  if (foo()) {\n  } else {\n  }\n  for (int i = 0; i &lt; 10; ++i) {\n  }</p>\n</li>\n<li><p><code>bool AfterEnum</code> Wrap enum definitions.</p>\n<pre><code>  true:\n  enum X : int\n  {\n    B\n  };\n</code></pre><p>  false:\n  enum X : int { B };</p>\n</li>\n<li><p><code>bool AfterFunction</code> Wrap function definitions.</p>\n<pre><code>  true:\n  void foo()\n  {\n    bar();\n    bar2();\n  }\n</code></pre><p>  false:\n  void foo() {</p>\n<pre><code>bar();\nbar2();\n</code></pre><p>  }</p>\n</li>\n<li><p><code>bool AfterNamespace</code> Wrap namespace definitions.</p>\n<pre><code>  true:\n  namespace\n  {\n  int foo();\n  int bar();\n  }\n</code></pre><p>  false:\n  namespace {\n  int foo();\n  int bar();\n  }</p>\n</li>\n<li><p><code>bool AfterObjCDeclaration</code> Wrap ObjC definitions (<code>@autoreleasepool</code>, interfaces, ..).</p>\n</li>\n<li><p><code>bool AfterStruct</code> Wrap struct definitions.</p>\n<pre><code>  true:\n  struct foo\n  {\n    int x;\n  };\n</code></pre><p>  false:\n  struct foo {</p>\n<pre><code>int x;\n</code></pre><p>  };</p>\n</li>\n<li><p><code>bool AfterUnion</code> Wrap union definitions.</p>\n<pre><code>  true:\n  union foo\n  {\n    int x;\n  }\n</code></pre><p>  false:\n  union foo {</p>\n<pre><code>int x;\n</code></pre><p>  }</p>\n</li>\n<li><p><code>bool AfterExternBlock</code> Wrap extern blocks.</p>\n<pre><code>  true:\n  extern &quot;C&quot;\n  {\n    int foo();\n  }\n</code></pre><p>  false:\n  extern &quot;C&quot; {\n  int foo();\n  }</p>\n</li>\n<li><p><code>bool BeforeCatch</code> Wrap before <code>catch</code>.</p>\n<pre><code>  true:\n  try {\n    foo();\n  }\n  catch () {\n  }\n</code></pre><p>  false:\n  try {</p>\n<pre><code>foo();\n</code></pre><p>  } catch () {\n  }</p>\n</li>\n<li><p><code>bool BeforeElse</code> Wrap before <code>else</code>.</p>\n<pre><code>  true:\n  if (foo()) {\n  }\n  else {\n  }\n</code></pre><p>  false:\n  if (foo()) {\n  } else {\n  }</p>\n</li>\n<li><p><code>bool IndentBraces</code> Indent the wrapped braces themselves.</p>\n</li>\n<li><p><code>bool SplitEmptyFunction</code> If <code>false</code>, empty function body can be put on a single line.\nThis option is used only if the opening brace of the function has\nalready been wrapped, i.e. the `AfterFunction` brace wrapping mode is\nset, and the function could/should not be put on a single line (as per\n`AllowShortFunctionsOnASingleLine` and constructor formatting options).</p>\n<pre><code>  int f()   vs.   inf f()\n  {}              {\n                  }\n</code></pre></li>\n<li><p><code>bool SplitEmptyRecord</code> If <code>false</code>, empty record (e.g. class, struct or union) body\ncan be put on a single line. This option is used only if the opening\nbrace of the record has already been wrapped, i.e. the `AfterClass`\n(for classes) brace wrapping mode is set.</p>\n<pre><code>  class Foo   vs.  class Foo\n  {}               {\n                   }\n</code></pre></li>\n<li><p><code>bool SplitEmptyNamespace</code> If <code>false</code>, empty namespace body can be put on a single line.\nThis option is used only if the opening brace of the namespace has\nalready been wrapped, i.e. the `AfterNamespace` brace wrapping mode is\nset.</p>\n<pre><code>  namespace Foo   vs.  namespace Foo\n  {}                   {\n                       }\n</code></pre></li>\n</ul>\n",
            "options": [
                "AfterClass",
                "AfterControlStatement",
                "AfterEnum",
                "AfterFunction",
                "AfterNamespace",
                "AfterObjCDeclaration",
                "AfterStruct",
                "AfterUnion",
                "AfterExternBlock",
                "BeforeCatch",
                "BeforeElse",
                "IndentBraces",
                "SplitEmptyFunction",
                "SplitEmptyRecord",
                "SplitEmptyNamespace"
            ]
        },
        "BreakAfterJavaFieldAnnotations": {
            "type": "bool",
            "doc": "<p>  Break after each annotation on a field in Java files.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     @Partial                       vs.     @Partial @Mock DataLoad loader;\n     @Mock\n     DataLoad loader;\n</code></pre>\n"
        },
        "BreakBeforeBinaryOperators": {
            "type": "BinaryOperatorStyle",
            "doc": "<p>  The way to wrap binary operators.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BOS_None</code> (in configuration: <code>None</code>)\nBreak after operators.</p>\n<pre><code>   LooooooooooongType loooooooooooooooooooooongVariable =\n       someLooooooooooooooooongFunction();\n</code></pre><p>   bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +</p>\n<pre><code>                    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==\n                aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &amp;&amp;\n            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &gt;\n                ccccccccccccccccccccccccccccccccccccccccc;\n</code></pre></li>\n<li><p><code>BOS_NonAssignment</code> (in configuration: <code>NonAssignment</code>)\nBreak before operators that aren&#39;t assignments.</p>\n<pre><code>   LooooooooooongType loooooooooooooooooooooongVariable =\n       someLooooooooooooooooongFunction();\n</code></pre><p>   bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</p>\n<pre><code>                    + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n                == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n            &amp;&amp; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n                   &gt; ccccccccccccccccccccccccccccccccccccccccc;\n</code></pre></li>\n<li><p><code>BOS_All</code> (in configuration: <code>All</code>)\nBreak before operators.</p>\n<pre><code>   LooooooooooongType loooooooooooooooooooooongVariable\n       = someLooooooooooooooooongFunction();\n</code></pre><p>   bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</p>\n<pre><code>                    + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n                == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n            &amp;&amp; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n                   &gt; ccccccccccccccccccccccccccccccccccccccccc;\n</code></pre></li>\n</ul>\n",
            "options": [
                "None",
                "NonAssignment",
                "All"
            ]
        },
        "BreakBeforeBraces": {
            "type": "BraceBreakingStyle",
            "doc": "<p>  The brace breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BS_Attach</code> (in configuration: <code>Attach</code>)\nAlways attach braces to surrounding context.</p>\n<pre><code>  try {\n    foo();\n  } catch () {\n  }\n  void foo() { bar(); }\n  class foo {};\n  if (foo()) {\n  } else {\n  }\n  enum X : int { A, B };\n</code></pre></li>\n<li><p><code>BS_Linux</code> (in configuration: <code>Linux</code>)\nLike <code>Attach</code>, but break before braces on function, namespace and\nclass definitions.</p>\n<pre><code>  try {\n    foo();\n  } catch () {\n  }\n  void foo() { bar(); }\n  class foo\n  {\n  };\n  if (foo()) {\n  } else {\n  }\n  enum X : int { A, B };\n</code></pre></li>\n<li><p><code>BS_Mozilla</code> (in configuration: <code>Mozilla</code>)\nLike <code>Attach</code>, but break before braces on enum, function, and record\ndefinitions.</p>\n<pre><code>  try {\n    foo();\n  } catch () {\n  }\n  void foo() { bar(); }\n  class foo\n  {\n  };\n  if (foo()) {\n  } else {\n  }\n  enum X : int { A, B };\n</code></pre></li>\n<li><p><code>BS_Stroustrup</code> (in configuration: <code>Stroustrup</code>)\nLike <code>Attach</code>, but break before function definitions, <code>catch</code>, and\n<code>else</code>.</p>\n<pre><code>  try {\n    foo();\n  } catch () {\n  }\n  void foo() { bar(); }\n  class foo\n  {\n  };\n  if (foo()) {\n  } else {\n  }\n  enum X : int\n  {\n    A,\n    B\n  };\n</code></pre></li>\n<li><p><code>BS_Allman</code> (in configuration: <code>Allman</code>)\nAlways break before braces.</p>\n<pre><code>  try {\n    foo();\n  }\n  catch () {\n  }\n  void foo() { bar(); }\n  class foo {\n  };\n  if (foo()) {\n  }\n  else {\n  }\n  enum X : int { A, B };\n</code></pre></li>\n<li><p><code>BS_GNU</code> (in configuration: <code>GNU</code>)\nAlways break before braces and add an extra level of indentation to\nbraces of control statements, not to those of class, function\nor other definitions.</p>\n<pre><code>  try\n    {\n      foo();\n    }\n  catch ()\n    {\n    }\n  void foo() { bar(); }\n  class foo\n  {\n  };\n  if (foo())\n    {\n    }\n  else\n    {\n    }\n  enum X : int\n  {\n    A,\n    B\n  };\n</code></pre></li>\n<li><p><code>BS_WebKit</code> (in configuration: <code>WebKit</code>)\nLike <code>Attach</code>, but break before functions.</p>\n<pre><code>  try {\n    foo();\n  } catch () {\n  }\n  void foo() { bar(); }\n  class foo {\n  };\n  if (foo()) {\n  } else {\n  }\n  enum X : int { A, B };\n</code></pre></li>\n<li><p><code>BS_Custom</code> (in configuration: <code>Custom</code>)\nConfigure each individual brace in `BraceWrapping`.</p>\n</li>\n</ul>\n",
            "options": [
                "Attach",
                "Linux",
                "Mozilla",
                "Stroustrup",
                "Allman",
                "GNU",
                "WebKit",
                "Custom"
            ]
        },
        "BreakBeforeInheritanceComma": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, in the class inheritance expression clang-format will\n  break before <code>:</code> and <code>,</code> if there is multiple inheritance.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     class MyClass                  vs.     class MyClass : public X, public Y {\n         : public X                         };\n         , public Y {\n     };\n</code></pre>\n"
        },
        "BreakBeforeTernaryOperators": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, ternary operators will be placed after line breaks.</p>\n<pre><code class=\"lang-  \">     true:\n     veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription\n         ? firstValue\n         : SecondValueVeryVeryVeryVeryLong;\n</code></pre>\n<pre><code> false:\n veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ?\n     firstValue :\n     SecondValueVeryVeryVeryVeryLong;\n</code></pre>"
        },
        "BreakConstructorInitializers": {
            "type": "BreakConstructorInitializersStyle",
            "doc": "<p>  The constructor initializers style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BCIS_BeforeColon</code> (in configuration: <code>BeforeColon</code>)\nBreak constructor initializers before the colon and after the commas.</p>\n<pre><code>  Constructor()\n      : initializer1(),\n        initializer2()\n</code></pre></li>\n<li><p><code>BCIS_BeforeComma</code> (in configuration: <code>BeforeComma</code>)\nBreak constructor initializers before the colon and commas, and align\nthe commas with the colon.</p>\n<pre><code>  Constructor()\n      : initializer1()\n      , initializer2()\n</code></pre></li>\n<li><p><code>BCIS_AfterColon</code> (in configuration: <code>AfterColon</code>)\nBreak constructor initializers after the colon and commas.</p>\n<pre><code>  Constructor() :\n      initializer1(),\n      initializer2()\n</code></pre></li>\n</ul>\n",
            "options": [
                "BeforeColon",
                "BeforeComma",
                "AfterColon"
            ]
        },
        "BreakStringLiterals": {
            "type": "bool",
            "doc": "<p>  Allow breaking string literals when formatting.</p>\n"
        },
        "ColumnLimit": {
            "type": "unsigned",
            "doc": "<p>  The column limit.</p>\n<p>  A column limit of <code>0</code> means that there is no column limit. In this case,\n  clang-format will respect the input&#39;s line breaking decisions within\n  statements unless they contradict other rules.</p>\n"
        },
        "CommentPragmas": {
            "type": "std::string",
            "doc": "<p>  A regular expression that describes comments with special meaning,\n  which should not be split into lines or otherwise changed.</p>\n<pre><code class=\"lang-  \">     // CommentPragmas: &#39;^ FOOBAR pragma:&#39;\n     // Will leave the following line unaffected\n     #include &lt;vector&gt; // FOOBAR pragma: keep\n</code></pre>\n"
        },
        "CompactNamespaces": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, consecutive namespace declarations will be on the same\n  line. If <code>false</code>, each namespace is declared on a new line.</p>\n<pre><code class=\"lang-  \">    true:\n    namespace Foo { namespace Bar {\n    }}\n</code></pre>\n<pre><code>false:\nnamespace Foo {\nnamespace Bar {\n}\n}\n</code></pre><p>  If it does not fit on a single line, the overflowing namespaces get\n  wrapped:</p>\n<pre><code class=\"lang-  \">    namespace Foo { namespace Bar {\n    namespace Extra {\n    }}}\n</code></pre>\n"
        },
        "ConstructorInitializerAllOnOneLineOrOnePerLine": {
            "type": "bool",
            "doc": "<p>  If the constructor initializers don&#39;t fit on a line, put each\n  initializer on its own line.</p>\n<pre><code class=\"lang-  \">    true:\n    SomeClass::Constructor()\n        : aaaaaaaa(aaaaaaaa), aaaaaaaa(aaaaaaaa), aaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaa) {\n      return 0;\n    }\n</code></pre>\n<pre><code>false:\nSomeClass::Constructor()\n    : aaaaaaaa(aaaaaaaa), aaaaaaaa(aaaaaaaa),\n      aaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaa) {\n  return 0;\n}\n</code></pre>"
        },
        "ConstructorInitializerIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of constructor\n  initializer lists.</p>\n"
        },
        "ContinuationIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  Indent width for line continuations.</p>\n<pre><code class=\"lang-  \">     ContinuationIndentWidth: 2\n</code></pre>\n<pre><code> int i =         //  VeryVeryVeryVeryVeryLongComment\n   longFunction( // Again a long comment\n     arg);\n</code></pre>"
        },
        "Cpp11BracedListStyle": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, format braced lists as best suited for C++11 braced\n  lists.</p>\n<p>  Important differences:</p>\n<ul>\n<li>No spaces inside the braced list.</li>\n<li>No line break before the closing brace.</li>\n<li><p>Indentation with the continuation indent, not with the block indent.</p>\n<p>Fundamentally, C++11 braced lists are formatted exactly like function\ncalls would be formatted in their place. If the braced list follows a name\n(e.g. a type or variable name), clang-format formats as if the <code>{}</code> were\nthe parentheses of a function call with that name. If there is no name,\na zero-length name is assumed.</p>\n<pre><code> true:                                  false:\n vector&lt;int&gt; x{1, 2, 3, 4};     vs.     vector&lt;int&gt; x{ 1, 2, 3, 4 };\n vector&lt;T&gt; x{{}, {}, {}, {}};           vector&lt;T&gt; x{ {}, {}, {}, {} };\n f(MyMap[{composite, key}]);            f(MyMap[{ composite, key }]);\n new int[3]{1, 2, 3};                   new int[3]{ 1, 2, 3 };\n</code></pre></li>\n</ul>\n"
        },
        "DerivePointerAlignment": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, analyze the formatted file for the most common\n  alignment of <code>&amp;</code> and <code>*</code>.\n  Pointer and reference alignment styles are going to be updated according\n  to the preferences found in the file.\n  <code>PointerAlignment</code> is then used only as fallback.</p>\n"
        },
        "DisableFormat": {
            "type": "bool",
            "doc": "<p>  Disables formatting completely.</p>\n"
        },
        "ExperimentalAutoDetectBinPacking": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format detects whether function calls and\n  definitions are formatted with one parameter per line.</p>\n<p>  Each call can be bin-packed, one-per-line or inconclusive. If it is\n  inconclusive, e.g. completely on one line, but a decision needs to be\n  made, clang-format analyzes whether there are other bin-packed cases in\n  the input file and act accordingly.</p>\n<p>  NOTE: This is an experimental flag, that might go away or be renamed. Do\n  not use this in config files, etc. Use at your own risk.</p>\n"
        },
        "FixNamespaceComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format adds missing namespace end comments and\n  fixes invalid existing ones.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     namespace a {                  vs.     namespace a {\n     foo();                                 foo();\n     } // namespace a;                      }\n</code></pre>\n"
        },
        "ForEachMacros": {
            "type": "std::vector<std::string>",
            "doc": "<p>  A vector of macros that should be interpreted as foreach loops\n  instead of as function calls.</p>\n<p>  These are expected to be macros of the form:</p>\n<pre><code class=\"lang-  \">    FOREACH(&lt;variable-declaration&gt;, ...)\n      &lt;loop-body&gt;\n</code></pre>\n<p>  In the .clang-format configuration file, this can be configured like:</p>\n<pre><code class=\"lang-  \">    ForEachMacros: [&#39;RANGES_FOR&#39;, &#39;FOREACH&#39;]\n</code></pre>\n<p>  For example: BOOST_FOREACH.</p>\n"
        },
        "IncludeBlocks": {
            "type": "IncludeBlocksStyle",
            "doc": "<p>  Dependent on the value, multiple <code>#include</code> blocks can be sorted\n  as one and divided based on category.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>IBS_Preserve</code> (in configuration: <code>Preserve</code>)\nSort each <code>#include</code> block separately.</p>\n<pre><code>   #include &quot;b.h&quot;               into      #include &quot;b.h&quot;\n</code></pre><p>   #include &lt;lib/main.h&gt;                  #include &quot;a.h&quot;\n   #include &quot;a.h&quot;                         #include &lt;lib/main.h&gt;</p>\n</li>\n<li><p><code>IBS_Merge</code> (in configuration: <code>Merge</code>)\nMerge multiple <code>#include</code> blocks together and sort as one.</p>\n<pre><code>   #include &quot;b.h&quot;               into      #include &quot;a.h&quot;\n                                          #include &quot;b.h&quot;\n   #include &lt;lib/main.h&gt;                  #include &lt;lib/main.h&gt;\n   #include &quot;a.h&quot;\n</code></pre></li>\n<li><p><code>IBS_Regroup</code> (in configuration: <code>Regroup</code>)\nMerge multiple <code>#include</code> blocks together and sort as one.\nThen split into groups based on category priority. See <code>IncludeCategories</code>.</p>\n<pre><code>   #include &quot;b.h&quot;               into      #include &quot;a.h&quot;\n                                          #include &quot;b.h&quot;\n   #include &lt;lib/main.h&gt;\n   #include &quot;a.h&quot;                         #include &lt;lib/main.h&gt;\n</code></pre></li>\n</ul>\n",
            "options": [
                "Preserve",
                "Merge",
                "Regroup"
            ]
        },
        "IncludeCategories": {
            "type": "std::vector<IncludeCategory>",
            "doc": "<p>  Regular expressions denoting the different <code>#include</code> categories\n  used for ordering <code>#includes</code>.</p>\n<p>  These regular expressions are matched against the filename of an include\n  (including the &lt;&gt; or &quot;&quot;) in order. The value belonging to the first\n  matching regular expression is assigned and <code>#includes</code> are sorted first\n  according to increasing category number and then alphabetically within\n  each category.</p>\n<p>  If none of the regular expressions match, INT_MAX is assigned as\n  category. The main header for a source file automatically gets category 0.\n  so that it is generally kept at the beginning of the <code>#includes</code>\n  (http://llvm.org/docs/CodingStandards.html#include-style). However, you\n  can also assign negative priorities if you have certain headers that\n  always need to be first.</p>\n<p>  To configure this in the .clang-format file, use:</p>\n<pre><code class=\"lang-  \">    IncludeCategories:\n      - Regex:           &#39;^&quot;(llvm|llvm-c|clang|clang-c)/&#39;\n        Priority:        2\n      - Regex:           &#39;^(&lt;|&quot;(gtest|gmock|isl|json)/)&#39;\n        Priority:        3\n      - Regex:           &#39;.*&#39;\n        Priority:        1\n</code></pre>\n",
            "options": []
        },
        "IncludeIsMainRegex": {
            "type": "std::string",
            "doc": "<p>  Specify a regular expression of suffixes that are allowed in the\n  file-to-main-include mapping.</p>\n<p>  When guessing whether a #include is the &quot;main&quot; include (to assign\n  category 0, see above), use this regex of allowed suffixes to the header\n  stem. A partial match is done, so that:</p>\n<ul>\n<li>&quot;&quot; means &quot;arbitrary suffix&quot;</li>\n<li><p>&quot;$&quot; means &quot;no suffix&quot;</p>\n<p>For example, if configured to &quot;(_test)?$&quot;, then a header a.h would be seen\nas the &quot;main&quot; include in both a.cc and a_test.cc.</p>\n</li>\n</ul>\n"
        },
        "IndentCaseLabels": {
            "type": "bool",
            "doc": "<p>  Indent case labels one level from the switch statement.</p>\n<p>  When <code>false</code>, use the same indentation level as for the switch statement.\n  Switch statement body is always indented one level more than case labels.</p>\n<pre><code class=\"lang-  \">     false:                                 true:\n     switch (fool) {                vs.     switch (fool) {\n     case 1:                                  case 1:\n       bar();                                   bar();\n       break;                                   break;\n     default:                                 default:\n       plop();                                  plop();\n     }                                      }\n</code></pre>\n"
        },
        "IndentPPDirectives": {
            "type": "PPDirectiveIndentStyle",
            "doc": "<p>  The preprocessor directive indenting style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>PPDIS_None</code> (in configuration: <code>None</code>)\nDoes not indent any directives.</p>\n<pre><code>   #if FOO\n   #if BAR\n   #include &lt;foo&gt;\n   #endif\n   #endif\n</code></pre></li>\n<li><p><code>PPDIS_AfterHash</code> (in configuration: <code>AfterHash</code>)\nIndents directives after the hash.</p>\n<pre><code>   #if FOO\n   #  if BAR\n   #    include &lt;foo&gt;\n   #  endif\n   #endif\n</code></pre></li>\n</ul>\n",
            "options": [
                "None",
                "AfterHash"
            ]
        },
        "IndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns to use for indentation.</p>\n<pre><code class=\"lang-  \">     IndentWidth: 3\n</code></pre>\n<pre><code> void f() {\n    someFunction();\n    if (true, false) {\n       f();\n    }\n }\n</code></pre>"
        },
        "IndentWrappedFunctionNames": {
            "type": "bool",
            "doc": "<p>  Indent if a function definition or declaration is wrapped after the\n  type.</p>\n<pre><code class=\"lang-  \">     true:\n     LoooooooooooooooooooooooooooooooooooooooongReturnType\n         LoooooooooooooooooooooooooooooooongFunctionDeclaration();\n</code></pre>\n<pre><code> false:\n LoooooooooooooooooooooooooooooooooooooooongReturnType\n LoooooooooooooooooooooooooooooooongFunctionDeclaration();\n</code></pre>"
        },
        "JavaScriptQuotes": {
            "type": "JavaScriptQuoteStyle",
            "doc": "<p>  The JavaScriptQuoteStyle to use for JavaScript strings.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>JSQS_Leave</code> (in configuration: <code>Leave</code>)\nLeave string quotes as they are.</p>\n<pre><code>   string1 = &quot;foo&quot;;\n   string2 = &#39;bar&#39;;\n</code></pre></li>\n<li><p><code>JSQS_Single</code> (in configuration: <code>Single</code>)\nAlways use single quotes.</p>\n<pre><code>   string1 = &#39;foo&#39;;\n   string2 = &#39;bar&#39;;\n</code></pre></li>\n<li><p><code>JSQS_Double</code> (in configuration: <code>Double</code>)\nAlways use double quotes.</p>\n<pre><code>   string1 = &quot;foo&quot;;\n   string2 = &quot;bar&quot;;\n</code></pre></li>\n</ul>\n",
            "options": [
                "Leave",
                "Single",
                "Double"
            ]
        },
        "JavaScriptWrapImports": {
            "type": "bool",
            "doc": "<p>  Whether to wrap JavaScript import/export statements.</p>\n<pre><code class=\"lang-  \">     true:\n     import {\n         VeryLongImportsAreAnnoying,\n         VeryLongImportsAreAnnoying,\n         VeryLongImportsAreAnnoying,\n     } from &#39;some/module.js&#39;\n</code></pre>\n<pre><code> false:\n import {VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying,} from &quot;some/module.js&quot;\n</code></pre>"
        },
        "KeepEmptyLinesAtTheStartOfBlocks": {
            "type": "bool",
            "doc": "<p>  If true, the empty line at the start of blocks is kept.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     if (foo) {                     vs.     if (foo) {\n                                              bar();\n       bar();                               }\n     }\n</code></pre>\n"
        },
        "Language": {
            "type": "LanguageKind",
            "doc": "<p>  Language, this format style is targeted at.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>LK_None</code> (in configuration: <code>None</code>)\nDo not use.</p>\n</li>\n<li><p><code>LK_Cpp</code> (in configuration: <code>Cpp</code>)\nShould be used for C, C++.</p>\n</li>\n<li><p><code>LK_Java</code> (in configuration: <code>Java</code>)\nShould be used for Java.</p>\n</li>\n<li><p><code>LK_JavaScript</code> (in configuration: <code>JavaScript</code>)\nShould be used for JavaScript.</p>\n</li>\n<li><p><code>LK_ObjC</code> (in configuration: <code>ObjC</code>)\nShould be used for Objective-C, Objective-C++.</p>\n</li>\n<li><p><code>LK_Proto</code> (in configuration: <code>Proto</code>)\nShould be used for Protocol Buffers\n(https://developers.google.com/protocol-buffers/).</p>\n</li>\n<li><p><code>LK_TableGen</code> (in configuration: <code>TableGen</code>)\nShould be used for TableGen code.</p>\n</li>\n<li><p><code>LK_TextProto</code> (in configuration: <code>TextProto</code>)\nShould be used for Protocol Buffer messages in text format\n(https://developers.google.com/protocol-buffers/).</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "Cpp",
                "Java",
                "JavaScript",
                "ObjC",
                "Proto",
                "TableGen",
                "TextProto"
            ]
        },
        "MacroBlockBegin": {
            "type": "std::string",
            "doc": "<p>  A regular expression matching macros that start a block.</p>\n<pre><code class=\"lang-  \">     # With:\n     MacroBlockBegin: &quot;^NS_MAP_BEGIN|\\\n     NS_TABLE_HEAD$&quot;\n     MacroBlockEnd: &quot;^\\\n     NS_MAP_END|\\\n     NS_TABLE_.*_END$&quot;\n</code></pre>\n<pre><code> NS_MAP_BEGIN\n   foo();\n NS_MAP_END\n\n NS_TABLE_HEAD\n   bar();\n NS_TABLE_FOO_END\n\n # Without:\n NS_MAP_BEGIN\n foo();\n NS_MAP_END\n\n NS_TABLE_HEAD\n bar();\n NS_TABLE_FOO_END\n</code></pre>"
        },
        "MacroBlockEnd": {
            "type": "std::string",
            "doc": "<p>  A regular expression matching macros that end a block.</p>\n"
        },
        "MaxEmptyLinesToKeep": {
            "type": "unsigned",
            "doc": "<p>  The maximum number of consecutive empty lines to keep.</p>\n<pre><code class=\"lang-  \">     MaxEmptyLinesToKeep: 1         vs.     MaxEmptyLinesToKeep: 0\n     int f() {                              int f() {\n       int = 1;                                 int i = 1;\n                                                i = foo();\n       i = foo();                               return i;\n                                            }\n       return i;\n     }\n</code></pre>\n"
        },
        "NamespaceIndentation": {
            "type": "NamespaceIndentationKind",
            "doc": "<p>  The indentation used for namespaces.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>NI_None</code> (in configuration: <code>None</code>)\nDon&#39;t indent in namespaces.</p>\n<pre><code>   namespace out {\n   int i;\n   namespace in {\n   int i;\n   }\n   }\n</code></pre></li>\n<li><p><code>NI_Inner</code> (in configuration: <code>Inner</code>)\nIndent only in inner namespaces (nested in other namespaces).</p>\n<pre><code>   namespace out {\n   int i;\n   namespace in {\n     int i;\n   }\n   }\n</code></pre></li>\n<li><p><code>NI_All</code> (in configuration: <code>All</code>)\nIndent in all namespaces.</p>\n<pre><code>   namespace out {\n     int i;\n     namespace in {\n       int i;\n     }\n   }\n</code></pre></li>\n</ul>\n",
            "options": [
                "None",
                "Inner",
                "All"
            ]
        },
        "ObjCBlockIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of ObjC blocks.</p>\n<pre><code class=\"lang-  \">     ObjCBlockIndentWidth: 4\n</code></pre>\n<pre><code> [operation setCompletionBlock:^{\n     [self onOperationDone];\n }];\n</code></pre>"
        },
        "ObjCSpaceAfterProperty": {
            "type": "bool",
            "doc": "<p>  Add a space after <code>@property</code> in Objective-C, i.e. use\n  <code>@property (readonly)</code> instead of <code>@property(readonly)</code>.</p>\n"
        },
        "ObjCSpaceBeforeProtocolList": {
            "type": "bool",
            "doc": "<p>  Add a space in front of an Objective-C protocol list, i.e. use\n  <code>Foo &lt;Protocol&gt;</code> instead of <code>Foo&lt;Protocol&gt;</code>.</p>\n"
        },
        "PenaltyBreakAssignment": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking around an assignment operator.</p>\n"
        },
        "PenaltyBreakBeforeFirstCallParameter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking a function call after <code>call(</code>.</p>\n"
        },
        "PenaltyBreakComment": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a comment.</p>\n"
        },
        "PenaltyBreakFirstLessLess": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking before the first <code>&lt;&lt;</code>.</p>\n"
        },
        "PenaltyBreakString": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a string literal.</p>\n"
        },
        "PenaltyExcessCharacter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each character outside of the column limit.</p>\n"
        },
        "PenaltyReturnTypeOnItsOwnLine": {
            "type": "unsigned",
            "doc": "<p>  Penalty for putting the return type of a function onto its own\n  line.</p>\n"
        },
        "PointerAlignment": {
            "type": "PointerAlignmentStyle",
            "doc": "<p>  Pointer and reference alignment style.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>PAS_Left</code> (in configuration: <code>Left</code>)\nAlign pointer to the left.</p>\n<pre><code>  int* a;\n</code></pre></li>\n<li><p><code>PAS_Right</code> (in configuration: <code>Right</code>)\nAlign pointer to the right.</p>\n<pre><code>  int *a;\n</code></pre></li>\n<li><p><code>PAS_Middle</code> (in configuration: <code>Middle</code>)\nAlign pointer in the middle.</p>\n<pre><code>  int * a;\n</code></pre></li>\n</ul>\n",
            "options": [
                "Left",
                "Right",
                "Middle"
            ]
        },
        "RawStringFormats": {
            "type": "std::vector<RawStringFormat>",
            "doc": "<p>  Raw string delimiters denoting that the raw string contents are\n  code in a particular language and can be reformatted.</p>\n<p>  A raw string with a matching delimiter will be reformatted assuming the\n  specified language based on a predefined style given by &#39;BasedOnStyle&#39;.\n  If &#39;BasedOnStyle&#39; is not found, the formatting is based on llvm style.</p>\n<p>  To configure this in the .clang-format file, use:</p>\n<pre><code class=\"lang-  \">    RawStringFormats:\n      - Delimiter: &#39;pb&#39;\n        Language:  TextProto\n        BasedOnStyle: llvm\n      - Delimiter: &#39;proto&#39;\n        Language:  TextProto\n        BasedOnStyle: google\n</code></pre>\n",
            "options": []
        },
        "ReflowComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format will attempt to re-flow comments.</p>\n<pre><code class=\"lang-  \">     false:\n     // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information\n     /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */\n</code></pre>\n<pre><code> true:\n // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of\n // information\n /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of\n  * information */\n</code></pre>"
        },
        "SortIncludes": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format will sort <code>#includes</code>.</p>\n<pre><code class=\"lang-  \">     false:                                 true:\n     #include &quot;b.h&quot;                 vs.     #include &quot;a.h&quot;\n     #include &quot;a.h&quot;                         #include &quot;b.h&quot;\n</code></pre>\n"
        },
        "SortUsingDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format will sort using declarations.</p>\n<p>  The order of using declarations is defined as follows:\n  Split the strings by &quot;::&quot; and discard any initial empty strings. The last\n  element of each list is a non-namespace name; all others are namespace\n  names. Sort the lists of names lexicographically, where the sort order of\n  individual names is that all non-namespace names come before all namespace\n  names, and within those groups, names are in case-insensitive\n  lexicographic order.</p>\n<pre><code class=\"lang-  \">     false:                                 true:\n     using std::cout;               vs.     using std::cin;\n     using std::cin;                        using std::cout;\n</code></pre>\n"
        },
        "SpaceAfterCStyleCast": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, a space is inserted after C style casts.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     (int)i;                        vs.     (int) i;\n</code></pre>\n"
        },
        "SpaceAfterTemplateKeyword": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, a space will be inserted after the &#39;template&#39; keyword.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     template &lt;int&gt; void foo();     vs.     template&lt;int&gt; void foo();\n</code></pre>\n"
        },
        "SpaceBeforeAssignmentOperators": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, spaces will be removed before assignment operators.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     int a = 5;                     vs.     int a=5;\n     a += 42                                a+=42;\n</code></pre>\n"
        },
        "SpaceBeforeParens": {
            "type": "SpaceBeforeParensOptions",
            "doc": "<p>  Defines in which cases to put a space before opening parentheses.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>SBPO_Never</code> (in configuration: <code>Never</code>)\nNever put a space before opening parentheses.</p>\n<pre><code>   void f() {\n     if(true) {\n       f();\n     }\n   }\n</code></pre></li>\n<li><p><code>SBPO_ControlStatements</code> (in configuration: <code>ControlStatements</code>)\nPut a space before opening parentheses only after control statement\nkeywords (<code>for/if/while...</code>).</p>\n<pre><code>   void f() {\n     if (true) {\n       f();\n     }\n   }\n</code></pre></li>\n<li><p><code>SBPO_Always</code> (in configuration: <code>Always</code>)\nAlways put a space before opening parentheses, except when it&#39;s\nprohibited by the syntax rules (in function-like macro definitions) or\nwhen determined by other style rules (after unary operators, opening\nparentheses, etc.)</p>\n<pre><code>   void f () {\n     if (true) {\n       f ();\n     }\n   }\n</code></pre></li>\n</ul>\n",
            "options": [
                "Never",
                "ControlStatements",
                "Always"
            ]
        },
        "SpaceInEmptyParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into <code>()</code>.</p>\n<pre><code class=\"lang-  \">     true:                                false:\n     void f( ) {                    vs.   void f() {\n       int x[] = {foo( ), bar( )};          int x[] = {foo(), bar()};\n       if (true) {                          if (true) {\n         f( );                                f();\n       }                                    }\n     }                                    }\n</code></pre>\n"
        },
        "SpacesBeforeTrailingComments": {
            "type": "unsigned",
            "doc": "<p>  The number of spaces before trailing line comments\n  (<code>//</code> - comments).</p>\n<p>  This does not affect trailing block comments (<code>/*</code> - comments) as\n  those commonly have different usage patterns and a number of special\n  cases.</p>\n<pre><code class=\"lang-  \">     SpacesBeforeTrailingComments: 3\n     void f() {\n       if (true) {   // foo1\n         f();        // bar\n       }             // foo\n     }\n</code></pre>\n"
        },
        "SpacesInAngles": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>&lt;</code> and before <code>&gt;</code>\n  in template argument lists.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     static_cast&lt; int &gt;(arg);       vs.     static_cast&lt;int&gt;(arg);\n     std::function&lt; void(int) &gt; fct;        std::function&lt;void(int)&gt; fct;\n</code></pre>\n"
        },
        "SpacesInCStyleCastParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into C style casts.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     x = ( int32 )y                 vs.     x = (int32)y\n</code></pre>\n"
        },
        "SpacesInContainerLiterals": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces are inserted inside container literals (e.g.\n  ObjC and Javascript array and dict literals).</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     var arr = [ 1, 2, 3 ];         vs.     var arr = [1, 2, 3];\n     f({a : 1, b : 2, c : 3});              f({a: 1, b: 2, c: 3});\n</code></pre>\n"
        },
        "SpacesInParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>(</code> and before <code>)</code>.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     t f( Deleted &amp; ) &amp; = delete;   vs.     t f(Deleted &amp;) &amp; = delete;\n</code></pre>\n"
        },
        "SpacesInSquareBrackets": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>[</code> and before <code>]</code>.\n  Lambdas or unspecified size array declarations will not be affected.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     int a[ 5 ];                    vs.     int a[5];\n     std::unique_ptr&lt;int[]&gt; foo() {} // Won&#39;t be affected\n</code></pre>\n"
        },
        "Standard": {
            "type": "LanguageStandard",
            "doc": "<p>  Format compatible with this standard, e.g. use <code>A&lt;A&lt;int&gt; &gt;</code>\n  instead of <code>A&lt;A&lt;int&gt;&gt;</code> for <code>LS_Cpp03</code>.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>LS_Cpp03</code> (in configuration: <code>Cpp03</code>)\nUse C++03-compatible syntax.</p>\n</li>\n<li><p><code>LS_Cpp11</code> (in configuration: <code>Cpp11</code>)\nUse features of C++11, C++14 and C++1z (e.g. <code>A&lt;A&lt;int&gt;&gt;</code> instead of\n<code>A&lt;A&lt;int&gt; &gt;</code>).</p>\n</li>\n<li><p><code>LS_Auto</code> (in configuration: <code>Auto</code>)\nAutomatic detection based on the input.</p>\n</li>\n</ul>\n",
            "options": [
                "Cpp03",
                "Cpp11",
                "Auto"
            ]
        },
        "TabWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns used for tab stops.</p>\n"
        },
        "UseTab": {
            "type": "UseTabStyle",
            "doc": "<p>  The way to use tab characters in the resulting file.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>UT_Never</code> (in configuration: <code>Never</code>)\nNever use tab.</p>\n</li>\n<li><p><code>UT_ForIndentation</code> (in configuration: <code>ForIndentation</code>)\nUse tabs only for indentation.</p>\n</li>\n<li><p><code>UT_ForContinuationAndIndentation</code> (in configuration: <code>ForContinuationAndIndentation</code>)\nUse tabs only for line continuation and indentation.</p>\n</li>\n<li><p><code>UT_Always</code> (in configuration: <code>Always</code>)\nUse tabs whenever we need to fill whitespace that spans at least from\none tab stop to the next one.</p>\n</li>\n</ul>\n",
            "options": [
                "Never",
                "ForIndentation",
                "ForContinuationAndIndentation",
                "Always"
            ]
        }
    },
    "HEAD": {
        "BasedOnStyle": {
            "type": "string",
            "doc": "<p>  The style used for all options not specifically set in the configuration.</p>\n<p>  This option is supported only in the <strong>clang-format</strong> configuration\n  (both within <code>-style=&#39;{...}&#39;</code> and the <code>.clang-format</code> file).</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LLVM</code>\nA style complying with the <a href=\"http://llvm.org/docs/CodingStandards.html\">LLVM coding standards</a></li>\n<li><code>Google</code>\nA style complying with <a href=\"http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml\">Google&#39;s C++ style guide</a></li>\n<li><code>Chromium</code>\nA style complying with <a href=\"http://www.chromium.org/developers/coding-style\">Chromium&#39;s style guide</a></li>\n<li><code>Mozilla</code>\nA style complying with <a href=\"https://developer.mozilla.org/en-US/docs/Developer_Guide/Coding_Style\">Mozilla&#39;s style guide</a></li>\n<li><code>WebKit</code>\nA style complying with <a href=\"http://www.webkit.org/coding/coding-style.html\">WebKit&#39;s style guide</a></li>\n</ul>\n",
            "options": [
                "LLVM",
                "Google",
                "Chromium",
                "Mozilla",
                "WebKit"
            ]
        },
        "AccessModifierOffset": {
            "type": "int",
            "doc": "<p>  The extra indent or outdent of access modifiers, e.g. <code>public:</code>.</p>\n"
        },
        "AlignAfterOpenBracket": {
            "type": "BracketAlignmentStyle",
            "doc": "<p>  If <code>true</code>, horizontally aligns arguments after an open bracket.</p>\n<p>  This applies to round brackets (parentheses), angle brackets and square\n  brackets.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BAS_Align</code> (in configuration: <code>Align</code>)\nAlign parameters on the open bracket, e.g.:</p>\n<pre><code>  someLongFunction(argument1,\n                   argument2);\n</code></pre></li>\n<li><p><code>BAS_DontAlign</code> (in configuration: <code>DontAlign</code>)\nDon&#39;t align, instead use <code>ContinuationIndentWidth</code>, e.g.:</p>\n<pre><code>  someLongFunction(argument1,\n      argument2);\n</code></pre></li>\n<li><p><code>BAS_AlwaysBreak</code> (in configuration: <code>AlwaysBreak</code>)\nAlways break after an open bracket, if the parameters don&#39;t fit\non a single line, e.g.:</p>\n<pre><code>  someLongFunction(\n      argument1, argument2);\n</code></pre></li>\n</ul>\n",
            "options": [
                "Align",
                "DontAlign",
                "AlwaysBreak"
            ]
        },
        "AlignConsecutiveAssignments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns consecutive assignments.</p>\n<p>  This will align the assignment operators of consecutive lines. This\n  will result in formattings like</p>\n<pre><code class=\"lang-  \">    int aaaa = 12;\n    int b    = 23;\n    int ccc  = 23;\n</code></pre>\n"
        },
        "AlignConsecutiveDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns consecutive declarations.</p>\n<p>  This will align the declaration names of consecutive lines. This\n  will result in formattings like</p>\n<pre><code class=\"lang-  \">    int         aaaa = 12;\n    float       b = 23;\n    std::string ccc = 23;\n</code></pre>\n"
        },
        "AlignEscapedNewlines": {
            "type": "EscapedNewlineAlignmentStyle",
            "doc": "<p>  Options for aligning backslashes in escaped newlines.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>ENAS_DontAlign</code> (in configuration: <code>DontAlign</code>)\nDon&#39;t align escaped newlines.</p>\n<pre><code>  #define A \\\n    int aaaa; \\\n    int b; \\\n    int dddddddddd;\n</code></pre></li>\n<li><p><code>ENAS_Left</code> (in configuration: <code>Left</code>)\nAlign escaped newlines as far left as possible.</p>\n<pre><code>  true:\n  #define A   \\\n    int aaaa; \\\n    int b;    \\\n    int dddddddddd;\n</code></pre><p>  false:</p>\n</li>\n<li><p><code>ENAS_Right</code> (in configuration: <code>Right</code>)\nAlign escaped newlines in the right-most column.</p>\n<pre><code>  #define A                                                                      \\\n    int aaaa;                                                                    \\\n    int b;                                                                       \\\n    int dddddddddd;\n</code></pre></li>\n</ul>\n",
            "options": [
                "DontAlign",
                "Left",
                "Right"
            ]
        },
        "AlignOperands": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, horizontally align operands of binary and ternary\n  expressions.</p>\n<p>  Specifically, this aligns operands of a single expression that needs to be\n  split over multiple lines, e.g.:</p>\n<pre><code class=\"lang-  \">    int aaa = bbbbbbbbbbbbbbb +\n              ccccccccccccccc;\n</code></pre>\n"
        },
        "AlignTrailingComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, aligns trailing comments.</p>\n<pre><code class=\"lang-  \">    true:                                   false:\n    int a;     // My comment a      vs.     int a; // My comment a\n    int b = 2; // comment  b                int b = 2; // comment about b\n</code></pre>\n"
        },
        "AllowAllParametersOfDeclarationOnNextLine": {
            "type": "bool",
            "doc": "<p>  If the function declaration doesn&#39;t fit on a line,\n  allow putting all parameters of a function declaration onto\n  the next line even if <code>BinPackParameters</code> is <code>false</code>.</p>\n<pre><code class=\"lang-  \">    true:\n    void myFunction(\n        int a, int b, int c, int d, int e);\n</code></pre>\n<pre><code>false:\nvoid myFunction(int a,\n                int b,\n                int c,\n                int d,\n                int e);\n</code></pre>"
        },
        "AllowShortBlocksOnASingleLine": {
            "type": "bool",
            "doc": "<p>  Allows contracting simple braced statements to a single line.</p>\n<p>  E.g., this allows <code>if (a) { return; }</code> to be put on a single line.</p>\n"
        },
        "AllowShortCaseLabelsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, short case labels will be contracted to a single line.</p>\n<pre><code class=\"lang-  \">    true:                                   false:\n    switch (a) {                    vs.     switch (a) {\n    case 1: x = 1; break;                   case 1:\n    case 2: return;                           x = 1;\n    }                                         break;\n                                            case 2:\n                                              return;\n                                            }\n</code></pre>\n"
        },
        "AllowShortFunctionsOnASingleLine": {
            "type": "ShortFunctionStyle",
            "doc": "<p>  Dependent on the value, <code>int f() { return 0; }</code> can be put on a\n  single line.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>SFS_None</code> (in configuration: <code>None</code>)\nNever merge functions into a single line.</p>\n</li>\n<li><p><code>SFS_InlineOnly</code> (in configuration: <code>InlineOnly</code>)\nOnly merge functions defined inside a class. Same as &quot;inline&quot;,\nexcept it does not implies &quot;empty&quot;: i.e. top level empty functions\nare not merged either.</p>\n<pre><code>  class Foo {\n    void f() { foo(); }\n  };\n  void f() {\n    foo();\n  }\n  void f() {\n  }\n</code></pre></li>\n<li><p><code>SFS_Empty</code> (in configuration: <code>Empty</code>)\nOnly merge empty functions.</p>\n<pre><code>  void f() {}\n  void f2() {\n    bar2();\n  }\n</code></pre></li>\n<li><p><code>SFS_Inline</code> (in configuration: <code>Inline</code>)\nOnly merge functions defined inside a class. Implies &quot;empty&quot;.</p>\n<pre><code>  class Foo {\n    void f() { foo(); }\n  };\n  void f() {\n    foo();\n  }\n  void f() {}\n</code></pre></li>\n<li><p><code>SFS_All</code> (in configuration: <code>All</code>)\nMerge all functions fitting on a single line.</p>\n<pre><code>  class Foo {\n    void f() { foo(); }\n  };\n  void f() { bar(); }\n</code></pre></li>\n</ul>\n",
            "options": [
                "None",
                "InlineOnly",
                "Empty",
                "Inline",
                "All"
            ]
        },
        "AllowShortIfStatementsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>if (a) return;</code> can be put on a single line.</p>\n"
        },
        "AllowShortLoopsOnASingleLine": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, <code>while (true) continue;</code> can be put on a single\n  line.</p>\n"
        },
        "AlwaysBreakAfterDefinitionReturnType": {
            "type": "DefinitionReturnTypeBreakingStyle",
            "doc": "<p>  The function definition return type breaking style to use.  This\n  option is <strong>deprecated</strong> and is retained for backwards compatibility.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>DRTBS_None</code> (in configuration: <code>None</code>)\nBreak after return type automatically.\n<code>PenaltyReturnTypeOnItsOwnLine</code> is taken into account.</p>\n</li>\n<li><p><code>DRTBS_All</code> (in configuration: <code>All</code>)\nAlways break after the return type.</p>\n</li>\n<li><p><code>DRTBS_TopLevel</code> (in configuration: <code>TopLevel</code>)\nAlways break after the return types of top-level functions.</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "All",
                "TopLevel"
            ]
        },
        "AlwaysBreakAfterReturnType": {
            "type": "ReturnTypeBreakingStyle",
            "doc": "<p>  The function declaration return type breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>RTBS_None</code> (in configuration: <code>None</code>)\nBreak after return type automatically.\n<code>PenaltyReturnTypeOnItsOwnLine</code> is taken into account.</p>\n<pre><code>  class A {\n    int f() { return 0; };\n  };\n  int f();\n  int f() { return 1; }\n</code></pre></li>\n<li><p><code>RTBS_All</code> (in configuration: <code>All</code>)\nAlways break after the return type.</p>\n<pre><code>  class A {\n    int\n    f() {\n      return 0;\n    };\n  };\n  int\n  f();\n  int\n  f() {\n    return 1;\n  }\n</code></pre></li>\n<li><p><code>RTBS_TopLevel</code> (in configuration: <code>TopLevel</code>)\nAlways break after the return types of top-level functions.</p>\n<pre><code>  class A {\n    int f() { return 0; };\n  };\n  int\n  f();\n  int\n  f() {\n    return 1;\n  }\n</code></pre></li>\n<li><p><code>RTBS_AllDefinitions</code> (in configuration: <code>AllDefinitions</code>)\nAlways break after the return type of function definitions.</p>\n<pre><code>  class A {\n    int\n    f() {\n      return 0;\n    };\n  };\n  int f();\n  int\n  f() {\n    return 1;\n  }\n</code></pre></li>\n<li><p><code>RTBS_TopLevelDefinitions</code> (in configuration: <code>TopLevelDefinitions</code>)\nAlways break after the return type of top-level definitions.</p>\n<pre><code>  class A {\n    int f() { return 0; };\n  };\n  int f();\n  int\n  f() {\n    return 1;\n  }\n</code></pre></li>\n</ul>\n",
            "options": [
                "None",
                "All",
                "TopLevel",
                "AllDefinitions",
                "TopLevelDefinitions"
            ]
        },
        "AlwaysBreakBeforeMultilineStrings": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, always break before multiline string literals.</p>\n<p>  This flag is mean to make cases where there are multiple multiline strings\n  in a file look more consistent. Thus, it will only take effect if wrapping\n  the string at that point leads to it being indented\n  <code>ContinuationIndentWidth</code> spaces from the start of the line.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     aaaa =                         vs.     aaaa = &quot;bbbb&quot;\n         &quot;bbbb&quot;                                    &quot;cccc&quot;;\n         &quot;cccc&quot;;\n</code></pre>\n"
        },
        "AlwaysBreakTemplateDeclarations": {
            "type": "BreakTemplateDeclarationsStyle",
            "doc": "<p>  The template declaration breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BTDS_No</code> (in configuration: <code>No</code>)\nDo not force break before declaration.\n<code>PenaltyBreakTemplateDeclaration</code> is taken into account.</p>\n<pre><code>   template &lt;typename T&gt; T foo() {\n   }\n   template &lt;typename T&gt; T foo(int aaaaaaaaaaaaaaaaaaaaa,\n                               int bbbbbbbbbbbbbbbbbbbbb) {\n   }\n</code></pre></li>\n<li><p><code>BTDS_MultiLine</code> (in configuration: <code>MultiLine</code>)\nForce break after template declaration only when the following\ndeclaration spans multiple lines.</p>\n<pre><code>   template &lt;typename T&gt; T foo() {\n   }\n   template &lt;typename T&gt;\n   T foo(int aaaaaaaaaaaaaaaaaaaaa,\n         int bbbbbbbbbbbbbbbbbbbbb) {\n   }\n</code></pre></li>\n<li><p><code>BTDS_Yes</code> (in configuration: <code>Yes</code>)\nAlways break after template declaration.</p>\n<pre><code>   template &lt;typename T&gt;\n   T foo() {\n   }\n   template &lt;typename T&gt;\n   T foo(int aaaaaaaaaaaaaaaaaaaaa,\n         int bbbbbbbbbbbbbbbbbbbbb) {\n   }\n</code></pre></li>\n</ul>\n",
            "options": [
                "No",
                "MultiLine",
                "Yes"
            ]
        },
        "BinPackArguments": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function call&#39;s arguments will either be all on the\n  same line or will have one line each.</p>\n<pre><code class=\"lang-  \">    true:\n    void f() {\n      f(aaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaa,\n        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\n    }\n</code></pre>\n<pre><code>false:\nvoid f() {\n  f(aaaaaaaaaaaaaaaaaaaa,\n    aaaaaaaaaaaaaaaaaaaa,\n    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\n}\n</code></pre>"
        },
        "BinPackParameters": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, a function declaration&#39;s or function definition&#39;s\n  parameters will either all be on the same line or will have one line each.</p>\n<pre><code class=\"lang-  \">    true:\n    void f(int aaaaaaaaaaaaaaaaaaaa, int aaaaaaaaaaaaaaaaaaaa,\n           int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\n</code></pre>\n<pre><code>false:\nvoid f(int aaaaaaaaaaaaaaaaaaaa,\n       int aaaaaaaaaaaaaaaaaaaa,\n       int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\n</code></pre>"
        },
        "BraceWrapping": {
            "type": "BraceWrappingFlags",
            "doc": "<p>  Control of individual brace wrapping cases.</p>\n<p>  If <code>BreakBeforeBraces</code> is set to <code>BS_Custom</code>, use this to specify how\n  each individual brace case should be handled. Otherwise, this is ignored.</p>\n<pre><code class=\"lang-  \">    # Example of usage:\n    BreakBeforeBraces: Custom\n    BraceWrapping:\n      AfterEnum: true\n      AfterStruct: false\n      SplitEmptyFunction: false\n</code></pre>\n<p>  Nested configuration flags:</p>\n<ul>\n<li><p><code>bool AfterClass</code> Wrap class definitions.</p>\n<pre><code>  true:\n  class foo {};\n</code></pre><p>  false:\n  class foo\n  {};</p>\n</li>\n<li><p><code>bool AfterControlStatement</code> Wrap control statements (<code>if</code>/<code>for</code>/<code>while</code>/<code>switch</code>/..).</p>\n<pre><code>  true:\n  if (foo())\n  {\n  } else\n  {}\n  for (int i = 0; i &lt; 10; ++i)\n  {}\n</code></pre><p>  false:\n  if (foo()) {\n  } else {\n  }\n  for (int i = 0; i &lt; 10; ++i) {\n  }</p>\n</li>\n<li><p><code>bool AfterEnum</code> Wrap enum definitions.</p>\n<pre><code>  true:\n  enum X : int\n  {\n    B\n  };\n</code></pre><p>  false:\n  enum X : int { B };</p>\n</li>\n<li><p><code>bool AfterFunction</code> Wrap function definitions.</p>\n<pre><code>  true:\n  void foo()\n  {\n    bar();\n    bar2();\n  }\n</code></pre><p>  false:\n  void foo() {</p>\n<pre><code>bar();\nbar2();\n</code></pre><p>  }</p>\n</li>\n<li><p><code>bool AfterNamespace</code> Wrap namespace definitions.</p>\n<pre><code>  true:\n  namespace\n  {\n  int foo();\n  int bar();\n  }\n</code></pre><p>  false:\n  namespace {\n  int foo();\n  int bar();\n  }</p>\n</li>\n<li><p><code>bool AfterObjCDeclaration</code> Wrap ObjC definitions (interfaces, implementations...).\n@autoreleasepool and @synchronized blocks are wrapped\naccording to `AfterControlStatement` flag.</p>\n</li>\n<li><p><code>bool AfterStruct</code> Wrap struct definitions.</p>\n<pre><code>  true:\n  struct foo\n  {\n    int x;\n  };\n</code></pre><p>  false:\n  struct foo {</p>\n<pre><code>int x;\n</code></pre><p>  };</p>\n</li>\n<li><p><code>bool AfterUnion</code> Wrap union definitions.</p>\n<pre><code>  true:\n  union foo\n  {\n    int x;\n  }\n</code></pre><p>  false:\n  union foo {</p>\n<pre><code>int x;\n</code></pre><p>  }</p>\n</li>\n<li><p><code>bool AfterExternBlock</code> Wrap extern blocks.</p>\n<pre><code>  true:\n  extern &quot;C&quot;\n  {\n    int foo();\n  }\n</code></pre><p>  false:\n  extern &quot;C&quot; {\n  int foo();\n  }</p>\n</li>\n<li><p><code>bool BeforeCatch</code> Wrap before <code>catch</code>.</p>\n<pre><code>  true:\n  try {\n    foo();\n  }\n  catch () {\n  }\n</code></pre><p>  false:\n  try {</p>\n<pre><code>foo();\n</code></pre><p>  } catch () {\n  }</p>\n</li>\n<li><p><code>bool BeforeElse</code> Wrap before <code>else</code>.</p>\n<pre><code>  true:\n  if (foo()) {\n  }\n  else {\n  }\n</code></pre><p>  false:\n  if (foo()) {\n  } else {\n  }</p>\n</li>\n<li><p><code>bool IndentBraces</code> Indent the wrapped braces themselves.</p>\n</li>\n<li><p><code>bool SplitEmptyFunction</code> If <code>false</code>, empty function body can be put on a single line.\nThis option is used only if the opening brace of the function has\nalready been wrapped, i.e. the `AfterFunction` brace wrapping mode is\nset, and the function could/should not be put on a single line (as per\n`AllowShortFunctionsOnASingleLine` and constructor formatting options).</p>\n<pre><code>  int f()   vs.   inf f()\n  {}              {\n                  }\n</code></pre></li>\n<li><p><code>bool SplitEmptyRecord</code> If <code>false</code>, empty record (e.g. class, struct or union) body\ncan be put on a single line. This option is used only if the opening\nbrace of the record has already been wrapped, i.e. the `AfterClass`\n(for classes) brace wrapping mode is set.</p>\n<pre><code>  class Foo   vs.  class Foo\n  {}               {\n                   }\n</code></pre></li>\n<li><p><code>bool SplitEmptyNamespace</code> If <code>false</code>, empty namespace body can be put on a single line.\nThis option is used only if the opening brace of the namespace has\nalready been wrapped, i.e. the `AfterNamespace` brace wrapping mode is\nset.</p>\n<pre><code>  namespace Foo   vs.  namespace Foo\n  {}                   {\n                       }\n</code></pre></li>\n</ul>\n",
            "options": [
                "AfterClass",
                "AfterControlStatement",
                "AfterEnum",
                "AfterFunction",
                "AfterNamespace",
                "AfterObjCDeclaration",
                "AfterStruct",
                "AfterUnion",
                "AfterExternBlock",
                "BeforeCatch",
                "BeforeElse",
                "IndentBraces",
                "SplitEmptyFunction",
                "SplitEmptyRecord",
                "SplitEmptyNamespace"
            ]
        },
        "BreakAfterJavaFieldAnnotations": {
            "type": "bool",
            "doc": "<p>  Break after each annotation on a field in Java files.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     @Partial                       vs.     @Partial @Mock DataLoad loader;\n     @Mock\n     DataLoad loader;\n</code></pre>\n"
        },
        "BreakBeforeBinaryOperators": {
            "type": "BinaryOperatorStyle",
            "doc": "<p>  The way to wrap binary operators.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BOS_None</code> (in configuration: <code>None</code>)\nBreak after operators.</p>\n<pre><code>   LooooooooooongType loooooooooooooooooooooongVariable =\n       someLooooooooooooooooongFunction();\n</code></pre><p>   bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +</p>\n<pre><code>                    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==\n                aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &amp;&amp;\n            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &gt;\n                ccccccccccccccccccccccccccccccccccccccccc;\n</code></pre></li>\n<li><p><code>BOS_NonAssignment</code> (in configuration: <code>NonAssignment</code>)\nBreak before operators that aren&#39;t assignments.</p>\n<pre><code>   LooooooooooongType loooooooooooooooooooooongVariable =\n       someLooooooooooooooooongFunction();\n</code></pre><p>   bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</p>\n<pre><code>                    + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n                == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n            &amp;&amp; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n                   &gt; ccccccccccccccccccccccccccccccccccccccccc;\n</code></pre></li>\n<li><p><code>BOS_All</code> (in configuration: <code>All</code>)\nBreak before operators.</p>\n<pre><code>   LooooooooooongType loooooooooooooooooooooongVariable\n       = someLooooooooooooooooongFunction();\n</code></pre><p>   bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</p>\n<pre><code>                    + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n                == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n            &amp;&amp; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n                   &gt; ccccccccccccccccccccccccccccccccccccccccc;\n</code></pre></li>\n</ul>\n",
            "options": [
                "None",
                "NonAssignment",
                "All"
            ]
        },
        "BreakBeforeBraces": {
            "type": "BraceBreakingStyle",
            "doc": "<p>  The brace breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BS_Attach</code> (in configuration: <code>Attach</code>)\nAlways attach braces to surrounding context.</p>\n<pre><code>  try {\n    foo();\n  } catch () {\n  }\n  void foo() { bar(); }\n  class foo {};\n  if (foo()) {\n  } else {\n  }\n  enum X : int { A, B };\n</code></pre></li>\n<li><p><code>BS_Linux</code> (in configuration: <code>Linux</code>)\nLike <code>Attach</code>, but break before braces on function, namespace and\nclass definitions.</p>\n<pre><code>  try {\n    foo();\n  } catch () {\n  }\n  void foo() { bar(); }\n  class foo\n  {\n  };\n  if (foo()) {\n  } else {\n  }\n  enum X : int { A, B };\n</code></pre></li>\n<li><p><code>BS_Mozilla</code> (in configuration: <code>Mozilla</code>)\nLike <code>Attach</code>, but break before braces on enum, function, and record\ndefinitions.</p>\n<pre><code>  try {\n    foo();\n  } catch () {\n  }\n  void foo() { bar(); }\n  class foo\n  {\n  };\n  if (foo()) {\n  } else {\n  }\n  enum X : int { A, B };\n</code></pre></li>\n<li><p><code>BS_Stroustrup</code> (in configuration: <code>Stroustrup</code>)\nLike <code>Attach</code>, but break before function definitions, <code>catch</code>, and\n<code>else</code>.</p>\n<pre><code>  try {\n    foo();\n  } catch () {\n  }\n  void foo() { bar(); }\n  class foo\n  {\n  };\n  if (foo()) {\n  } else {\n  }\n  enum X : int\n  {\n    A,\n    B\n  };\n</code></pre></li>\n<li><p><code>BS_Allman</code> (in configuration: <code>Allman</code>)\nAlways break before braces.</p>\n<pre><code>  try {\n    foo();\n  }\n  catch () {\n  }\n  void foo() { bar(); }\n  class foo {\n  };\n  if (foo()) {\n  }\n  else {\n  }\n  enum X : int { A, B };\n</code></pre></li>\n<li><p><code>BS_GNU</code> (in configuration: <code>GNU</code>)\nAlways break before braces and add an extra level of indentation to\nbraces of control statements, not to those of class, function\nor other definitions.</p>\n<pre><code>  try\n    {\n      foo();\n    }\n  catch ()\n    {\n    }\n  void foo() { bar(); }\n  class foo\n  {\n  };\n  if (foo())\n    {\n    }\n  else\n    {\n    }\n  enum X : int\n  {\n    A,\n    B\n  };\n</code></pre></li>\n<li><p><code>BS_WebKit</code> (in configuration: <code>WebKit</code>)\nLike <code>Attach</code>, but break before functions.</p>\n<pre><code>  try {\n    foo();\n  } catch () {\n  }\n  void foo() { bar(); }\n  class foo {\n  };\n  if (foo()) {\n  } else {\n  }\n  enum X : int { A, B };\n</code></pre></li>\n<li><p><code>BS_Custom</code> (in configuration: <code>Custom</code>)\nConfigure each individual brace in `BraceWrapping`.</p>\n</li>\n</ul>\n",
            "options": [
                "Attach",
                "Linux",
                "Mozilla",
                "Stroustrup",
                "Allman",
                "GNU",
                "WebKit",
                "Custom"
            ]
        },
        "BreakBeforeTernaryOperators": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, ternary operators will be placed after line breaks.</p>\n<pre><code class=\"lang-  \">     true:\n     veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription\n         ? firstValue\n         : SecondValueVeryVeryVeryVeryLong;\n</code></pre>\n<pre><code> false:\n veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ?\n     firstValue :\n     SecondValueVeryVeryVeryVeryLong;\n</code></pre>"
        },
        "BreakConstructorInitializers": {
            "type": "BreakConstructorInitializersStyle",
            "doc": "<p>  The constructor initializers style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BCIS_BeforeColon</code> (in configuration: <code>BeforeColon</code>)\nBreak constructor initializers before the colon and after the commas.</p>\n<pre><code>   Constructor()\n       : initializer1(),\n         initializer2()\n</code></pre></li>\n<li><p><code>BCIS_BeforeComma</code> (in configuration: <code>BeforeComma</code>)\nBreak constructor initializers before the colon and commas, and align\nthe commas with the colon.</p>\n<pre><code>   Constructor()\n       : initializer1()\n       , initializer2()\n</code></pre></li>\n<li><p><code>BCIS_AfterColon</code> (in configuration: <code>AfterColon</code>)\nBreak constructor initializers after the colon and commas.</p>\n<pre><code>   Constructor() :\n       initializer1(),\n       initializer2()\n</code></pre></li>\n</ul>\n",
            "options": [
                "BeforeColon",
                "BeforeComma",
                "AfterColon"
            ]
        },
        "BreakInheritanceList": {
            "type": "BreakInheritanceListStyle",
            "doc": "<p>  The inheritance list style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BILS_BeforeColon</code> (in configuration: <code>BeforeColon</code>)\nBreak inheritance list before the colon and after the commas.</p>\n<pre><code>   class Foo\n       : Base1,\n         Base2\n   {};\n</code></pre></li>\n<li><p><code>BILS_BeforeComma</code> (in configuration: <code>BeforeComma</code>)\nBreak inheritance list before the colon and commas, and align\nthe commas with the colon.</p>\n<pre><code>   class Foo\n       : Base1\n       , Base2\n   {};\n</code></pre></li>\n<li><p><code>BILS_AfterColon</code> (in configuration: <code>AfterColon</code>)\nBreak inheritance list after the colon and commas.</p>\n<pre><code>   class Foo :\n       Base1,\n       Base2\n   {};\n</code></pre></li>\n</ul>\n",
            "options": [
                "BeforeColon",
                "BeforeComma",
                "AfterColon"
            ]
        },
        "BreakStringLiterals": {
            "type": "bool",
            "doc": "<p>  Allow breaking string literals when formatting.</p>\n"
        },
        "ColumnLimit": {
            "type": "unsigned",
            "doc": "<p>  The column limit.</p>\n<p>  A column limit of <code>0</code> means that there is no column limit. In this case,\n  clang-format will respect the input&#39;s line breaking decisions within\n  statements unless they contradict other rules.</p>\n"
        },
        "CommentPragmas": {
            "type": "std::string",
            "doc": "<p>  A regular expression that describes comments with special meaning,\n  which should not be split into lines or otherwise changed.</p>\n<pre><code class=\"lang-  \">     // CommentPragmas: &#39;^ FOOBAR pragma:&#39;\n     // Will leave the following line unaffected\n     #include &lt;vector&gt; // FOOBAR pragma: keep\n</code></pre>\n"
        },
        "CompactNamespaces": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, consecutive namespace declarations will be on the same\n  line. If <code>false</code>, each namespace is declared on a new line.</p>\n<pre><code class=\"lang-  \">    true:\n    namespace Foo { namespace Bar {\n    }}\n</code></pre>\n<pre><code>false:\nnamespace Foo {\nnamespace Bar {\n}\n}\n</code></pre><p>  If it does not fit on a single line, the overflowing namespaces get\n  wrapped:</p>\n<pre><code class=\"lang-  \">    namespace Foo { namespace Bar {\n    namespace Extra {\n    }}}\n</code></pre>\n"
        },
        "ConstructorInitializerAllOnOneLineOrOnePerLine": {
            "type": "bool",
            "doc": "<p>  If the constructor initializers don&#39;t fit on a line, put each\n  initializer on its own line.</p>\n<pre><code class=\"lang-  \">    true:\n    FitsOnOneLine::Constructor()\n        : aaaaaaaaaaaaa(aaaaaaaaaaaaaa), aaaaaaaaaaaaa(aaaaaaaaaaaaaa) {}\n</code></pre>\n<pre><code>DoesntFit::Constructor()\n    : aaaaaaaaaaaaa(aaaaaaaaaaaaaa),\n      aaaaaaaaaaaaa(aaaaaaaaaaaaaa),\n      aaaaaaaaaaaaa(aaaaaaaaaaaaaa) {}\n\nfalse:\nFitsOnOneLine::Constructor()\n    : aaaaaaaaaaaaa(aaaaaaaaaaaaaa), aaaaaaaaaaaaa(aaaaaaaaaaaaaa) {}\n\nDoesntFit::Constructor()\n    : aaaaaaaaaaaaa(aaaaaaaaaaaaaa), aaaaaaaaaaaaa(aaaaaaaaaaaaaa),\n      aaaaaaaaaaaaa(aaaaaaaaaaaaaa) {}\n</code></pre>"
        },
        "ConstructorInitializerIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of constructor\n  initializer lists as well as inheritance lists.</p>\n"
        },
        "ContinuationIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  Indent width for line continuations.</p>\n<pre><code class=\"lang-  \">     ContinuationIndentWidth: 2\n</code></pre>\n<pre><code> int i =         //  VeryVeryVeryVeryVeryLongComment\n   longFunction( // Again a long comment\n     arg);\n</code></pre>"
        },
        "Cpp11BracedListStyle": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, format braced lists as best suited for C++11 braced\n  lists.</p>\n<p>  Important differences:</p>\n<ul>\n<li>No spaces inside the braced list.</li>\n<li>No line break before the closing brace.</li>\n<li><p>Indentation with the continuation indent, not with the block indent.</p>\n<p>Fundamentally, C++11 braced lists are formatted exactly like function\ncalls would be formatted in their place. If the braced list follows a name\n(e.g. a type or variable name), clang-format formats as if the <code>{}</code> were\nthe parentheses of a function call with that name. If there is no name,\na zero-length name is assumed.</p>\n<pre><code> true:                                  false:\n vector&lt;int&gt; x{1, 2, 3, 4};     vs.     vector&lt;int&gt; x{ 1, 2, 3, 4 };\n vector&lt;T&gt; x{{}, {}, {}, {}};           vector&lt;T&gt; x{ {}, {}, {}, {} };\n f(MyMap[{composite, key}]);            f(MyMap[{ composite, key }]);\n new int[3]{1, 2, 3};                   new int[3]{ 1, 2, 3 };\n</code></pre></li>\n</ul>\n"
        },
        "DerivePointerAlignment": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, analyze the formatted file for the most common\n  alignment of <code>&amp;</code> and <code>*</code>.\n  Pointer and reference alignment styles are going to be updated according\n  to the preferences found in the file.\n  <code>PointerAlignment</code> is then used only as fallback.</p>\n"
        },
        "DisableFormat": {
            "type": "bool",
            "doc": "<p>  Disables formatting completely.</p>\n"
        },
        "ExperimentalAutoDetectBinPacking": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format detects whether function calls and\n  definitions are formatted with one parameter per line.</p>\n<p>  Each call can be bin-packed, one-per-line or inconclusive. If it is\n  inconclusive, e.g. completely on one line, but a decision needs to be\n  made, clang-format analyzes whether there are other bin-packed cases in\n  the input file and act accordingly.</p>\n<p>  NOTE: This is an experimental flag, that might go away or be renamed. Do\n  not use this in config files, etc. Use at your own risk.</p>\n"
        },
        "FixNamespaceComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format adds missing namespace end comments and\n  fixes invalid existing ones.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     namespace a {                  vs.     namespace a {\n     foo();                                 foo();\n     } // namespace a;                      }\n</code></pre>\n"
        },
        "ForEachMacros": {
            "type": "std::vector<std::string>",
            "doc": "<p>  A vector of macros that should be interpreted as foreach loops\n  instead of as function calls.</p>\n<p>  These are expected to be macros of the form:</p>\n<pre><code class=\"lang-  \">    FOREACH(&lt;variable-declaration&gt;, ...)\n      &lt;loop-body&gt;\n</code></pre>\n<p>  In the .clang-format configuration file, this can be configured like:</p>\n<pre><code class=\"lang-  \">    ForEachMacros: [&#39;RANGES_FOR&#39;, &#39;FOREACH&#39;]\n</code></pre>\n<p>  For example: BOOST_FOREACH.</p>\n"
        },
        "IncludeBlocks": {
            "type": "IncludeBlocksStyle",
            "doc": "<p>  Dependent on the value, multiple <code>#include</code> blocks can be sorted\n  as one and divided based on category.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>IBS_Preserve</code> (in configuration: <code>Preserve</code>)\nSort each <code>#include</code> block separately.</p>\n<pre><code>   #include &quot;b.h&quot;               into      #include &quot;b.h&quot;\n</code></pre><p>   #include &lt;lib/main.h&gt;                  #include &quot;a.h&quot;\n   #include &quot;a.h&quot;                         #include &lt;lib/main.h&gt;</p>\n</li>\n<li><p><code>IBS_Merge</code> (in configuration: <code>Merge</code>)\nMerge multiple <code>#include</code> blocks together and sort as one.</p>\n<pre><code>   #include &quot;b.h&quot;               into      #include &quot;a.h&quot;\n                                          #include &quot;b.h&quot;\n   #include &lt;lib/main.h&gt;                  #include &lt;lib/main.h&gt;\n   #include &quot;a.h&quot;\n</code></pre></li>\n<li><p><code>IBS_Regroup</code> (in configuration: <code>Regroup</code>)\nMerge multiple <code>#include</code> blocks together and sort as one.\nThen split into groups based on category priority. See\n<code>IncludeCategories</code>.</p>\n<pre><code>   #include &quot;b.h&quot;               into      #include &quot;a.h&quot;\n                                          #include &quot;b.h&quot;\n   #include &lt;lib/main.h&gt;\n   #include &quot;a.h&quot;                         #include &lt;lib/main.h&gt;\n</code></pre></li>\n</ul>\n",
            "options": [
                "Preserve",
                "Merge",
                "Regroup"
            ]
        },
        "IncludeCategories": {
            "type": "std::vector<IncludeCategory>",
            "doc": "<p>  Regular expressions denoting the different <code>#include</code> categories\n  used for ordering <code>#includes</code>.</p>\n<p>  <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html\">POSIX extended\n </a>\n  regular expressions are supported.</p>\n<p>  These regular expressions are matched against the filename of an include\n  (including the &lt;&gt; or &quot;&quot;) in order. The value belonging to the first\n  matching regular expression is assigned and <code>#includes</code> are sorted first\n  according to increasing category number and then alphabetically within\n  each category.</p>\n<p>  If none of the regular expressions match, INT_MAX is assigned as\n  category. The main header for a source file automatically gets category 0.\n  so that it is generally kept at the beginning of the <code>#includes</code>\n  (http://llvm.org/docs/CodingStandards.html#include-style). However, you\n  can also assign negative priorities if you have certain headers that\n  always need to be first.</p>\n<p>  To configure this in the .clang-format file, use:</p>\n<pre><code class=\"lang-  \">    IncludeCategories:\n      - Regex:           &#39;^&quot;(llvm|llvm-c|clang|clang-c)/&#39;\n        Priority:        2\n      - Regex:           &#39;^(&lt;|&quot;(gtest|gmock|isl|json)/)&#39;\n        Priority:        3\n      - Regex:           &#39;&lt;[[:alnum:].]+&gt;&#39;\n        Priority:        4\n      - Regex:           &#39;.*&#39;\n        Priority:        1\n</code></pre>\n",
            "options": []
        },
        "IncludeIsMainRegex": {
            "type": "std::string",
            "doc": "<p>  Specify a regular expression of suffixes that are allowed in the\n  file-to-main-include mapping.</p>\n<p>  When guessing whether a #include is the &quot;main&quot; include (to assign\n  category 0, see above), use this regex of allowed suffixes to the header\n  stem. A partial match is done, so that:</p>\n<ul>\n<li>&quot;&quot; means &quot;arbitrary suffix&quot;</li>\n<li><p>&quot;$&quot; means &quot;no suffix&quot;</p>\n<p>For example, if configured to &quot;(_test)?$&quot;, then a header a.h would be seen\nas the &quot;main&quot; include in both a.cc and a_test.cc.</p>\n</li>\n</ul>\n"
        },
        "IndentCaseLabels": {
            "type": "bool",
            "doc": "<p>  Indent case labels one level from the switch statement.</p>\n<p>  When <code>false</code>, use the same indentation level as for the switch statement.\n  Switch statement body is always indented one level more than case labels.</p>\n<pre><code class=\"lang-  \">     false:                                 true:\n     switch (fool) {                vs.     switch (fool) {\n     case 1:                                  case 1:\n       bar();                                   bar();\n       break;                                   break;\n     default:                                 default:\n       plop();                                  plop();\n     }                                      }\n</code></pre>\n"
        },
        "IndentPPDirectives": {
            "type": "PPDirectiveIndentStyle",
            "doc": "<p>  The preprocessor directive indenting style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>PPDIS_None</code> (in configuration: <code>None</code>)\nDoes not indent any directives.</p>\n<pre><code>   #if FOO\n   #if BAR\n   #include &lt;foo&gt;\n   #endif\n   #endif\n</code></pre></li>\n<li><p><code>PPDIS_AfterHash</code> (in configuration: <code>AfterHash</code>)\nIndents directives after the hash.</p>\n<pre><code>   #if FOO\n   #  if BAR\n   #    include &lt;foo&gt;\n   #  endif\n   #endif\n</code></pre></li>\n</ul>\n",
            "options": [
                "None",
                "AfterHash"
            ]
        },
        "IndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns to use for indentation.</p>\n<pre><code class=\"lang-  \">     IndentWidth: 3\n</code></pre>\n<pre><code> void f() {\n    someFunction();\n    if (true, false) {\n       f();\n    }\n }\n</code></pre>"
        },
        "IndentWrappedFunctionNames": {
            "type": "bool",
            "doc": "<p>  Indent if a function definition or declaration is wrapped after the\n  type.</p>\n<pre><code class=\"lang-  \">     true:\n     LoooooooooooooooooooooooooooooooooooooooongReturnType\n         LoooooooooooooooooooooooooooooooongFunctionDeclaration();\n</code></pre>\n<pre><code> false:\n LoooooooooooooooooooooooooooooooooooooooongReturnType\n LoooooooooooooooooooooooooooooooongFunctionDeclaration();\n</code></pre>"
        },
        "JavaScriptQuotes": {
            "type": "JavaScriptQuoteStyle",
            "doc": "<p>  The JavaScriptQuoteStyle to use for JavaScript strings.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>JSQS_Leave</code> (in configuration: <code>Leave</code>)\nLeave string quotes as they are.</p>\n<pre><code>   string1 = &quot;foo&quot;;\n   string2 = &#39;bar&#39;;\n</code></pre></li>\n<li><p><code>JSQS_Single</code> (in configuration: <code>Single</code>)\nAlways use single quotes.</p>\n<pre><code>   string1 = &#39;foo&#39;;\n   string2 = &#39;bar&#39;;\n</code></pre></li>\n<li><p><code>JSQS_Double</code> (in configuration: <code>Double</code>)\nAlways use double quotes.</p>\n<pre><code>   string1 = &quot;foo&quot;;\n   string2 = &quot;bar&quot;;\n</code></pre></li>\n</ul>\n",
            "options": [
                "Leave",
                "Single",
                "Double"
            ]
        },
        "JavaScriptWrapImports": {
            "type": "bool",
            "doc": "<p>  Whether to wrap JavaScript import/export statements.</p>\n<pre><code class=\"lang-  \">     true:\n     import {\n         VeryLongImportsAreAnnoying,\n         VeryLongImportsAreAnnoying,\n         VeryLongImportsAreAnnoying,\n     } from &#39;some/module.js&#39;\n</code></pre>\n<pre><code> false:\n import {VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying,} from &quot;some/module.js&quot;\n</code></pre>"
        },
        "KeepEmptyLinesAtTheStartOfBlocks": {
            "type": "bool",
            "doc": "<p>  If true, the empty line at the start of blocks is kept.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     if (foo) {                     vs.     if (foo) {\n                                              bar();\n       bar();                               }\n     }\n</code></pre>\n"
        },
        "Language": {
            "type": "LanguageKind",
            "doc": "<p>  Language, this format style is targeted at.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>LK_None</code> (in configuration: <code>None</code>)\nDo not use.</p>\n</li>\n<li><p><code>LK_Cpp</code> (in configuration: <code>Cpp</code>)\nShould be used for C, C++.</p>\n</li>\n<li><p><code>LK_Java</code> (in configuration: <code>Java</code>)\nShould be used for Java.</p>\n</li>\n<li><p><code>LK_JavaScript</code> (in configuration: <code>JavaScript</code>)\nShould be used for JavaScript.</p>\n</li>\n<li><p><code>LK_ObjC</code> (in configuration: <code>ObjC</code>)\nShould be used for Objective-C, Objective-C++.</p>\n</li>\n<li><p><code>LK_Proto</code> (in configuration: <code>Proto</code>)\nShould be used for Protocol Buffers\n(https://developers.google.com/protocol-buffers/).</p>\n</li>\n<li><p><code>LK_TableGen</code> (in configuration: <code>TableGen</code>)\nShould be used for TableGen code.</p>\n</li>\n<li><p><code>LK_TextProto</code> (in configuration: <code>TextProto</code>)\nShould be used for Protocol Buffer messages in text format\n(https://developers.google.com/protocol-buffers/).</p>\n</li>\n</ul>\n",
            "options": [
                "None",
                "Cpp",
                "Java",
                "JavaScript",
                "ObjC",
                "Proto",
                "TableGen",
                "TextProto"
            ]
        },
        "MacroBlockBegin": {
            "type": "std::string",
            "doc": "<p>  A regular expression matching macros that start a block.</p>\n<pre><code class=\"lang-  \">     # With:\n     MacroBlockBegin: &quot;^NS_MAP_BEGIN|\\\n     NS_TABLE_HEAD$&quot;\n     MacroBlockEnd: &quot;^\\\n     NS_MAP_END|\\\n     NS_TABLE_.*_END$&quot;\n</code></pre>\n<pre><code> NS_MAP_BEGIN\n   foo();\n NS_MAP_END\n\n NS_TABLE_HEAD\n   bar();\n NS_TABLE_FOO_END\n\n # Without:\n NS_MAP_BEGIN\n foo();\n NS_MAP_END\n\n NS_TABLE_HEAD\n bar();\n NS_TABLE_FOO_END\n</code></pre>"
        },
        "MacroBlockEnd": {
            "type": "std::string",
            "doc": "<p>  A regular expression matching macros that end a block.</p>\n"
        },
        "MaxEmptyLinesToKeep": {
            "type": "unsigned",
            "doc": "<p>  The maximum number of consecutive empty lines to keep.</p>\n<pre><code class=\"lang-  \">     MaxEmptyLinesToKeep: 1         vs.     MaxEmptyLinesToKeep: 0\n     int f() {                              int f() {\n       int = 1;                                 int i = 1;\n                                                i = foo();\n       i = foo();                               return i;\n                                            }\n       return i;\n     }\n</code></pre>\n"
        },
        "NamespaceIndentation": {
            "type": "NamespaceIndentationKind",
            "doc": "<p>  The indentation used for namespaces.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>NI_None</code> (in configuration: <code>None</code>)\nDon&#39;t indent in namespaces.</p>\n<pre><code>   namespace out {\n   int i;\n   namespace in {\n   int i;\n   }\n   }\n</code></pre></li>\n<li><p><code>NI_Inner</code> (in configuration: <code>Inner</code>)\nIndent only in inner namespaces (nested in other namespaces).</p>\n<pre><code>   namespace out {\n   int i;\n   namespace in {\n     int i;\n   }\n   }\n</code></pre></li>\n<li><p><code>NI_All</code> (in configuration: <code>All</code>)\nIndent in all namespaces.</p>\n<pre><code>   namespace out {\n     int i;\n     namespace in {\n       int i;\n     }\n   }\n</code></pre></li>\n</ul>\n",
            "options": [
                "None",
                "Inner",
                "All"
            ]
        },
        "ObjCBinPackProtocolList": {
            "type": "BinPackStyle",
            "doc": "<p>  Controls bin-packing Objective-C protocol conformance list\n  items into as few lines as possible when they go over <code>ColumnLimit</code>.</p>\n<p>  If <code>Auto</code> (the default), delegates to the value in\n  <code>BinPackParameters</code>. If that is <code>true</code>, bin-packs Objective-C\n  protocol conformance list items into as few lines as possible\n  whenever they go over <code>ColumnLimit</code>.</p>\n<p>  If <code>Always</code>, always bin-packs Objective-C protocol conformance\n  list items into as few lines as possible whenever they go over\n  <code>ColumnLimit</code>.</p>\n<p>  If <code>Never</code>, lays out Objective-C protocol conformance list items\n  onto individual lines whenever they go over <code>ColumnLimit</code>.</p>\n<pre><code class=\"lang-  \">     Always (or Auto, if BinPackParameters=true):\n     @interface ccccccccccccc () &lt;\n         ccccccccccccc, ccccccccccccc,\n         ccccccccccccc, ccccccccccccc&gt; {\n     }\n</code></pre>\n<pre><code> Never (or Auto, if BinPackParameters=false):\n @interface ddddddddddddd () &lt;\n     ddddddddddddd,\n     ddddddddddddd,\n     ddddddddddddd,\n     ddddddddddddd&gt; {\n }\n</code></pre><p>  Possible values:</p>\n<ul>\n<li><p><code>BPS_Auto</code> (in configuration: <code>Auto</code>)\nAutomatically determine parameter bin-packing behavior.</p>\n</li>\n<li><p><code>BPS_Always</code> (in configuration: <code>Always</code>)\nAlways bin-pack parameters.</p>\n</li>\n<li><p><code>BPS_Never</code> (in configuration: <code>Never</code>)\nNever bin-pack parameters.</p>\n</li>\n</ul>\n",
            "options": [
                "Auto",
                "Always",
                "Never"
            ]
        },
        "ObjCBlockIndentWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of characters to use for indentation of ObjC blocks.</p>\n<pre><code class=\"lang-  \">     ObjCBlockIndentWidth: 4\n</code></pre>\n<pre><code> [operation setCompletionBlock:^{\n     [self onOperationDone];\n }];\n</code></pre>"
        },
        "ObjCSpaceAfterProperty": {
            "type": "bool",
            "doc": "<p>  Add a space after <code>@property</code> in Objective-C, i.e. use\n  <code>@property (readonly)</code> instead of <code>@property(readonly)</code>.</p>\n"
        },
        "ObjCSpaceBeforeProtocolList": {
            "type": "bool",
            "doc": "<p>  Add a space in front of an Objective-C protocol list, i.e. use\n  <code>Foo &lt;Protocol&gt;</code> instead of <code>Foo&lt;Protocol&gt;</code>.</p>\n"
        },
        "PenaltyBreakAssignment": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking around an assignment operator.</p>\n"
        },
        "PenaltyBreakBeforeFirstCallParameter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking a function call after <code>call(</code>.</p>\n"
        },
        "PenaltyBreakComment": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a comment.</p>\n"
        },
        "PenaltyBreakFirstLessLess": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking before the first <code>&lt;&lt;</code>.</p>\n"
        },
        "PenaltyBreakString": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each line break introduced inside a string literal.</p>\n"
        },
        "PenaltyBreakTemplateDeclaration": {
            "type": "unsigned",
            "doc": "<p>  The penalty for breaking after template declaration.</p>\n"
        },
        "PenaltyExcessCharacter": {
            "type": "unsigned",
            "doc": "<p>  The penalty for each character outside of the column limit.</p>\n"
        },
        "PenaltyReturnTypeOnItsOwnLine": {
            "type": "unsigned",
            "doc": "<p>  Penalty for putting the return type of a function onto its own\n  line.</p>\n"
        },
        "PointerAlignment": {
            "type": "PointerAlignmentStyle",
            "doc": "<p>  Pointer and reference alignment style.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>PAS_Left</code> (in configuration: <code>Left</code>)\nAlign pointer to the left.</p>\n<pre><code>  int* a;\n</code></pre></li>\n<li><p><code>PAS_Right</code> (in configuration: <code>Right</code>)\nAlign pointer to the right.</p>\n<pre><code>  int *a;\n</code></pre></li>\n<li><p><code>PAS_Middle</code> (in configuration: <code>Middle</code>)\nAlign pointer in the middle.</p>\n<pre><code>  int * a;\n</code></pre></li>\n</ul>\n",
            "options": [
                "Left",
                "Right",
                "Middle"
            ]
        },
        "RawStringFormats": {
            "type": "std::vector<RawStringFormat>",
            "doc": "<p>  Defines hints for detecting supported languages code blocks in raw\n  strings.</p>\n<p>  A raw string with a matching delimiter or a matching enclosing function\n  name will be reformatted assuming the specified language based on the\n  style for that language defined in the .clang-format file. If no style has\n  been defined in the .clang-format file for the specific language, a\n  predefined style given by &#39;BasedOnStyle&#39; is used. If &#39;BasedOnStyle&#39; is not\n  found, the formatting is based on llvm style. A matching delimiter takes\n  precedence over a matching enclosing function name for determining the\n  language of the raw string contents.</p>\n<p>  If a canonical delimiter is specified, occurrences of other delimiters for\n  the same language will be updated to the canonical if possible.</p>\n<p>  There should be at most one specification per language and each delimiter\n  and enclosing function should not occur in multiple specifications.</p>\n<p>  To configure this in the .clang-format file, use:</p>\n<pre><code class=\"lang-  \">    RawStringFormats:\n      - Language: TextProto\n          Delimiters:\n            - &#39;pb&#39;\n            - &#39;proto&#39;\n          EnclosingFunctions:\n            - &#39;PARSE_TEXT_PROTO&#39;\n          BasedOnStyle: google\n      - Language: Cpp\n          Delimiters:\n            - &#39;cc&#39;\n            - &#39;cpp&#39;\n          BasedOnStyle: llvm\n          CanonicalDelimiter: &#39;cc&#39;\n</code></pre>\n",
            "options": []
        },
        "ReflowComments": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format will attempt to re-flow comments.</p>\n<pre><code class=\"lang-  \">     false:\n     // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information\n     /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */\n</code></pre>\n<pre><code> true:\n // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of\n // information\n /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of\n  * information */\n</code></pre>"
        },
        "SortIncludes": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format will sort <code>#includes</code>.</p>\n<pre><code class=\"lang-  \">     false:                                 true:\n     #include &quot;b.h&quot;                 vs.     #include &quot;a.h&quot;\n     #include &quot;a.h&quot;                         #include &quot;b.h&quot;\n</code></pre>\n"
        },
        "SortUsingDeclarations": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, clang-format will sort using declarations.</p>\n<p>  The order of using declarations is defined as follows:\n  Split the strings by &quot;::&quot; and discard any initial empty strings. The last\n  element of each list is a non-namespace name; all others are namespace\n  names. Sort the lists of names lexicographically, where the sort order of\n  individual names is that all non-namespace names come before all namespace\n  names, and within those groups, names are in case-insensitive\n  lexicographic order.</p>\n<pre><code class=\"lang-  \">     false:                                 true:\n     using std::cout;               vs.     using std::cin;\n     using std::cin;                        using std::cout;\n</code></pre>\n"
        },
        "SpaceAfterCStyleCast": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, a space is inserted after C style casts.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     (int) i;                       vs.     (int)i;\n</code></pre>\n"
        },
        "SpaceAfterTemplateKeyword": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, a space will be inserted after the &#39;template&#39; keyword.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     template &lt;int&gt; void foo();     vs.     template&lt;int&gt; void foo();\n</code></pre>\n"
        },
        "SpaceBeforeAssignmentOperators": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, spaces will be removed before assignment operators.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     int a = 5;                     vs.     int a=5;\n     a += 42                                a+=42;\n</code></pre>\n"
        },
        "SpaceBeforeCpp11BracedList": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, a space will be inserted before a C++11 braced list\n  used to initialize an object (after the preceding identifier or type).</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     Foo foo { bar };               vs.     Foo foo{ bar };\n     Foo {};                                Foo{};\n     vector&lt;int&gt; { 1, 2, 3 };               vector&lt;int&gt;{ 1, 2, 3 };\n     new int[3] { 1, 2, 3 };                new int[3]{ 1, 2, 3 };\n</code></pre>\n"
        },
        "SpaceBeforeCtorInitializerColon": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, spaces will be removed before constructor initializer\n  colon.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     Foo::Foo() : a(a) {}                   Foo::Foo(): a(a) {}\n</code></pre>\n"
        },
        "SpaceBeforeInheritanceColon": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, spaces will be removed before inheritance colon.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     class Foo : Bar {}             vs.     class Foo: Bar {}\n</code></pre>\n"
        },
        "SpaceBeforeParens": {
            "type": "SpaceBeforeParensOptions",
            "doc": "<p>  Defines in which cases to put a space before opening parentheses.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>SBPO_Never</code> (in configuration: <code>Never</code>)\nNever put a space before opening parentheses.</p>\n<pre><code>   void f() {\n     if(true) {\n       f();\n     }\n   }\n</code></pre></li>\n<li><p><code>SBPO_ControlStatements</code> (in configuration: <code>ControlStatements</code>)\nPut a space before opening parentheses only after control statement\nkeywords (<code>for/if/while...</code>).</p>\n<pre><code>   void f() {\n     if (true) {\n       f();\n     }\n   }\n</code></pre></li>\n<li><p><code>SBPO_Always</code> (in configuration: <code>Always</code>)\nAlways put a space before opening parentheses, except when it&#39;s\nprohibited by the syntax rules (in function-like macro definitions) or\nwhen determined by other style rules (after unary operators, opening\nparentheses, etc.)</p>\n<pre><code>   void f () {\n     if (true) {\n       f ();\n     }\n   }\n</code></pre></li>\n</ul>\n",
            "options": [
                "Never",
                "ControlStatements",
                "Always"
            ]
        },
        "SpaceBeforeRangeBasedForLoopColon": {
            "type": "bool",
            "doc": "<p>  If <code>false</code>, spaces will be removed before range-based for loop\n  colon.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     for (auto v : values) {}       vs.     for(auto v: values) {}\n</code></pre>\n"
        },
        "SpaceInEmptyParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into <code>()</code>.</p>\n<pre><code class=\"lang-  \">     true:                                false:\n     void f( ) {                    vs.   void f() {\n       int x[] = {foo( ), bar( )};          int x[] = {foo(), bar()};\n       if (true) {                          if (true) {\n         f( );                                f();\n       }                                    }\n     }                                    }\n</code></pre>\n"
        },
        "SpacesBeforeTrailingComments": {
            "type": "unsigned",
            "doc": "<p>  The number of spaces before trailing line comments\n  (<code>//</code> - comments).</p>\n<p>  This does not affect trailing block comments (<code>/*</code> - comments) as\n  those commonly have different usage patterns and a number of special\n  cases.</p>\n<pre><code class=\"lang-  \">     SpacesBeforeTrailingComments: 3\n     void f() {\n       if (true) {   // foo1\n         f();        // bar\n       }             // foo\n     }\n</code></pre>\n"
        },
        "SpacesInAngles": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>&lt;</code> and before <code>&gt;</code>\n  in template argument lists.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     static_cast&lt; int &gt;(arg);       vs.     static_cast&lt;int&gt;(arg);\n     std::function&lt; void(int) &gt; fct;        std::function&lt;void(int)&gt; fct;\n</code></pre>\n"
        },
        "SpacesInCStyleCastParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces may be inserted into C style casts.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     x = ( int32 )y                 vs.     x = (int32)y\n</code></pre>\n"
        },
        "SpacesInContainerLiterals": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces are inserted inside container literals (e.g.\n  ObjC and Javascript array and dict literals).</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     var arr = [ 1, 2, 3 ];         vs.     var arr = [1, 2, 3];\n     f({a : 1, b : 2, c : 3});              f({a: 1, b: 2, c: 3});\n</code></pre>\n"
        },
        "SpacesInParentheses": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>(</code> and before <code>)</code>.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     t f( Deleted &amp; ) &amp; = delete;   vs.     t f(Deleted &amp;) &amp; = delete;\n</code></pre>\n"
        },
        "SpacesInSquareBrackets": {
            "type": "bool",
            "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>[</code> and before <code>]</code>.\n  Lambdas or unspecified size array declarations will not be affected.</p>\n<pre><code class=\"lang-  \">     true:                                  false:\n     int a[ 5 ];                    vs.     int a[5];\n     std::unique_ptr&lt;int[]&gt; foo() {} // Won&#39;t be affected\n</code></pre>\n"
        },
        "Standard": {
            "type": "LanguageStandard",
            "doc": "<p>  Format compatible with this standard, e.g. use <code>A&lt;A&lt;int&gt; &gt;</code>\n  instead of <code>A&lt;A&lt;int&gt;&gt;</code> for <code>LS_Cpp03</code>.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>LS_Cpp03</code> (in configuration: <code>Cpp03</code>)\nUse C++03-compatible syntax.</p>\n</li>\n<li><p><code>LS_Cpp11</code> (in configuration: <code>Cpp11</code>)\nUse features of C++11, C++14 and C++1z (e.g. <code>A&lt;A&lt;int&gt;&gt;</code> instead of\n<code>A&lt;A&lt;int&gt; &gt;</code>).</p>\n</li>\n<li><p><code>LS_Auto</code> (in configuration: <code>Auto</code>)\nAutomatic detection based on the input.</p>\n</li>\n</ul>\n",
            "options": [
                "Cpp03",
                "Cpp11",
                "Auto"
            ]
        },
        "StatementMacros": {
            "type": "std::vector<std::string>",
            "doc": "<p>  A vector of macros that should be interpreted as complete statements.</p>\n<p>  Typical macros are expressions, and require a semi-colon to be\n  added; sometimes this is not the case, and this allows to make\n  clang-format aware of such cases.</p>\n<p>  For example: Q_UNUSED</p>\n"
        },
        "TabWidth": {
            "type": "unsigned",
            "doc": "<p>  The number of columns used for tab stops.</p>\n"
        },
        "UseTab": {
            "type": "UseTabStyle",
            "doc": "<p>  The way to use tab characters in the resulting file.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>UT_Never</code> (in configuration: <code>Never</code>)\nNever use tab.</p>\n</li>\n<li><p><code>UT_ForIndentation</code> (in configuration: <code>ForIndentation</code>)\nUse tabs only for indentation.</p>\n</li>\n<li><p><code>UT_ForContinuationAndIndentation</code> (in configuration: <code>ForContinuationAndIndentation</code>)\nUse tabs only for line continuation and indentation.</p>\n</li>\n<li><p><code>UT_Always</code> (in configuration: <code>Always</code>)\nUse tabs whenever we need to fill whitespace that spans at least from\none tab stop to the next one.</p>\n</li>\n</ul>\n",
            "options": [
                "Never",
                "ForIndentation",
                "ForContinuationAndIndentation",
                "Always"
            ]
        }
    }
}